{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lonboard","text":"<p>A Python library for fast, interactive geospatial vector data visualization in Jupyter.</p> <p>Building on cutting-edge technologies like GeoArrow and GeoParquet in conjunction with GPU-based map rendering, Lonboard aims to enable visualizing large geospatial datasets interactively through a simple interface.</p> <p></p> <p>3 million points rendered from a GeoPandas <code>GeoDataFrame</code> in JupyterLab.  Example notebook.</p>"},{"location":"#install","title":"Install","text":"<p>To install Lonboard using pip:</p> <pre><code>pip install lonboard\n</code></pre> <p>Lonboard is on conda-forge and can be installed using conda, mamba, or pixi. To install Lonboard using conda:</p> <pre><code>conda install -c conda-forge lonboard\n</code></pre> <p>To install from source, refer to the developer documentation.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>For the simplest rendering, pass geospatial data into the top-level <code>viz</code> function.</p> <pre><code>import geopandas as gpd\nfrom lonboard import viz\n\ngdf = gpd.GeoDataFrame(...)\nviz(gdf)\n</code></pre> <p>Under the hood, this delegates to a <code>ScatterplotLayer</code>, <code>PathLayer</code>, or <code>PolygonLayer</code>. Refer to the documentation and examples for more control over rendering.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation at developmentseed.org/lonboard.</p>"},{"location":"#why-the-name","title":"Why the name?","text":"<p>This is a new binding to the deck.gl geospatial data visualization library. A \"deck\" is the part of a skateboard you ride on. What's a fast, geospatial skateboard? A lonboard.</p> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#0103-2024-10-15","title":"[0.10.3] - 2024-10-15","text":""},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>Downgrade minimum traitlets version to fix use with Colab. developmentseed/lonboard!687</li> </ul>"},{"location":"CHANGELOG/#0102-2024-10-10","title":"[0.10.2] - 2024-10-10","text":""},{"location":"CHANGELOG/#fixes_1","title":"Fixes","text":"<ul> <li>Fix using <code>TripsLayer.from_movingpandas</code> with numpy v2.</li> </ul>"},{"location":"CHANGELOG/#0101-2024-10-08","title":"[0.10.1] - 2024-10-08","text":""},{"location":"CHANGELOG/#fixes_2","title":"Fixes","text":"<ul> <li>Fix import when pandas not installed.</li> </ul>"},{"location":"CHANGELOG/#0100-2024-10-07","title":"[0.10.0] - 2024-10-07","text":""},{"location":"CHANGELOG/#new","title":"New!","text":"<ul> <li>New <code>TripsLayer</code> for animating moving objects, which integrates with MovingPandas. See the Air Traffic Control example and the MovingPandas integration example.</li> <li>New <code>ColumnLayer</code> for rendering extruded cylinders. See the new <code>ColumnLayer</code> example.</li> <li>Removed required dependencies! <code>geopandas</code>, <code>pandas</code>, <code>shapely</code>, <code>pyarrow</code>, <code>matplotlib</code>, and <code>palettable</code> are now optional dependencies. Lonboard will still work out of the box with them, but they aren't required to use Lonboard. This gives Lonboard a smaller footprint and makes it easier to use in environments such as Pyodide.</li> <li>You can now draw bounding boxes on the map. This is exposed as the <code>selected_bounds</code> attribute on the <code>Map</code> object, stored as a two-dimensional bounding box <code>(minx, miny, maxx, maxy)</code>.</li> <li>Improved documentation</li> <li>How to use Lonboard in pyodide, a Python environment that is fully running in your browser.</li> <li>Add linked maps example by @ATL2001 in developmentseed/lonboard!655</li> <li>Add troubleshooting doc by @kylebarron in developmentseed/lonboard!654</li> <li>Add longraph to showcase by @kylebarron in developmentseed/lonboard!595</li> <li>New <code>Map.add_layer</code> method for easily adding more layer(s) to an existing <code>Map</code> instance.</li> <li>Add <code>highlight_color</code> to change the color of <code>auto_highlight</code> by @kylebarron in developmentseed/lonboard!666</li> <li>Use deterministic colors in <code>viz</code> by @kylebarron in developmentseed/lonboard!621</li> <li>Categorical data filtering. The <code>DataFilterExtension</code> now has a <code>filter_categories</code> attribute that lets you filter categorical data on the map. by @kylebarron in developmentseed/lonboard!609</li> </ul>"},{"location":"CHANGELOG/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The tooltip shown on hover was replaced with a side panel. You now must click on a geometry to view its attributes. By @vgeorge in developmentseed/lonboard!636</li> </ul>"},{"location":"CHANGELOG/#fixes_3","title":"Fixes","text":"<ul> <li>We've switched from storing <code>list</code> objects to storing <code>tuple</code> objects (e.g. the list of layers in a <code>Map</code>). The immutability of the <code>tuple</code> ensures that a any changes in the sequence of layers will be propagated to the frontend.Fixed in developmentseed/lonboard!620</li> <li>A class of bugs was fixed when using Arrow input, where the chunking structure of the main <code>table</code> did not match the chunking of accessors. Fixed in developmentseed/lonboard!644</li> <li>Fix reading from DuckDB with only geometry column by @kylebarron in developmentseed/lonboard!625</li> <li>Fix attribution by @vgeorge in developmentseed/lonboard!561</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@MarcSkovMadsen made their first contribution in developmentseed/lonboard!539</li> <li>@ATL2001 made their first contribution in developmentseed/lonboard!655</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.9.3...v0.10.0</p>"},{"location":"CHANGELOG/#093-2024-05-27","title":"[0.9.3] - 2024-05-27","text":""},{"location":"CHANGELOG/#fixes_4","title":"Fixes","text":"<ul> <li>Fix reprojecting GeoArrow input by @kylebarron in developmentseed/lonboard!532</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.9.2...v0.9.3</p>"},{"location":"CHANGELOG/#092-2024-05-14","title":"[0.9.2] - 2024-05-14","text":""},{"location":"CHANGELOG/#fixes_5","title":"Fixes","text":"<ul> <li>Reverse the layer order for automatically split geometry by @RaczeQ in developmentseed/lonboard!516</li> </ul>"},{"location":"CHANGELOG/#whats-changed","title":"What's Changed","text":"<ul> <li>Perf: Use ravel, not flatten, for numpy to pyarrow by @kylebarron in developmentseed/lonboard!512</li> <li>Update docstring in as_html by @kylebarron in developmentseed/lonboard!519</li> <li>Add type checks to fly_to by @kylebarron in developmentseed/lonboard!521</li> <li>Add pypi classifiers by @kylebarron in developmentseed/lonboard!523</li> </ul>"},{"location":"CHANGELOG/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@RaczeQ made their first contribution in developmentseed/lonboard!516</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.9.1...v0.9.2</p>"},{"location":"CHANGELOG/#091-2024-05-07","title":"[0.9.1] - 2024-05-07","text":""},{"location":"CHANGELOG/#fixes_6","title":"Fixes","text":"<ul> <li>Fix parquet-wasm WASM version mismatch by @kylebarron in developmentseed/lonboard!508</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.9.0...v0.9.1</p>"},{"location":"CHANGELOG/#090-2024-05-06","title":"[0.9.0] - 2024-05-06","text":""},{"location":"CHANGELOG/#new_1","title":"New!","text":"<ul> <li>Direct DuckDB Spatial integration. Refer to the DuckDB example notebook and the DuckDB page in the documentation. by @kylebarron in developmentseed/lonboard!498</li> <li>Add overture buildings notebook by @kylebarron in developmentseed/lonboard!479</li> <li>Adding PathStyleExtension code by @shriv in developmentseed/lonboard!487</li> <li>Handle mixed geometry types in <code>viz</code> by @kylebarron in developmentseed/lonboard!495</li> <li>Render map as static HTML file by @kylebarron in developmentseed/lonboard!474. You can use <code>Map.as_html</code> to render a map in notebook environments that support HTML but not widgets.</li> <li>Improved integration with geoarrow-pyarrow by @kylebarron in developmentseed/lonboard!470</li> </ul>"},{"location":"CHANGELOG/#fixes_7","title":"Fixes","text":"<ul> <li>Updated Map keyword arguments by @kylebarron in developmentseed/lonboard!496</li> <li>validate basemap style is a url by @kylebarron in developmentseed/lonboard!497</li> </ul>"},{"location":"CHANGELOG/#new-contributors_2","title":"New Contributors","text":"<ul> <li>@willemarcel made their first contribution in developmentseed/lonboard!486</li> <li>@shriv made their first contribution in developmentseed/lonboard!487</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.8.0...v0.9.0</p>"},{"location":"CHANGELOG/#080-2024-04-05","title":"[0.8.0] - 2024-04-05","text":""},{"location":"CHANGELOG/#new_2","title":"New!","text":"<ul> <li>A new <code>PolygonLayer</code>! This layer renders polygon outlines for easier visibility. @kylebarron in developmentseed/lonboard!330</li> <li>An example using <code>PolygonLayer</code> by @naomatheus in developmentseed/lonboard!351</li> <li>Sync view state between JS and Python by @kylebarron in developmentseed/lonboard!448</li> <li>Support geoarrow array input into <code>viz()</code> by @kylebarron in developmentseed/lonboard!427</li> <li>Internal architecture documentation by @kylebarron in developmentseed/lonboard!450</li> </ul>"},{"location":"CHANGELOG/#fixes_8","title":"Fixes","text":"<ul> <li>Fix CLI with unset <code>geometry_name</code> by @kylebarron in developmentseed/lonboard!451</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.7.1...v0.8.0</p>"},{"location":"CHANGELOG/#071-2024-03-22","title":"[0.7.1] - 2024-03-22","text":""},{"location":"CHANGELOG/#fixes_9","title":"Fixes","text":"<ul> <li>Fix CLI with geopackage files by @kylebarron in developmentseed/lonboard!434</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.7.0...v0.7.1</p>"},{"location":"CHANGELOG/#070-2024-03-21","title":"[0.7.0] - 2024-03-21","text":""},{"location":"CHANGELOG/#new_3","title":"New!","text":"<ul> <li>There's a new command-line interface (CLI)! Use the <code>lonboard</code> command to quickly visualize one or more data files readable by GDAL! For example: <code>lonboard admins.geojson features.gpkg</code>. By @kylebarron in developmentseed/lonboard!379</li> <li>Type hinting for constructors and <code>from_geopandas</code> method. This should make it easier to pass the correct parameters into layers. This has been tested to work in IDEs like VSCode, but unfortunately appears not to work in JupyterLab. By @kylebarron in developmentseed/lonboard!399</li> </ul> <ul> <li>Warn on missing CRS. One of the most common reasons that you might see an empty map is from accidentally visualizing data that is not in EPSG 4326 (longitude-latitude). We now emit a warning for data that doesn't have a CRS defined on the data. By @kylebarron in developmentseed/lonboard!395.</li> <li>Lonboard is now on <code>conda-forge</code>! Install with <code>conda install -c conda-forge lonboard</code>. By @giswqs in developmentseed/lonboard!223</li> <li>Add PointCloudLayer. By @kylebarron in developmentseed/lonboard!396</li> <li>Add fly-to map action to \"fly\" the map to a new location. By @kylebarron in developmentseed/lonboard!408</li> <li>Docs showcase page by @kylebarron in developmentseed/lonboard!401</li> <li>Improve default colors in <code>viz</code>. We now attempt to apply some basic styling onto data passed into <code>viz</code>. This will likely further improve in the future. By @kylebarron in developmentseed/lonboard!389</li> </ul>"},{"location":"CHANGELOG/#fixes_10","title":"Fixes","text":"<ul> <li>Set exported HTML height to 100% by @kylebarron in developmentseed/lonboard!377</li> <li>Raise error on single input to MultiRangeSlider by @kylebarron in developmentseed/lonboard!367</li> <li>Fix pandas <code>to_numeric</code> FutureWarning by @kylebarron in developmentseed/lonboard!368</li> <li>Fix viewing polygons in local html files by @kylebarron in developmentseed/lonboard!387</li> <li>Fix: fix sliced array input for reprojection by @kylebarron in developmentseed/lonboard!391</li> <li>Fix: Don't reproject for epsg:4326 input by @kylebarron in developmentseed/lonboard!392</li> <li>Fix: Fix weighted centroid calculation by @kylebarron in developmentseed/lonboard!393</li> <li>Fix <code>viz()</code> with <code>__geo_interface__</code> input by @kylebarron in developmentseed/lonboard!426</li> <li>Add DataFilterExtension notebook to website by @kylebarron in developmentseed/lonboard!362</li> <li>Allow non-compliant geoarrow CRS metadata by @kylebarron in developmentseed/lonboard!369</li> <li>Automatically parse geoarrow.wkb to native geoarrow by @kylebarron in developmentseed/lonboard!372</li> <li>Parse GeoParquet metadata by @kylebarron in developmentseed/lonboard!407</li> <li>CLI: 'crs' in geoparquet metadata should be optional. by @jwass in developmentseed/lonboard!411</li> </ul>"},{"location":"CHANGELOG/#other-changes","title":"Other changes","text":"<ul> <li>Creating a new user bug report by @emmalu in developmentseed/lonboard!386</li> <li>Update epic template by @emmalu in developmentseed/lonboard!382</li> <li>NormalAccessor by @naomatheus in developmentseed/lonboard!376</li> <li>Conda: Try including <code>manifest.in</code> file for <code>static</code> folder inclusion by @kylebarron in developmentseed/lonboard!421</li> <li>Switch to animated hero image by @kylebarron in developmentseed/lonboard!423</li> <li>Add CRS to GeoDataFrame in notebook examples by @kylebarron in developmentseed/lonboard!419</li> </ul>"},{"location":"CHANGELOG/#new-contributors_3","title":"New Contributors","text":"<ul> <li>@emmalu made their first contribution in developmentseed/lonboard!382</li> <li>@naomatheus made their first contribution in developmentseed/lonboard!376</li> <li>@jwass made their first contribution in developmentseed/lonboard!411</li> <li>@giswqs made their first contribution in developmentseed/lonboard!223</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.6.0...v0.7.0</p>"},{"location":"CHANGELOG/#060-2024-02-13","title":"[0.6.0] - 2024-02-13","text":""},{"location":"CHANGELOG/#new_4","title":"New!","text":"<ul> <li>DataFilterExtension by @kylebarron in developmentseed/lonboard!278</li> <li>Multi-range sliders for DataFilterExtension by @kylebarron in developmentseed/lonboard!340</li> <li>BitmapLayer and BitmapTileLayer by @kylebarron in developmentseed/lonboard!288</li> <li>Improved GeoArrow interop by @kylebarron in developmentseed/lonboard!308</li> <li>Allow passing a positional <code>layers</code> object into <code>Map</code> by @kylebarron in developmentseed/lonboard!319</li> <li>GeoArrow-based multithreaded coordinate reprojection by @kylebarron in developmentseed/lonboard!337</li> <li>Support <code>pyarrow.Table</code> with <code>geoarrow.pyarrow</code> extension types as geometry columns by @jorisvandenbossche in developmentseed/lonboard!218</li> <li>Add ecosystem/integrations documentation by @kylebarron in developmentseed/lonboard!350</li> </ul>"},{"location":"CHANGELOG/#fixes_11","title":"Fixes","text":"<ul> <li>Add font to index.css to fix static HTML export by @jtmiclat in developmentseed/lonboard!284</li> <li>Fix displaying tooltip for first row by @kylebarron in developmentseed/lonboard!287</li> <li>accept matplotlib colormap input to apply_cmap by @kylebarron in developmentseed/lonboard!289</li> <li>Use preferred OSM tile url by @kylebarron in developmentseed/lonboard!290</li> <li>set max zoom on osm layer by @kylebarron in developmentseed/lonboard!291</li> <li>Update contributor docs by @kylebarron in developmentseed/lonboard!316</li> <li>Check epsg:4326 bounds in layer creation by @kylebarron in developmentseed/lonboard!317</li> <li>add reference for installing from source by @kylebarron in developmentseed/lonboard!318</li> <li>Fix inferring number of rows per chunk by @kylebarron in developmentseed/lonboard!327</li> <li>Fix null checks by @kylebarron in developmentseed/lonboard!331</li> <li>Set max number of chunks per layer by @kylebarron in developmentseed/lonboard!332</li> <li>Move accessor length validation to serialization by @kylebarron in developmentseed/lonboard!333</li> <li>Deduplicate serialization for accessors by @kylebarron in developmentseed/lonboard!334</li> <li>Multi-dimensional GPU-based data filtering by @kylebarron in developmentseed/lonboard!335</li> <li>Bump anywidget to 0.9 &amp; simplify Wasm initialization by @kylebarron in developmentseed/lonboard!344</li> <li>Fix null checks by @kylebarron in developmentseed/lonboard!348</li> <li>docs fixes by @kylebarron in developmentseed/lonboard!354</li> <li>Add <code>DataFilterExtension</code> example by @kylebarron in developmentseed/lonboard!358</li> <li>fix arc layer default arguments by @kylebarron in developmentseed/lonboard!359</li> </ul>"},{"location":"CHANGELOG/#new-contributors_4","title":"New Contributors","text":"<ul> <li>@jtmiclat made their first contribution in developmentseed/lonboard!284</li> <li>@jorisvandenbossche made their first contribution in developmentseed/lonboard!218</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.5.0...v0.6.0</p>"},{"location":"CHANGELOG/#050-2023-12-01","title":"[0.5.0] - 2023-12-01","text":""},{"location":"CHANGELOG/#new-features","title":"New Features","text":"<ul> <li>Improve map height by @vgeorge in developmentseed/lonboard!220</li> <li>Add method to apply a categorical colormap by @kylebarron in developmentseed/lonboard!251</li> <li>Deduce environment and set map height in colab and vscode by @kylebarron in developmentseed/lonboard!252</li> <li>Add various carto basemaps as options by @kylebarron in developmentseed/lonboard!268</li> <li>Sync the clicked index back to Python by @kylebarron in developmentseed/lonboard!270</li> <li>Set <code>width_min_pixels</code> in PathLayer example by @kylebarron in developmentseed/lonboard!276</li> <li>Bump deck.gl layers for performance benefits by @kylebarron in developmentseed/lonboard!277</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.2...v0.5.0</p>"},{"location":"CHANGELOG/#042-2023-11-13","title":"[0.4.2] - 2023-11-13","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed ScatterplotLayer rendering by @kylebarron in developmentseed/lonboard!246</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.1...v0.4.2</p>"},{"location":"CHANGELOG/#041-2023-11-13","title":"[0.4.1] - 2023-11-13","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed Polygon rendering by @kylebarron in developmentseed/lonboard!243</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.0...v0.4.1</p>"},{"location":"CHANGELOG/#040-2023-11-10","title":"[0.4.0] - 2023-11-10","text":""},{"location":"CHANGELOG/#new-features_1","title":"New Features","text":"<ul> <li>New <code>HeatmapLayer</code></li> <li>New <code>experimental</code> module, with new layers (<code>ArcLayer</code>, <code>TextLayer</code>) and \"layer extensions\" (<code>BrushingExtension</code>, <code>CollisionFilterExtension</code>).</li> <li>New \"migration\" notebook using the experimental <code>ArcLayer</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Add pandas v2 requirement by @kylebarron in developmentseed/lonboard!229</li> <li>bump anywidget to 0.7.1 by @kylebarron in developmentseed/lonboard!233</li> </ul> <p>This should error when the JS files have not been included when packaging.</p> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.3.0...v0.4.0</p>"},{"location":"CHANGELOG/#030-2023-11-07","title":"[0.3.0] - 2023-11-07","text":""},{"location":"CHANGELOG/#new-features_2","title":"New Features","text":"<ul> <li>Save widget to standalone HTML file by @kylebarron in developmentseed/lonboard!199</li> <li>Support for rendering inside Visual Studio Code</li> <li>Allow customized picking radius by @kylebarron in developmentseed/lonboard!212</li> <li>New example notebooks</li> <li>Automatically downcast data types in <code>from_geopandas</code> by @kylebarron in developmentseed/lonboard!195</li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Allow pandas series as accessor to FloatAccessor by @kylebarron in developmentseed/lonboard!208</li> <li>Raise error when creating class with unknown keyword argument by @kylebarron in developmentseed/lonboard!209</li> <li>fix tooltip rendering when not hovering over an object by @kylebarron in developmentseed/lonboard!215</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.2.0...v0.3.0</p>"},{"location":"CHANGELOG/#020-2023-11-01","title":"[0.2.0] - 2023-11-01","text":""},{"location":"CHANGELOG/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Layers no longer render a map object. Instead, pass one or more layer instances into a <code>lonboard.Map</code> and display that.</li> </ul>"},{"location":"CHANGELOG/#new-features_3","title":"New Features","text":"<ul> <li>Support multiple layers on a single map.</li> <li>Tooltip with data information on hover.</li> <li>Allow hex string color input to ColorAccessor.</li> <li>Versioned documentation website</li> <li>New examples</li> <li>Experimental API to change map height</li> </ul>"},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Fix handling of 3d coordinates by @kylebarron in developmentseed/lonboard!160</li> <li>Improved validation error messages by @kylebarron in developmentseed/lonboard!161</li> </ul>"},{"location":"CHANGELOG/#new-contributors_5","title":"New Contributors","text":"<ul> <li>@chrisgervang made their first contribution in developmentseed/lonboard!150</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.1.2...v0.2.0</p>"},{"location":"CHANGELOG/#012-2023-10-24","title":"[0.1.2] - 2023-10-24","text":"<ul> <li>Actually update <code>@geoarrow/deck.gl-layers</code> to version 0.2.0, whoops \ud83d\ude05</li> </ul>"},{"location":"CHANGELOG/#011-2023-10-23","title":"[0.1.1] - 2023-10-23","text":"<ul> <li>Updates to <code>@geoarrow/deck.gl-layers</code> version 0.2.0:</li> <li>Fixed MultiPolygon rendering</li> <li>Fixed rendering of polygons with holes.</li> <li>Polygon rendering is roughly 35% faster.</li> </ul>"},{"location":"CHANGELOG/#010-2023-10-17","title":"[0.1.0] - 2023-10-17","text":"<ul> <li>Initial public release.</li> <li>Initial support for <code>ScatterplotLayer</code>, <code>PathLayer</code>, and <code>SolidPolygonLayer</code>.</li> </ul>"},{"location":"alternatives/","title":"Alternatives to Lonboard","text":""},{"location":"alternatives/#lonboard-vs-ipyleaflet","title":"Lonboard vs ipyleaflet","text":"<p>ipyleaflet is a great rendering library for small- and medium-sized datasets. ipyleaflet supports a broad range of data types and formats and gives the user broad control over how to render data.</p> <p>The downside of ipyleaflet is that it doesn't support large datasets as well. It uses GeoJSON to transfer data to the frontend, which is slow to write, slow to read, and large in transit. Additionally, leaflet's primary goal is not to support very large quantities of data.</p>"},{"location":"alternatives/#lonboard-vs-pydeck","title":"Lonboard vs pydeck","text":"<p>Pydeck is a full-featured binding from Python to deck.gl. Pydeck attempts to cover most of the deck.gl API. It's harder to use binary data transport with pydeck, and similarly to ipyleaflet will usually serialize data to GeoJSON.</p> <p>Lonboard does not try to cover deck.gl's full API, but rather has an opinionated approach that nudges users to the fastest rendering for many common use cases.</p>"},{"location":"alternatives/#why-not-contribute-back-to-pydeck","title":"Why not contribute back to pydeck?","text":"<p>Pydeck and lonboard have very different goals.</p> <p>A stated goal of pydeck is to be non-opinionated and to allow users with various data sources (GeoJSON strings, URLs to arbitrary data sources, etc.) to render. It makes sense for \"official\" bindings to be non-opinionated, but lonboard takes an opposite tack. By forcing users to use Arrow, we can get reliably fast performance the very common use case of rendering <code>GeoDataFrame</code>s. A downside here is that an Arrow-based implementation has required dependencies that pydeck wouldn't want. <code>pyarrow</code> on the Python side is 90MB on disk. Arrow JS on the JS side is ~200kb, and the default <code>parquet-wasm</code> build is ~1MB.</p> <p>Pydeck is tightly tied into the deck.gl JSON renderer, which allows describing a map state fully in JSON. It's not clear how this would work with the JavaScript GeoArrow layers.</p> <p>Aside from this, pydeck and lonboard use different widget architectures. Pydeck is built on the historical ipywidget layout, using the widget cookiecutter as inspiration and having a separate Jupyter Widget package published to NPM. Lonboard takes a newer approach (unavailable at the time pydeck was created) that uses Anywidget, vastly simplifying the widget process.</p>"},{"location":"alternatives/#lonboard-vs-keplergl-jupyter","title":"Lonboard vs kepler.gl-jupyter","text":"<p>kepler.gl is a JavaScript application focused on presenting a simple, high-level visualization and analysis toolkit to browser-based users. Just like Lonboard, it's built on top of deck.gl. It also has Python bindings via kepler.gl-jupyter.</p> <p>kepler.gl is a very good tool for data analysis and exploration in the browser. On the contrary, Lonboard targets users who plan to do most analysis in Python, but want the best performance to visualize the maximum amount of data. Lonboard should have better rendering performance, but has no user interface to analyze data in the browser.</p> <p>kepler.gl-jupyter serializes to GeoJSON and kepler.gl uses GeoJSON-like JavaScript objects internally; it therefore has the downside of creating a large text string in Python and serializing that to JavaScript. kepler.gl-jupyter is great for creating standalone static HTML files containing a dataset, but those files tend to be very large, since they contain embedded GeoJSON.</p>"},{"location":"alternatives/#lonboard-vs-datashader","title":"Lonboard vs datashader","text":"<p>Datashader is a truly scalable rendering library. Datashader will re-render your data from scratch when panning around in a map. This allows datashader to aggregate the source data before rendering. Datashader minimizes the amount of data being rendered and thus, in theory, Datashader should perform well for datasets as large as your computer's memory.</p> <p>Lonboard is not scalable in the same sense. It doesn't minimize the amount of data being rendered. If you ask to plot a GeoDataFrame with 3 million points, every single one of those points is transferred to the GPU and drawn to your screen. In contrast to Datashader, Lonboard should perform well for datasets whose geometries fit in your computer's GPU memory, which is usually much smaller than your computer's total memory.</p>"},{"location":"cli/","title":"Command-line Interface","text":"<p>Lonboard includes a command-line interface for quickly viewing local data files.</p> <p>The CLI is accessible either through the <code>lonboard</code> entry point or via <code>python -m lonboard</code> the latter can be useful to ensure that the <code>lonboard</code> instance you're calling is the same as your current <code>python</code> environment.</p> <pre><code>&gt; lonboard --help\nUsage: lonboard [OPTIONS] [FILES]...\n\n  Interactively visualize geospatial data using Lonboard.\n\n  This CLI can be used either to quickly view local files or to create static\n  HTML files.\n\nOptions:\n  -o, --output PATH   The output path for the generated HTML file. If not\n                      provided, will save to a temporary file.\n  --open / --no-open  Whether to open a web browser tab with the generated\n                      map. By default, the web browser is not opened when\n                      --output is provided, but is in other cases.\n  --help              Show this message and exit.\n</code></pre> <p>For example:</p> <pre><code>lonboard data.geojson\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Performance is a critical goal of lonboard. Below are a couple pieces of information you should know to understand lonboard's performance characteristics, as well as some advice for how to get the best performance.</p>"},{"location":"performance/#performance-characteristics","title":"Performance Characteristics","text":"<p>There are two distinct parts to the performance of lonboard: one is the performance of transferring data to the browser and the other is the performance of rendering the data once it's there.</p> <p>In general, these parts are completely distinct. Even if it takes a while to load the data in your browser, the map might be snappy once it loads, and vice versa.</p>"},{"location":"performance/#data-transfer","title":"Data Transfer","text":"<p>Lonboard creates an interactive visualization of your data in your browser. In order to do this, your GeoDataFrame needs to be transferred from your Python environment to your browser.</p> <p>In the case where your Python session is running locally (on the same machine as your browser), this data transfer is extremely fast: less than a second in most cases.</p> <p>However, in the case where your Python session is running on a remote server (such as Google Colab, Binder, or a JupyterHub instance), this data transfer means downloading the data to your local browser. Therefore, when running lonboard from a remote server, your internet speed and the quantity of data you pass into a layer will have large impacts on the data transfer speed.</p> <p>Under the hood, lonboard uses efficient compression (in the form of GeoParquet) to transfer data to the browser, but compression can only do so much; the data still needs to be downloaded.</p>"},{"location":"performance/#rendering-performance","title":"Rendering Performance","text":"<p>Once the data has been transfered from your Python session to your browser, it needs to be rendered.</p> <p>The biggest thing to note is that \u2014 in contrast to projects like datashader \u2014 lonboard does not minimize the amount of data being rendered. If you pass a GeoDataFrame with 10 million coordinates, lonboard will attempt to render all 10 million coordinates at once.</p> <p>The primary determinant of the maximum amount of data you can render with lonboard is your computer's hardware. Via the underlying deck.gl library, lonboard ultimately renders geometries using your computer's Graphics Processing Unit (GPU). If you have a better GPU card, you'll be able to visualize more data.</p> <p>Lonboard is more efficient at rendering than previous libraries, but there will always be some quantity of data beyond which your browser tab is likely to crash while attempting to render. Testing on a recent MacBook Pro M2 computer, lonboard has been able to render a few million points with minimal lag.</p>"},{"location":"performance/#performance-advice","title":"Performance Advice","text":""},{"location":"performance/#use-a-local-python-session","title":"Use a local Python session","text":"<p>Moving from a remote Python environment to a local Python environment is often impractical, but this change will make it much faster to visualize data, especially over slow internet connections.</p>"},{"location":"performance/#mutate-an-existing-map-where-possible","title":"Mutate an existing map where possible","text":"<p>Whenever you create a new map object, all the data will be transfered from your Python environment to your browser. Whenever mutating an existing map object, only the changed data will be sent to the browser.</p> <p>Therefore, unless changing the content of the data being rendered, do not create a new map object. If you're changing the rendering options of an existing map, prefer mutating the existing map object.</p> <p>Bad</p> <pre><code>map1 = ScatterplotLayer.from_geopandas(my_geodataframe)\n\n# Next cell\nmap2 = ScatterplotLayer.from_geopandas(\n    my_geodataframe,\n    get_fill_color=[255, 0, 0]\n)\n</code></pre> <p>Good</p> <pre><code>map1 = ScatterplotLayer.from_geopandas(my_geodataframe)\n\n# Next cell\nmap1.get_fill_color = [255, 0, 0]\n</code></pre> <p>In the first (bad) case, the content of <code>my_geodataframe</code> will be sent twice to the browser. In the second (good) case, the content of <code>my_geodataframe</code> will be sent only once to the browser, and only the tiny array <code>[255, 0, 0]</code> will be transfered on the second call.</p>"},{"location":"performance/#remove-columns-before-rendering","title":"Remove columns before rendering","text":"<p>All columns included in the <code>GeoDataFrame</code> will be transferred to the browser for visualization. (In the future, these other columns will be used to display a tooltip when hovering over/clicking on a geometry.)</p> <p>Especially in the case of a remote Python session, excluding unnecessary attribute columns will make data transfer to the browser faster.</p>"},{"location":"performance/#use-arrow-based-data-types-in-pandas","title":"Use Arrow-based data types in Pandas","text":"<p>As of Pandas 2.0, Pandas supports two backends for data types: either the original numpy-based data types or new data types based on Arrow and the pyarrow library.</p> <p>The first thing that lonboard does when visualizing data is converting from Pandas to an Arrow representation. Any non-geometry attribute columns will be converted to Arrow, so if you're using Arrow-based data types in Pandas already, this step will be \"free\" as no conversion is needed.</p> <p>If you're loading data from a geospatial file format, as of <code>pyogrio</code> version 0.7, you can load data to Arrow-based columns with</p> <pre><code>import pyogrio\nimport pandas as pd\n\narrow_to_pandas_kwargs = {\n    'types_mapper': lambda pa_dtype: pd.ArrowDtype(pa_dtype)\n}\ngdf = pyogrio.read_dataframe(\n    \"path/to/file\",\n    use_arrow=True,\n    arrow_to_pandas_kwargs=arrow_to_pandas_kwargs\n)\n</code></pre> <p>or directly from GeoPandas with <code>geopandas.read_file</code> with <code>engine=\"pyogrio\"</code>:</p> <pre><code>import geopandas as gpd\nimport pandas as pd\n\narrow_to_pandas_kwargs = {\n    'types_mapper': lambda pa_dtype: pd.ArrowDtype(pa_dtype)\n}\ngdf = gpd.read_file(\n    \"path/to/file\",\n    engine=\"pyogrio\",\n    use_arrow=True,\n    arrow_to_pandas_kwargs=arrow_to_pandas_kwargs\n)\n</code></pre> <p>See the pandas guide on data types and the <code>pandas.ArrowDtype</code> class for more information.</p>"},{"location":"performance/#simplify-geometries-before-rendering","title":"Simplify geometries before rendering","text":"<p>Simplifying geometries before rendering reduces the total number of coordinates and can make a visualization snappier. At this point, lonboard does not offer built-in geometry simplification. This is something you would need to do before passing data to lonboard.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#map-does-not-display","title":"Map does not display","text":""},{"location":"troubleshooting/#anywidget-not-available","title":"<code>anywidget</code> not available","text":"<p>Open the browser console to check for any errors generated by the JavaScript code, either with:</p> <ul> <li>option+command+I or similar on Linux/Windows</li> <li>Right click on the page and choose \"inspect\". (Note that in JupyterLab you may need to Shift + right click to access the browser menu.) Then in the top of the browser toolbar that opened on the right side of the screen, select \"Console\". Any errors will be highlighted in red.</li> </ul> <p>If you see something like</p> <pre><code>Failed to load model class 'AnyModel' from module 'anywidget'\nError: No version of module anywidget is registered\n</code></pre> <p>then anywidget's JavaScript code is not available.</p> <p>This can happen if you installed Lonboard after having launched Jupyter. Reloading the browser tab (not the Jupyter kernel) will usually fix this. In general, make sure you install Lonboard before launching Jupyter.</p> <p>If you're using Lonboard in a cloud-hosted Jupyter environment such as JupyterHub, you need to ensure that <code>anywidget</code> is installed in the environment from which Jupyter is launched. This is often different from the user's environment. See also more discussion in issue #397.</p>"},{"location":"troubleshooting/#incompatible-deckgl-versions","title":"Incompatible deck.gl versions","text":"<p>There can only be one version of the JavaScript deck.gl library loaded by a single webpage. This means using other Jupyter widgets that also depend on deck.gl, such as <code>maplibre</code>, will cause Lonboard to crash. See issue #640.</p>"},{"location":"troubleshooting/#map-displays-but-no-data-is-visible","title":"Map displays but no data is visible","text":"<p>If you don't see your data on the map, the most likely answer is that the data is displaying but with a configuration that makes it hard to see.</p> <p>As of Lonboard 0.10, only <code>lonboard.viz</code> will infer default rendering parameters that try to look \"good\". All layer constructors use deck.gl's default parameters, which may or may not default to what you want.</p> <p>For example, in a <code>ScatterplotLayer</code>, the default for <code>radius_units</code> is <code>\"meters\"</code>. So if you pass only <code>get_radius=10</code>, you likely won't see any data on the map because 10 meters is too small to render when zoomed out.</p> <p>To ensure that your data is in fact rendering, look for an attribute name ending in <code>min_pixels</code>. For example, the <code>ScatterplotLayer</code> has <code>radius_min_pixels</code>. If you set this to <code>10</code>, then it should be easy to verify that the data was correctly loaded. Then from there you can customize the full suite of visualization parameters.</p>"},{"location":"api/basemap/","title":"lonboard.basemap","text":""},{"location":"api/basemap/#lonboard.basemap.CartoBasemap","title":"lonboard.basemap.CartoBasemap","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Basemap styles provided by Carto.</p> <p>Refer to Carto documentation for information on styles.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.DarkMatter","title":"DarkMatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DarkMatter = 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json'\n</code></pre> <p>A dark map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.DarkMatterNoLabels","title":"DarkMatterNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DarkMatterNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A dark map style without labels.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.Positron","title":"Positron  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Positron = 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'\n</code></pre> <p>A light map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.PositronNoLabels","title":"PositronNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PositronNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/positron-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A light map style without labels.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.Voyager","title":"Voyager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Voyager = 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json'\n</code></pre> <p>A light, colored map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.VoyagerNoLabels","title":"VoyagerNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VoyagerNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/voyager-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A light, colored map style without labels.</p>"},{"location":"api/colormap/","title":"lonboard.colormap","text":""},{"location":"api/colormap/#lonboard.colormap","title":"lonboard.colormap","text":""},{"location":"api/colormap/#lonboard.colormap.DiscreteColormap","title":"DiscreteColormap  <code>module-attribute</code>","text":"<pre><code>DiscreteColormap = Mapping[Any, RGBColor]\n</code></pre> <p>A type definition for a discrete colormap.</p> <p>For example, for a land cover colormap, you may want to use the following dict:</p> <pre><code>color_map = {\n    \"Open Water\": [70, 107, 159],\n    \"Perennial Snow/Ice\": [209, 222, 248],\n    \"Developed, Open Space\": [222, 197, 197],\n    \"Developed, Low Intensity\": [217, 146, 130],\n    \"Developed, Medium Intensity\": [235, 0, 0],\n    \"Developed, High Intensity\": [171, 0, 0],\n    \"Barren Land\": [179, 172, 159],\n    \"Deciduous Forest\": [104, 171, 95],\n    \"Evergreen Forest\": [28, 95, 44],\n    \"Mixed Forest\": [181, 197, 143],\n    \"Shrub/Scrub\": [204, 184, 121],\n    \"Herbaceous\": [223, 223, 194],\n    \"Hay/Pasture\": [220, 217, 57],\n    \"Cultivated Crops\": [171, 108, 40],\n    \"Woody Wetlands\": [184, 217, 235],\n    \"Emergent Herbaceous Wetlands\": [108, 159, 184],\n}\n</code></pre> <p>This corresponds to the following well-known color palette from the National Land Cover Database.</p> <p> </p> <p>Keep in mind that the type of the key of the <code>color_map</code> dictionary is important. If your data is represented as a string, the keys of the <code>color_map</code> must also be represented as strings. If your data is represented as an integer, the keys of the colormap should be integers.</p>"},{"location":"api/colormap/#lonboard.colormap.RGBColor","title":"RGBColor  <code>module-attribute</code>","text":"<pre><code>RGBColor = Union[\n    Tuple[int, int, int], Tuple[int, int, int, int], Sequence[int], str\n]\n</code></pre> <p>A type definition for an RGB or RGBA color value</p> <p>All values must range between 0 and 255 (inclusive). If only three values are provided, the fourth (alpha) channel will be inferred as 255 (meaning full opacity, no transparency).</p> <p>This can also be a string that refers to a matplotlib named color.</p>"},{"location":"api/colormap/#lonboard.colormap.apply_categorical_cmap","title":"apply_categorical_cmap","text":"<pre><code>apply_categorical_cmap(\n    values: Union[\n        NDArray,\n        Series,\n        Array,\n        ChunkedArray,\n        ArrowArrayExportable,\n        ArrowStreamExportable,\n    ],\n    cmap: DiscreteColormap,\n    *,\n    alpha: int | float | None = None\n) -&gt; NDArray[uint8]\n</code></pre> <p>Apply a colormap to a column of categorical values.</p> <p>If you're working with categorical data in Pandas or GeoPandas, and especially when those categories are strings, you should use the pandas Categorical type. This will use much less memory and be faster to operate on. <code>apply_categorical_cmap</code> will be 2-3x faster (and use less memory itself) when your data is already represented as a categorical data type.</p> <p>The key of the colormap must be the same as the data type of the column of values you pass in. Usually this will be string, when you perform the lookup on a string column of data.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Union[NDArray, Series, Array, ChunkedArray, ArrowArrayExportable, ArrowStreamExportable]</code>)           \u2013            <p>A numpy array, pandas Series, pyarrow Array or pyarrow ChunkedArray of data. The data type of this column must match the keys of the colormap.</p> </li> <li> <code>cmap</code>               (<code>DiscreteColormap</code>)           \u2013            <p>A dictionary mapping keys to colors. See [DiscreteColormap] for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>alpha</code>               (<code>int | float | None</code>)           \u2013            <p>The default alpha value for entries in the colormap that do not have an alpha value defined. Alpha must be an integer between 0 and 255 (inclusive).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[uint8]</code>           \u2013            <p>A two dimensional numpy array with data type np.uint8. The second dimension will have a length of either <code>3</code> if <code>alpha</code> is <code>None</code>, or <code>4</code> is each color has an alpha value.</p> </li> </ul>"},{"location":"api/colormap/#lonboard.colormap.apply_continuous_cmap","title":"apply_continuous_cmap","text":"<pre><code>apply_continuous_cmap(\n    values: NDArray[floating],\n    cmap: Union[Palette, Colormap],\n    *,\n    alpha: Union[float, int, NDArray[floating], None] = None\n) -&gt; NDArray[uint8]\n</code></pre> <p>Apply a colormap to a column of continuous values.</p> <p>If you pass in a <code>Palette</code> object from the <code>palettable</code> package, this will use matplotlib's LinearSegmentedColormap under the hood. As described in Matplotlib's referenced docstring:</p> <p>The lookup table is generated using linear interpolation for each primary color, with the 0-1 domain divided into any number of segments.</p> <p>This means that input values are linearly combined from the two nearest colormap colors.</p> <p>If you pass in a Matplotlib <code>Colormap</code> object, this will use the lookup method defined in that class.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>NDArray[floating]</code>)           \u2013            <p>A numpy array of floating point values ranging from 0 to 1.</p> </li> <li> <code>cmap</code>               (<code>Union[Palette, Colormap]</code>)           \u2013            <p>Any matplotlib <code>Colormap</code> or <code>Palette</code> object from the <code>palettable</code> package.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>alpha</code>               (<code>Union[float, int, NDArray[floating], None]</code>)           \u2013            <p>Alpha must be a scalar between 0 and 1, a sequence of such floats with shape matching <code>values</code>, or None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[uint8]</code>           \u2013            <p>A two dimensional numpy array with data type np.uint8. The second dimension will have a length of either <code>3</code> if <code>alpha</code> is <code>None</code>, or <code>4</code> is each color has an alpha value.</p> </li> </ul>"},{"location":"api/controls/","title":"lonboard.controls","text":""},{"location":"api/controls/#lonboard.controls.MultiRangeSlider","title":"lonboard.controls.MultiRangeSlider","text":"<p>               Bases: <code>VBox</code></p> <p>A widget for multiple ranged sliders.</p> <p>This is designed to be used with the DataFilterExtension when you want to filter on 2 to 4 columns on the same time.</p> <p>If you have only a single filter, use an ipywidgets FloatRangeSlider directly.</p>"},{"location":"api/controls/#lonboard.controls.MultiRangeSlider--example","title":"Example","text":"<pre><code>from ipywidgets import FloatRangeSlider\n\nslider1 = FloatRangeSlider(\n    value=(2, 5),\n    min=0,\n    max=10,\n    step=0.1,\n    description=\"First slider: \"\n)\nslider2 = FloatRangeSlider(\n    value=(30, 40),\n    min=0,\n    max=50,\n    step=1,\n    description=\"Second slider: \"\n)\nmulti_slider = MultiRangeSlider([slider1, slider2])\nmulti_slider\n</code></pre> <p>Then to propagate updates to a rendered layer, call jsdlink to connect the two widgets.</p> <pre><code>from ipywidgets import jsdlink\n\njsdlink(\n    (multi_slider, \"value\"),\n    (layer, \"filter_range\")\n)\n</code></pre> <p>As you change the slider, the <code>filter_range</code> value on the layer class should be updated.</p>"},{"location":"api/map/","title":"Map","text":""},{"location":"api/map/#lonboard.Map","title":"lonboard.Map","text":"<p>The top-level class used to display a map in a Jupyter Widget.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer, SolidPolygonLayer\n\n# A GeoDataFrame with Point geometries\npoint_gdf = gpd.GeoDataFrame()\npoint_layer = ScatterplotLayer.from_geopandas(\n    point_gdf,\n    get_fill_color=[255, 0, 0],\n)\n\n# A GeoDataFrame with Polygon geometries\npolygon_gdf = gpd.GeoDataFrame()\npolygon_layer = SolidPolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\n\nm = Map([point_layer, polygon_layer])\n</code></pre>"},{"location":"api/map/#lonboard.Map.__init__","title":"__init__","text":"<pre><code>__init__(\n    layers: Union[BaseLayer, Sequence[BaseLayer]], **kwargs: Unpack[MapKwargs]\n) -&gt; None\n</code></pre> <p>Create a new Map.</p> <p>Aside from the <code>layers</code> argument, pass keyword arguments for any other attribute defined in this class.</p> <p>Parameters:</p> <ul> <li> <code>layers</code>               (<code>Union[BaseLayer, Sequence[BaseLayer]]</code>)           \u2013            <p>One or more layers to render on this map.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A Map object.</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.add_layer","title":"add_layer","text":"<pre><code>add_layer(\n    layers: BaseLayer | Sequence[BaseLayer] | Map,\n    *,\n    focus: bool = False,\n    reset_zoom: bool = False\n)\n</code></pre> <p>Add one or more new layers to the map.</p> <p>Examples:</p> <pre><code>from lonboard import viz\n\nm = viz(some_data)\nm.add_layer(viz(more_data), focus=True)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>layers</code>               (<code>BaseLayer | Sequence[BaseLayer] | Map</code>)           \u2013            <p>New layers to add to the map. This can be: - a layer instance - a list or tuple of layer instances - another <code>Map</code> instance, in which case its layers will be added to this   map. This lets you pass the result of <code>viz</code> into this method.</p> </li> <li> <code>focus</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, set the view state of the map based on the newly-added layers. Defaults to False.</p> </li> <li> <code>reset_zoom</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, set the view state of the map based on all layers. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>description</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.as_html","title":"as_html","text":"<pre><code>as_html() -&gt; HTML\n</code></pre> <p>Render the current map as a static HTML file in IPython.</p> <p>Warning</p> <p>The primary, recommended way to display a map is by leaving it as the last line in a cell.</p> <pre><code>from lonboard import Map\n\nm = Map(layers=[])\nm\n</code></pre> <p>This method exists to support environments that are unable to display Jupyter Widgets. Some aspects of Lonboard are unavailable with this display method. In particular, the map is unable to send any information back to Python. So <code>selected_index</code> will never be populated, for example.</p> <p>Returns:</p> <ul> <li> <code>HTML</code>           \u2013            <p>IPython HTML object.</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.basemap_style","title":"basemap_style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>basemap_style = BasemapUrl(PositronNoLabels)\n</code></pre> <p>A URL to a MapLibre-compatible basemap style.</p> <p>Various styles are provided in <code>lonboard.basemap</code>.</p> <ul> <li>Type: <code>str</code>, holding a URL hosting a basemap style.</li> <li>Default   <code>lonboard.basemap.CartoBasemap.PositronNoLabels</code></li> </ul>"},{"location":"api/map/#lonboard.Map.custom_attribution","title":"custom_attribution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_attribution = tag(sync=True)\n</code></pre> <p>Custom attribution to display on the map.</p> <p>This attribute supports the same format as the <code>attribution</code> property in the Maplibre API.</p> <ul> <li>Type: <code>str</code> or <code>List[str]</code></li> <li>Default: <code>None</code></li> </ul> <p>You can provide either a single string or a list of strings for custom attributions. If an attribution value is set in the map style, it will be displayed in addition to this custom attribution.</p> <p>Example:</p> <pre><code>```py\nm = Map(\n    layers,\n    custom_attribution=\"Development Seed\"\n)\n```\n</code></pre> <p>Example:</p> <pre><code>```py\nm = Map(\n    layers,\n    custom_attribution=[\"Development Seed\", \"OpenStreetMap\"]\n)\n```\n</code></pre>"},{"location":"api/map/#lonboard.Map.fly_to","title":"fly_to","text":"<pre><code>fly_to(\n    *,\n    longitude: Union[int, float],\n    latitude: Union[int, float],\n    zoom: Union[int, float],\n    duration: int = 4000,\n    pitch: Union[int, float] = 0,\n    bearing: Union[int, float] = 0,\n    curve: Optional[Union[int, float]] = None,\n    speed: Optional[Union[int, float]] = None,\n    screen_speed: Optional[Union[int, float]] = None\n)\n</code></pre> <p>\"Fly\" the map to a new location.</p> <p>Parameters:</p> <ul> <li> <code>longitude</code>               (<code>Union[int, float]</code>)           \u2013            <p>The longitude of the new viewport.</p> </li> <li> <code>latitude</code>               (<code>Union[int, float]</code>)           \u2013            <p>The latitude of the new viewport.</p> </li> <li> <code>zoom</code>               (<code>Union[int, float]</code>)           \u2013            <p>The zoom of the new viewport.</p> </li> <li> <code>pitch</code>               (<code>Union[int, float]</code>, default:                   <code>0</code> )           \u2013            <p>The pitch of the new viewport. Defaults to 0.</p> </li> <li> <code>bearing</code>               (<code>Union[int, float]</code>, default:                   <code>0</code> )           \u2013            <p>The bearing of the new viewport. Defaults to 0.</p> </li> <li> <code>duration</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>The number of milliseconds for the viewport transition to take. Defaults to 4000.</p> </li> <li> <code>curve</code>               (<code>Optional[Union[int, float]]</code>, default:                   <code>None</code> )           \u2013            <p>The zooming \"curve\" that will occur along the flight path. Default <code>1.414</code>.</p> </li> <li> <code>speed</code>               (<code>Optional[Union[int, float]]</code>, default:                   <code>None</code> )           \u2013            <p>The average speed of the animation defined in relation to <code>curve</code>, it linearly affects the duration, higher speed returns smaller durations and vice versa. Default <code>1.2</code>.</p> </li> <li> <code>screen_speed</code>               (<code>Optional[Union[int, float]]</code>, default:                   <code>None</code> )           \u2013            <p>The average speed of the animation measured in screenfuls per second. Similar to speed it linearly affects the duration, when specified speed is ignored.</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.layers","title":"layers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers = tag(sync=True, **widget_serialization)\n</code></pre> <p>One or more <code>Layer</code> objects to display on this map.</p>"},{"location":"api/map/#lonboard.Map.parameters","title":"parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameters = tag(sync=True)\n</code></pre> <p>GPU parameters to pass to deck.gl.</p> <p>This is an advanced API. The vast majority of users should not need to touch this setting.</p> <p>Note</p> <p>The docstring below is copied from upstream deck.gl documentation. Any usage of <code>GL</code> refers to the constants defined in <code>@luma.gl/constants</code> here, which comes from the MDN docs here.</p> <p>In place of any <code>GL</code> constant, you can use the underlying integer it represents. For example, instead of the JS</p> <pre><code>depthFunc: GL.LEQUAL\n</code></pre> <p>referring to the MDN docs, you should use</p> <pre><code>depthFunc: 0x0203\n</code></pre> <p>Note that these parameters do not yet work with integer keys. If you would like to use integer keys, open an issue.</p> <p>Expects an object with GPU parameters. Before each frame is rendered, this object will be passed to luma.gl's <code>setParameters</code> function to reset the GPU context parameters, e.g. to disable depth testing, change blending modes etc. The default parameters set by <code>Deck</code> on initialization are the following:</p> <pre><code>{\n  blend: true,\n  blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA],\n  polygonOffsetFill: true,\n  depthTest: true,\n  depthFunc: GL.LEQUAL\n}\n</code></pre> <p>Refer to the luma.gl setParameters API for documentation on supported parameters and values.</p> <pre><code>import GL from '@luma.gl/constants';\nnew Deck({\n  // ...\n  parameters: {\n    blendFunc: [GL.ONE, GL.ONE, GL.ONE, GL.ONE],\n    depthTest: false\n  }\n});\n</code></pre> <p>Notes:</p> <ul> <li>Any GPU <code>parameters</code> prop supplied to individual layers will still override the   global <code>parameters</code> when that layer is rendered.</li> </ul>"},{"location":"api/map/#lonboard.Map.picking_radius","title":"picking_radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>picking_radius = tag(sync=True)\n</code></pre> <p>Extra pixels around the pointer to include while picking (such as for a tooltip).</p> <p>This is helpful when rendered objects are difficult to target, for example irregularly shaped icons, small moving circles or interaction by touch.</p> <ul> <li>Type: <code>int</code></li> <li>Default: <code>5</code></li> </ul>"},{"location":"api/map/#lonboard.Map.selected_bounds","title":"selected_bounds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_bounds = tag(sync=True)\n</code></pre> <p>Bounds selected by the user, represented as a tuple of floats ordered as</p> <pre><code>(minx, miny, maxx, maxy)\n</code></pre>"},{"location":"api/map/#lonboard.Map.set_view_state","title":"set_view_state","text":"<pre><code>set_view_state(\n    *,\n    longitude: Optional[float] = None,\n    latitude: Optional[float] = None,\n    zoom: Optional[float] = None,\n    pitch: Optional[float] = None,\n    bearing: Optional[float] = None\n) -&gt; None\n</code></pre> <p>Set the view state of the map.</p> <p>Any parameters that are unset will not be changed.</p> <p>Other Parameters:</p> <ul> <li> <code>longitude</code>               (<code>Optional[float]</code>)           \u2013            <p>the new longitude to set on the map. Defaults to None.</p> </li> <li> <code>latitude</code>               (<code>Optional[float]</code>)           \u2013            <p>the new latitude to set on the map. Defaults to None.</p> </li> <li> <code>zoom</code>               (<code>Optional[float]</code>)           \u2013            <p>the new zoom to set on the map. Defaults to None.</p> </li> <li> <code>pitch</code>               (<code>Optional[float]</code>)           \u2013            <p>the new pitch to set on the map. Defaults to None.</p> </li> <li> <code>bearing</code>               (<code>Optional[float]</code>)           \u2013            <p>the new bearing to set on the map. Defaults to None.</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.show_tooltip","title":"show_tooltip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_tooltip = tag(sync=True)\n</code></pre> <p>Whether to render a tooltip on hover on the map.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/map/#lonboard.Map.to_html","title":"to_html","text":"<pre><code>to_html(\n    filename: Union[str, Path, TextIO, IO[str], None] = None,\n    title: Optional[str] = None,\n) -&gt; Union[None, str]\n</code></pre> <p>Save the current map as a standalone HTML file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>Union[str, Path, TextIO, IO[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>where to save the generated HTML file.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>title</code>               (<code>Optional[str]</code>)           \u2013            <p>A title for the exported map. This will show as the browser tab name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[None, str]</code>           \u2013            <p>If <code>filename</code> is not passed, returns the HTML content as a <code>str</code>.</p> </li> </ul>"},{"location":"api/map/#lonboard.Map.use_device_pixels","title":"use_device_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>use_device_pixels = tag(sync=True)\n</code></pre> <p>Controls the resolution of the drawing buffer used for rendering.</p> <p>Setting this to <code>false</code> or a number &lt;= 1 will improve performance on high resolution displays.</p> <p>Note: This parameter must be passed to the <code>Map()</code> constructor. It cannot be changed once the map has been created.</p> <p>The available options are:</p> <ul> <li><code>true</code>: Device (physical) pixels resolution is used for rendering, this resolution   is defined by <code>window.devicePixelRatio</code>. On Retina/HD systems this resolution is   usually twice as big as CSS pixels resolution.</li> <li><code>false</code>: CSS pixels resolution (equal to the canvas size) is used for rendering.</li> <li> <p><code>Number</code> (Experimental): Specified Number is used as a custom ratio (drawing   buffer resolution to CSS pixel resolution) to determine drawing buffer size, a   value less than one uses resolution smaller than CSS pixels, gives better   performance but produces blurry images, a value greater than one uses resolution   bigger than CSS pixels resolution (canvas size), produces sharp images but at a   lower performance.</p> </li> <li> <p>Type: <code>float</code>, <code>int</code> or <code>bool</code></p> </li> <li>Default: <code>true</code></li> </ul>"},{"location":"api/map/#lonboard.Map.view_state","title":"view_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>view_state = ViewStateTrait()\n</code></pre> <p>The view state of the map.</p> <ul> <li>Type: <code>ViewState</code></li> <li>Default: Automatically inferred from the data passed to the map.</li> </ul> <p>You can initialize the map to a specific view state using this property:</p> <pre><code>Map(\n    layers,\n    view_state={\"longitude\": -74.0060, \"latitude\": 40.7128, \"zoom\": 7}\n)\n</code></pre> <p>Note</p> <p>The properties of the view state are immutable. Use <code>set_view_state</code> to modify a map's view state once it's been initially rendered.</p>"},{"location":"api/map/#lonboard.models.ViewState","title":"lonboard.models.ViewState","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"api/map/#lonboard.models.ViewState.bearing","title":"bearing  <code>instance-attribute</code>","text":"<pre><code>bearing: float\n</code></pre> <p>Bearing angle in degrees. <code>0</code> is north.</p>"},{"location":"api/map/#lonboard.models.ViewState.latitude","title":"latitude  <code>instance-attribute</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Latitude at the map center.</p>"},{"location":"api/map/#lonboard.models.ViewState.longitude","title":"longitude  <code>instance-attribute</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Longitude at the map center</p>"},{"location":"api/map/#lonboard.models.ViewState.pitch","title":"pitch  <code>instance-attribute</code>","text":"<pre><code>pitch: float\n</code></pre> <p>Pitch angle in degrees. <code>0</code> is top-down.</p>"},{"location":"api/map/#lonboard.models.ViewState.zoom","title":"zoom  <code>instance-attribute</code>","text":"<pre><code>zoom: float\n</code></pre> <p>Zoom level.</p>"},{"location":"api/traits/","title":"lonboard.traits","text":""},{"location":"api/traits/#lonboard.traits.ColorAccessor","title":"lonboard.traits.ColorAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A trait to validate input for a deck.gl color accessor.</p> <p>Various input is allowed:</p> <ul> <li>A <code>list</code> or <code>tuple</code> with three or four integers, ranging between 0 and 255   (inclusive). This will be used as the color for all objects.</li> <li>A <code>str</code> representing a hex color or \"well known\" color interpretable by   matplotlib.colors.to_rgba. See also matplotlib's   list of named   colors.</li> <li>A numpy <code>ndarray</code> with two dimensions and data type <code>np.uint8</code>. The   size of the second dimension must be <code>3</code> or <code>4</code>, and will correspond to either RGB   or RGBA colors.</li> <li>A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The inner   size of the fixed size list must be <code>3</code> or <code>4</code> and its child must have type   <code>uint8</code>.</li> <li>Any Arrow fixed size list array from a library that implements the Arrow   PyCapsule   Interface.</li> </ul> <p>You can use helpers in the <code>lonboard.colormap</code> module (i.e. <code>apply_continuous_cmap</code>) to simplify constructing numpy arrays for color values.</p>"},{"location":"api/traits/#lonboard.traits.DashArrayAccessor","title":"lonboard.traits.DashArrayAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A trait to validate input for a deck.gl dash accessor.</p> <p>Primarily used in <code>PathStyleExtension</code>.</p> <p>Various input is allowed:</p> <ul> <li>A <code>list</code> or <code>tuple</code> with 2 integers. This defines the dash size and gap size   respectively.</li> <li>A numpy <code>ndarray</code> with two dimensions and numeric data type. The size of the   second dimension must be <code>2</code>.</li> <li>A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The inner   size of the fixed size list must be <code>2</code>.</li> <li>Any Arrow fixed size list array from a library that implements the Arrow   PyCapsule   Interface.</li> </ul>"},{"location":"api/traits/#lonboard.traits.FloatAccessor","title":"lonboard.traits.FloatAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A trait to validate input for a deck.gl float accessor.</p> <p>Various input is allowed:</p> <ul> <li>An <code>int</code> or <code>float</code>. This will be used as the value for all objects.</li> <li>A numpy <code>ndarray</code> with a numeric data type. This will be casted to an array of   data type <code>np.float32</code>. Each value in the array will be used as   the value for the object at the same row index.</li> <li>A pandas <code>Series</code> with a numeric data type. This will be casted to an array of   data type <code>np.float32</code>. Each value in the array will be used as   the value for the object at the same row index.</li> <li>A pyarrow <code>FloatArray</code>, <code>DoubleArray</code>   or <code>ChunkedArray</code> containing either a <code>FloatArray</code> or   <code>DoubleArray</code>. Each value in the array will be used as the value for the object at   the same row index.</li> <li>Any Arrow floating point array from a library that implements the Arrow PyCapsule   Interface.   This includes data structures from   <code>geoarrow-rust</code>.</li> </ul>"},{"location":"api/traits/#lonboard.traits.FilterValueAccessor","title":"lonboard.traits.FilterValueAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A trait to validate input for the <code>get_filter_value</code> accessor added by the <code>DataFilterExtension</code>, which can have between 1 and 4 float values per row.</p> <p>Various input is allowed:</p> <ul> <li>An <code>int</code> or <code>float</code>. This will be used as the value for all objects. The   <code>filter_size</code> of the   <code>DataFilterExtension</code> instance   must be 1.</li> <li>A one-dimensional numpy <code>ndarray</code> with a numeric data type. This will be casted to   an array of data type <code>np.float32</code>. Each value in the array will   be used as the value for the object at the same row index. The <code>filter_size</code> of   the <code>DataFilterExtension</code> instance   must be 1.</li> <li>A two-dimensional numpy <code>ndarray</code> with a numeric data type. This will be casted to   an array of data type <code>np.float32</code>. Each value in the array will   be used as the value for the object at the same row index. The <code>filter_size</code> of   the <code>DataFilterExtension</code> instance   must match the size of the second dimension of the array.</li> <li>A pandas <code>Series</code> with a numeric data type. This will be casted to an array of   data type <code>np.float32</code>. Each value in the array will be used as   the value for the object at the same row index. The <code>filter_size</code> of the   <code>DataFilterExtension</code> instance   must be 1.</li> <li>A pyarrow <code>FloatArray</code>, <code>DoubleArray</code>   or <code>ChunkedArray</code> containing either a <code>FloatArray</code> or   <code>DoubleArray</code>. Each value in the array will be used as the value for the object at   the same row index. The <code>filter_size</code> of the   <code>DataFilterExtension</code> instance   must be 1.</li> </ul> <p>Alternatively, you can pass any corresponding Arrow data structure from a library   that implements the Arrow PyCapsule   Interface. - A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The child   array of the fixed size list must be of floating point type. The <code>filter_size</code> of   the <code>DataFilterExtension</code> instance   must match the list size.</p> <p>Alternatively, you can pass any corresponding Arrow data structure from a library   that implements the Arrow PyCapsule   Interface.</p>"},{"location":"api/traits/#lonboard.traits.NormalAccessor","title":"lonboard.traits.NormalAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl \"normal\" accessor</p> <p>This is primarily used in the [lonboard.PointCloudLayer].</p> <p>Acceptable inputs: - A <code>list</code> or <code>tuple</code> with three <code>int</code> or <code>float</code> values. This will be used as the   normal for all objects. - A numpy ndarray with two dimensions and floating point type. The size of the   second dimension must be 3, i.e. its shape must be <code>(N, 3)</code>. - a pyarrow <code>FixedSizeListArray</code> or <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s   where the size of the inner fixed size list 3. The child array must have type   float32. - Any Arrow array that matches the above restrictions from a library that implements   the Arrow PyCapsule   Interface.</p>"},{"location":"api/traits/#lonboard.traits.PointAccessor","title":"lonboard.traits.PointAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl point accessor.</p> <p>Various input is allowed:</p> <ul> <li>A numpy <code>ndarray</code> with two dimensions and data type <code>np.uint8</code>. The   size of the second dimension must be <code>2</code> or <code>3</code>, and will correspond to either XY   or XYZ positions.</li> <li>A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The inner   size of the fixed size list must be <code>2</code> or <code>3</code> and its child must be of floating   point type.</li> </ul>"},{"location":"api/traits/#lonboard.traits.ArrowTableTrait","title":"lonboard.traits.ArrowTableTrait","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A trait to validate input for a geospatial Arrow-backed table</p> <p>Allowed input includes:</p> <ul> <li>A pyarrow <code>Table</code> or containing a geometry column with GeoArrow metadata.</li> <li>Any GeoArrow table from a library that implements the Arrow PyCapsule   Interface.   This includes the   <code>GeoTable</code>   class from   <code>geoarrow-rust</code>.</li> </ul>"},{"location":"api/traits/#lonboard.experimental.traits.TimestampAccessor","title":"lonboard.experimental.traits.TimestampAccessor","text":"<p>               Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl coordinate-timestamp accessor.</p> <p>deck.gl handles timestamps on the GPU as float32 values. This class will validate that the input timestamps are representable as float32 integers, and will automatically reduce the precision of input data if necessary to fit inside a float32.</p> <p>Accepted input includes:</p> <ul> <li>A pyarrow <code>ListArray</code> containing a temporal array such as a     TimestampArray. Each value in the array will be used as the value for the object     at the same row index.</li> <li>Any Arrow list array containing a temporal array from a library that implements   the Arrow PyCapsule   Interface.</li> </ul>"},{"location":"api/viz/","title":"viz","text":""},{"location":"api/viz/#lonboard.viz","title":"lonboard.viz","text":"<pre><code>viz(\n    data: Union[VizDataInput, List[VizDataInput], Tuple[VizDataInput, ...]],\n    *,\n    scatterplot_kwargs: Optional[ScatterplotLayerKwargs] = None,\n    path_kwargs: Optional[PathLayerKwargs] = None,\n    polygon_kwargs: Optional[PolygonLayerKwargs] = None,\n    map_kwargs: Optional[MapKwargs] = None,\n    con: Optional[DuckDBPyConnection] = None\n) -&gt; Map\n</code></pre> <p>A high-level function to plot your data easily.</p> <p>The goal of this function is to make it simple to get something showing on a map. For more control over rendering, construct <code>Map</code> and <code>Layer</code> objects directly.</p> <p>This function accepts a variety of geospatial inputs:</p> <ul> <li>GeoPandas <code>GeoDataFrame</code>.</li> <li>GeoPandas <code>GeoSeries</code>.</li> <li>numpy array of Shapely objects.</li> <li>Single Shapely object.</li> <li> <p>A DuckDB query with a spatial column from DuckDB Spatial.</p> <p>Warning</p> <p>The DuckDB query must be run with <code>duckdb.sql()</code> or <code>duckdb.DuckDBPyConnection.sql()</code> and not with <code>duckdb.execute()</code> or <code>duckdb.DuckDBPyConnection.execute()</code>.</p> <p>For example</p> <pre><code>import duckdb\nfrom lonboard import viz\n\nsql = \"SELECT * FROM spatial_table;\"\nquery = duckdb.sql(sql)\nviz(query)\n</code></pre> <p>If you're using a custom connection, ensure you pass in the <code>con</code> parameter:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\ncon = duckdb.connect()\nsql = \"SELECT * FROM spatial_table;\"\nquery = con.sql(sql)\nviz(query, con=con)\n</code></pre> <p>You can also render an entire table by using the <code>table()</code> method:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\ncon = duckdb.connect()\ncon.execute(\"CREATE TABLE spatial_table AS ...;\")\nviz(con.table(), con=con)\n</code></pre> <p>Warning</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326.</p> </li> <li> <p>Any Python class with a <code>__geo_interface__</code> property conforming to the     Geo Interface protocol.</p> </li> <li><code>dict</code> holding GeoJSON-like data.</li> <li>pyarrow <code>Table</code> with a geometry column marked with a     GeoArrow extension type.</li> <li>pyarrow <code>Array</code> marked with a GeoArrow extension type defined by geoarrow-pyarrow.</li> </ul> <p>Alternatively, you can pass a <code>list</code> or <code>tuple</code> of any of the above inputs.</p> <p>If you want to easily add more data, to an existing map, you can pass the output of <code>viz</code> into <code>Map.add_layer</code>.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[VizDataInput, List[VizDataInput], Tuple[VizDataInput, ...]]</code>)           \u2013            <p>a data object of any supported type.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>scatterplot_kwargs</code>               (<code>Optional[ScatterplotLayerKwargs]</code>)           \u2013            <p>a <code>dict</code> of parameters to pass down to all generated <code>ScatterplotLayer</code>s.</p> </li> <li> <code>path_kwargs</code>               (<code>Optional[PathLayerKwargs]</code>)           \u2013            <p>a <code>dict</code> of parameters to pass down to all generated <code>PathLayer</code>s.</p> </li> <li> <code>polygon_kwargs</code>               (<code>Optional[PolygonLayerKwargs]</code>)           \u2013            <p>a <code>dict</code> of parameters to pass down to all generated <code>PolygonLayer</code>s.</p> </li> <li> <code>map_kwargs</code>               (<code>Optional[MapKwargs]</code>)           \u2013            <p>a <code>dict</code> of parameters to pass down to the generated <code>Map</code>.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>)           \u2013            <p>the active DuckDB connection. This is necessary in some cases when passing in a DuckDB query. In particular, if you're using a non-global DuckDB connection and if your SQL query outputs the default <code>GEOMETRY</code> type.</p> </li> </ul> <p>For more control over rendering, construct <code>Map</code> and <code>Layer</code> objects directly.</p> <p>Returns:</p> <ul> <li> <code>Map</code>           \u2013            <p>widget visualizing the provided data.</p> </li> </ul>"},{"location":"api/viz/#lonboard._viz.VizDataInput","title":"VizDataInput  <code>module-attribute</code>","text":"<pre><code>VizDataInput = Union[\n    GeoDataFrame,\n    GeoSeries,\n    Table,\n    NDArray[object_],\n    BaseGeometry,\n    ArrowArrayExportable,\n    ArrowStreamExportable,\n    GeoInterfaceProtocol,\n    Dict[str, Any],\n    DuckDBPyRelation,\n]\n</code></pre> <p>A type definition for allowed data inputs to the <code>viz</code> function.</p>"},{"location":"api/layer-extensions/","title":"Layer Extensions","text":"<p>Layer extensions are bonus features that you can optionally add to the core deck.gl layers.</p> <p>Layer extensions are in an experimental state. Some things are known to not yet work:</p> <ul> <li>Modifying the extensions on a layer by mutating its <code>extensions</code> list via <code>append</code> or <code>pop</code>. It should work, however, by creating a new list and assigning <code>layer.extensions = new_extensions_list</code>.</li> </ul> <p>If you encounter issues, please create an issue with reproducible steps.</p>"},{"location":"api/layer-extensions/brushing-extension/","title":"BrushingExtension","text":"<p>Screen recording from U.S. County-to-County Migration example.</p>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension","title":"lonboard.layer_extension.BrushingExtension","text":"<p>Adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position.</p>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--example","title":"Example","text":"<p>An example is in the County-to-County Migration notebook.</p>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--layer-properties","title":"Layer Properties","text":"<p>This extension dynamically enables the following properties onto the layer(s) where it is included:</p>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--brushing_enabled","title":"<code>brushing_enabled</code>","text":"<p>Enable/disable brushing. If brushing is disabled, all objects are rendered.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--brushing_target","title":"<code>brushing_target</code>","text":"<p>The position used to filter each object by. One of the following:</p> <ul> <li><code>\"source\"</code>: Use the primary position for each object. This can mean different   things depending on the layer. It usually refers to the coordinates returned by   <code>getPosition</code> or <code>getSourcePosition</code> accessors.</li> <li><code>\"target\"</code>: Use the secondary position for each object. This may not be available   in some layers. It usually refers to the coordinates returned by   <code>getTargetPosition</code> accessor.</li> <li><code>\"source_target\"</code>: Use both the primary position and secondary position for each   object. Show object if either is in brushing range.</li> <li> <p><code>\"custom\"</code>: Some layers may not describe their data objects with one or two   coordinates, for example <code>PathLayer</code> and <code>PolygonLayer</code>. Use this option with the   <code>get_brushing_target</code> prop to provide a custom position that each object should be   filtered by.</p> </li> <li> <p>Type: <code>str</code>, optional</p> <p>One of: \"source\" | \"target\" | \"source_target\" | \"custom\"</p> </li> <li> <p>Default: <code>\"source\"</code></p> </li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--brushing_radius","title":"<code>brushing_radius</code>","text":"<p>The brushing radius centered at the pointer, in meters. If a data object is within this circle, it is rendered; otherwise it is hidden.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>10000</code></li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.layer_extension.BrushingExtension--get_brushing_target","title":"<code>get_brushing_target</code>","text":"<p>An arbitrary position for each object that it will be filtered by.</p> <p>Only effective if <code>brushing_target</code> is set to <code>\"custom\"</code>.</p> <ul> <li>Type: PointAccessor, optional<ul> <li>If a point is provided, it is used as the target for all rows.</li> <li>If an array of points is provided, each value in the array will be used as the   target for the row at the same row index.</li> </ul> </li> <li>Default: <code>None</code>.</li> </ul>"},{"location":"api/layer-extensions/collision-filter-extension/","title":"CollisionFilterExtension","text":""},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.layer_extension.CollisionFilterExtension","title":"lonboard.layer_extension.CollisionFilterExtension","text":"<p>Allows layers to hide overlapping objects.</p>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.layer_extension.CollisionFilterExtension--layer-properties","title":"Layer Properties","text":"<p>This extension dynamically enables the following properties onto the layer(s) where it is included:</p>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.layer_extension.CollisionFilterExtension--collision_enabled","title":"<code>collision_enabled</code>","text":"<p>Enable/disable collisions. If collisions are disabled, all objects are rendered.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.layer_extension.CollisionFilterExtension--collision_group","title":"<code>collision_group</code>","text":"<p>Collision group this layer belongs to. If it is not set, the 'default' collision group is used</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.layer_extension.CollisionFilterExtension--get_collision_priority","title":"<code>get_collision_priority</code>","text":"<p>Accessor for collision priority. Must return a number in the range -1000 -&gt; 1000. Features with higher values are shown preferentially.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the priority for all objects.</li> <li>If an array is provided, each value in the array will be used as the priority   for the object at the same row index.</li> </ul> </li> <li>Default: <code>0</code>.</li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/","title":"DataFilterExtension","text":""},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension","title":"lonboard.layer_extension.DataFilterExtension","text":"<p>Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties.</p>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--example","title":"Example","text":"<pre><code>from lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\nfrom lonboard.layer_extension import DataFilterExtension\n\ngdf = gpd.GeoDataFrame(...)\nextension = DataFilterExtension()\nlayer = ScatterplotLayer.from_geopandas(\n    gdf,\n    extensions=[extension],\n    get_filter_value=gdf[\"filter_value\"], # replace with desired column\n    filter_range=[0, 5] # replace with desired filter range\n)\n</code></pre> <p>The <code>DataFilterExtension</code> allows filtering on 1 to 4 attributes at the same time. So if you have four numeric columns of interest, you can filter on the intersection of all of them.</p> <p>For easy visualization, we suggest connecting the <code>DataFilterExtension</code> to an interactive slider from <code>ipywidgets</code>.</p> <pre><code>from ipywidgets import FloatRangeSlider\n\nslider = FloatRangeSlider(\n    value=(2, 5),\n    min=0,\n    max=10,\n    step=0.1,\n    description=\"Slider: \"\n)\nslider\n\njsdlink(\n    (slider, \"value\"),\n    (layer, \"filter_range\")\n)\n</code></pre> <p>If you have 2 to 4 columns, use a <code>MultiRangeSlider</code>, which combines multiple <code>FloatRangeSlider</code> objects in a form that the <code>DataFilterExtension</code> expects.</p> <pre><code>from ipywidgets import FloatRangeSlider, jsdlink\n\nslider1 = FloatRangeSlider(\n    value=(2, 5),\n    min=0,\n    max=10,\n    step=0.1,\n    description=\"First slider: \"\n)\nslider2 = FloatRangeSlider(\n    value=(30, 40),\n    min=0,\n    max=50,\n    step=1,\n    description=\"Second slider: \"\n)\nmulti_slider = MultiRangeSlider([slider1, slider2])\nmulti_slider\n\njsdlink(\n    (multi_slider, \"value\"),\n    (layer, \"filter_range\")\n)\n</code></pre>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--important-notes","title":"Important notes","text":"<ul> <li>The DataFilterExtension only supports float32 data, so integer data will be casted   to float32.</li> <li>The DataFilterExtension copies all data referenced by <code>get_filter_value</code> to the   GPU, so it will increase memory pressure on the GPU.</li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--layer-properties","title":"Layer Properties","text":"<p>This extension dynamically enables the following properties onto the layer(s) where it is included:</p>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_categories","title":"<code>filter_categories</code>","text":"<p>The list of categories that should be rendered. If an object's filtered category is in the list, the object will be rendered; otherwise it will be hidden. This prop can be updated on user input or animation with very little cost.</p> <p>Format:</p> <ul> <li>If category_size is 1: ['category1', 'category2']</li> <li>If category_size is 2 to 4:     [['category1', 'category2', ...], ['category3', ...], ...] for each filtered     property, respectively.</li> </ul> <p>The maximum number of supported is determined by the category_size:</p> <ul> <li>If category_size is 1: 128 categories</li> <li>If category_size is 2: 64 categories per dimension</li> <li>If category_size is 3 or 4: 32 categories per dimension.</li> </ul> <p>If this value is exceeded any categories beyond the limit will be ignored.</p> <p>Default: <code>[0]</code></p>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_enabled","title":"<code>filter_enabled</code>","text":"<p>Enable/disable the data filter. If the data filter is disabled, all objects are rendered.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_range","title":"<code>filter_range</code>","text":"<p>The bounds which defines whether an object should be rendered. If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden. This prop can be updated on user input or animation with very little cost.</p> <p>Format:</p> <p>If <code>filter_size</code> is 1, provide a single tuple of <code>(min, max)</code>.</p> <p>If <code>filter_size</code> is 2 to 4, provide a list of tuples: <code>[(min0, max0), (min1, max1), ...]</code> for each filtered property, respectively.</p> <ul> <li>Type: either Tuple[float, float] or List[Tuple[float, float]], optional</li> <li>Default: <code>(-1, 1)</code></li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_soft_range","title":"<code>filter_soft_range</code>","text":"<p>If specified, objects will be faded in/out instead of abruptly shown/hidden.</p> <p>When the filtered value is outside of the bounds defined by <code>filter_soft_range</code> but still within the bounds defined by <code>filter_range</code>, the object will be rendered as \"faded\".</p> <ul> <li>Type: Tuple[float, float], optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_transform_size","title":"<code>filter_transform_size</code>","text":"<p>When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if <code>filter_soft_range</code> is specified.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--filter_transform_color","title":"<code>filter_transform_color</code>","text":"<p>When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if <code>filter_soft_range</code> is specified.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--get_filter_value","title":"<code>get_filter_value</code>","text":"<p>Accessor to retrieve the value for each object that it will be filtered by.</p> <ul> <li>Type: FilterValueAccessor<ul> <li>If a scalar value is provided, it is used as the value for all objects.</li> <li>If an array is provided, each value in the array will be used as the value for   the object at the same row index.</li> </ul> </li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension--get_filter_category","title":"<code>get_filter_category</code>","text":"<p>Accessor to retrieve the category for each object that it will be filtered by.</p> <ul> <li>Type: FilterValueAccessor<ul> <li>If a scalar value is provided, it is used as the value for all objects.</li> <li>If an array is provided, each value in the array will be used as the value for   the object at the same row index.</li> </ul> </li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension.category_size","title":"category_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category_size = tag(sync=True)\n</code></pre> <p>The size of the category filter (number of columns to filter by).</p> <p>The category filter can show/hide data based on 1-4 properties of each object.</p> <ul> <li>Type: <code>int</code>. This is required if using category-based filtering.</li> <li>Default 0.</li> </ul>"},{"location":"api/layer-extensions/data-filter-extension/#lonboard.layer_extension.DataFilterExtension.filter_size","title":"filter_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_size = tag(sync=True)\n</code></pre> <p>The size of the filter (number of columns to filter by).</p> <p>The data filter can show/hide data based on 1-4 numeric properties of each object.</p> <ul> <li>Type: <code>int</code>. This is required if using range-based filtering.</li> <li>Default 1.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/","title":"PathStyleExtension","text":""},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension","title":"lonboard.layer_extension.PathStyleExtension","text":"<p>Adds selected features to the PathLayer and composite layers that render the PathLayer, e.g. PolygonLayer.</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--example","title":"Example","text":"<p>Deck.gl example deck.gl/docs/api-reference/extensions/path-style-extension</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--layer-properties","title":"Layer Properties","text":"<p>This extension dynamically enables the following properties onto the layer(s) where it is included:</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--get_dash_array","title":"<code>get_dash_array</code>","text":"<p>Must be specified if the dash option is enabled. The dash array to draw each path with <code>[dash_size, gap_size]</code> relative to the width of the path.</p> <ul> <li>Type: DashArrayAccessor, optional<ul> <li>If a scalar value is provided, it is used as the value for all objects. Pass   <code>[0, 0]</code> to draw the path in solid line.</li> <li>If an array is provided, each value in the array will be used as the value   for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0]</code>.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--dash_justified","title":"<code>dash_justified</code>","text":"<p>Only effective if <code>get_dash_array</code> is specified. If <code>True</code>, adjust gaps for the dashes to align at both ends. Overrides the effect of <code>high_precision_dash</code>.</p> <ul> <li>Type: <code>boolean</code>, optional</li> <li>Default <code>False</code>.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--get_offset","title":"<code>get_offset</code>","text":"<p>Must be specified if the <code>offset</code> option is enabled.</p> <p>The offset to draw each path with, relative to the width of the path. Negative offset is to the left hand side, and positive offset is to the right hand side. <code>0</code> extrudes the path so that it is centered at the specified coordinates.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the offset for all objects.</li> <li>If an array is provided, each value in the array will be used as the offset   for the object at the same row index.</li> </ul> </li> <li>Default: <code>None</code>.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--dash_gap_pickable","title":"<code>dash_gap_pickable</code>","text":"<p>Only effective if <code>get_dash_array</code> is specified. If <code>True</code>, gaps between solid strokes are pickable. If <code>False</code>, only the solid strokes are pickable.</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--remarks","title":"Remarks","text":""},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--limitations","title":"Limitations","text":"<p>WebGL2 has guaranteed support for up to 16 attributes per shader. The current implementation of <code>PathLayer</code> uses 13 attributes. Each one of the options of this extension adds one more attribute. In other words, if all options are enabled, the layer will not be able to use other extensions.</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension--tips-on-rendering-dash-lines","title":"Tips on Rendering Dash Lines","text":"<p>There are three modes to render dash lines with this extension:</p> <ol> <li>Default: dash starts from the beginning of each line segment</li> <li>Justified: dash is stretched to center on each line segment</li> <li>High precision: dash is evaluated continuously from the beginning of a path</li> </ol> <p></p> <p>The above table illustrates the visual behavior of the three modes.</p> <p>The default mode works best if the data consists of long, disjoint paths. It renders dashes at exactly the defined lengths.</p> <p>The justified mode is guaranteed to render sharp, well-defined corners. This is great for rendering polyline shapes. However, the gap size may look inconsistent across line segments due to stretching.</p> <p>The high precision mode pre-calculates path length on the CPU, so it may be slower and use more resources for large datasets. When a path contains a lot of short segments, this mode yields the best result.</p>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension.dash","title":"dash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dash = tag(sync=True)\n</code></pre> <p>Add capability to render dashed lines.</p> <ul> <li>Type: <code>boolean</code>, optional</li> <li>Default False.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension.high_precision_dash","title":"high_precision_dash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>high_precision_dash = tag(sync=True)\n</code></pre> <p>Improve dash rendering quality in certain circumstances.</p> <p>Note that this option introduces additional performance overhead. See \"Remarks\".</p> <ul> <li>Type: <code>boolean</code>, optional</li> <li>Default <code>False</code>.</li> </ul>"},{"location":"api/layer-extensions/path-style-extension/#lonboard.layer_extension.PathStyleExtension.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset = tag(sync=True)\n</code></pre> <p>Add capability to offset lines.</p> <ul> <li>Type: <code>boolean</code>, optional</li> <li>Default <code>False</code>.</li> </ul>"},{"location":"api/layers/arc-layer/","title":"ArcLayer","text":"<p>Screen recording from U.S. County-to-County Migration example.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer","title":"lonboard.experimental.ArcLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>Render raised arcs joining pairs of source and target coordinates.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_height","title":"get_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_height = FloatAccessor(None, allow_none=True)\n</code></pre> <p>Height color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_source_color","title":"get_source_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_source_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>Source color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_source_position","title":"get_source_position  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_source_position = PointAccessor(None, allow_none=True)\n</code></pre> <p>Source position of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_target_color","title":"get_target_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_target_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>Target color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_target_position","title":"get_target_position  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_target_position = PointAccessor(None, allow_none=True)\n</code></pre> <p>Target position of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_tilt","title":"get_tilt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_tilt = FloatAccessor(None, allow_none=True)\n</code></pre> <p>Use to tilt the arc to the side if you have multiple arcs with the same source and target positions.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>0</code>.</li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_width","title":"get_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The line width of each object, in units specified by <code>widthUnits</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.great_circle","title":"great_circle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>great_circle = tag(sync=True)\n</code></pre> <p>If <code>True</code>, create the arc along the shortest path on the earth surface.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.num_segments","title":"num_segments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_segments = tag(sync=True)\n</code></pre> <p>The number of segments used to draw each arc.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>50</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait()\n</code></pre> <p>A GeoArrow table.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_max_pixels","title":"width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum line width in pixels.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_min_pixels","title":"width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum line width in pixels.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_scale","title":"width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_scale = tag(sync=True)\n</code></pre> <p>The scaling multiplier for the width of each line.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_units","title":"width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'pixels'</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/base-layer/","title":"Base Classes","text":""},{"location":"api/layers/base-layer/#lonboard.BaseLayer","title":"lonboard.BaseLayer","text":"<p>               Bases: <code>BaseWidget</code></p>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/base-layer/#lonboard.BaseLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer","title":"lonboard.BaseArrowLayer","text":"<p>               Bases: <code>BaseLayer</code></p> <p>Any Arrow-based layer should subclass from BaseArrowLayer</p>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/base-layer/#lonboard.BaseArrowLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/bitmap-layer/","title":"BitmapLayer","text":""},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer","title":"lonboard.BitmapLayer","text":"<p>               Bases: <code>BaseLayer</code></p> <p>The <code>BitmapLayer</code> renders a bitmap (e.g. PNG, JPEG, or WebP) at specified boundaries.</p> <p>Example:</p> <pre><code>from lonboard import Map, BitmapLayer\n\nlayer = BitmapLayer(\n    image='https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-districts.png',\n    bounds=[-122.5190, 37.7045, -122.355, 37.829]\n)\nm = Map(layer)\nm\n</code></pre>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.bounds","title":"bounds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bounds = tag(sync=True)\n</code></pre> <p>The bounds of the image.</p> <p>Supported formats:</p> <pre><code>- Coordinates of the bounding box of the bitmap `[left, bottom, right, top]`\n- Coordinates of four corners of the bitmap, should follow the sequence of\n  `[[left, bottom], [left, top], [right, top], [right, bottom]]`.\n</code></pre>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.desaturate","title":"desaturate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>desaturate = tag(sync=True)\n</code></pre> <p>The desaturation of the bitmap. Between <code>[0, 1]</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image = tag(sync=True)\n</code></pre> <p>The URL to an image to display.</p> <ul> <li>Type: <code>str</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.tint_color","title":"tint_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tint_color = VariableLengthTuple(\n    Float(), default_value=None, allow_none=True, minlen=3, maxlen=4\n)\n</code></pre> <p>The color to tint the bitmap by, in <code>[r, g, b]</code>.</p> <ul> <li>Type: <code>List[float]</code>, optional</li> <li>Default: <code>[255, 255, 255]</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.transparent_color","title":"transparent_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transparent_color = VariableLengthTuple(\n    Float(), default_value=None, allow_none=True, minlen=3, maxlen=4\n)\n</code></pre> <p>The color to use for transparent pixels, in <code>[r, g, b, a]</code>.</p> <ul> <li>Type: <code>List[float]</code>, optional</li> <li>Default: <code>[0, 0, 0, 0]</code></li> </ul>"},{"location":"api/layers/bitmap-layer/#lonboard.BitmapLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/","title":"BitmapTileLayer","text":""},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer","title":"lonboard.BitmapTileLayer","text":"<p>               Bases: <code>BaseLayer</code></p> <p>The BitmapTileLayer renders image tiles (e.g. PNG, JPEG, or WebP) in the web mercator tiling system. Only the tiles visible in the current viewport are loaded and rendered.</p> <p>Example:</p> <pre><code>from lonboard import Map, BitmapTileLayer\n\n# We set `max_requests &lt; 0` because `tile.openstreetmap.org` supports HTTP/2.\nlayer = BitmapTileLayer(\n    data=\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    tile_size=256,\n    max_requests=-1,\n    min_zoom=0,\n    max_zoom=19,\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data = tag(sync=True)\n</code></pre> <p>Either a URL template or an array of URL templates from which the tile data should be loaded.</p> <p>If the value is a string: a URL template. Substrings {x} {y} and {z}, if present, will be replaced with a tile's actual index when it is requested.</p> <p>If the value is an array: multiple URL templates. Each endpoint must return the same content for the same tile index. This can be used to work around domain sharding, allowing browsers to download more resources simultaneously. Requests made are balanced among the endpoints, based on the tile index.</p>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.desaturate","title":"desaturate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>desaturate = tag(sync=True)\n</code></pre> <p>The desaturation of the bitmap. Between <code>[0, 1]</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extent = tag(sync=True)\n</code></pre> <p>The bounding box of the layer's data, in the form of <code>[min_x, min_y, max_x, max_y]</code>. If provided, the layer will only load and render the tiles that are needed to fill this box.</p> <ul> <li>Type: <code>List[float]</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.max_cache_size","title":"max_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_cache_size = tag(sync=True)\n</code></pre> <p>The maximum number of tiles that can be cached. The tile cache keeps loaded tiles in memory even if they are no longer visible. It reduces the need to re-download the same data over and over again when the user pan/zooms around the map, providing a smoother experience.</p> <p>If not supplied, the <code>max_cache_size</code> is calculated as 5 times the number of tiles in the current viewport.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.max_requests","title":"max_requests  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_requests = tag(sync=True)\n</code></pre> <p>The maximum number of concurrent data fetches.</p> <p>If &lt;= 0, no throttling will occur, and <code>get_tile_data</code> may be called an unlimited number of times concurrently regardless of how long that tile is or was visible.</p> <p>If &gt; 0, a maximum of <code>max_requests</code> instances of <code>get_tile_data</code> will be called concurrently. Requests may never be called if the tile wasn't visible long enough to be scheduled and started. Requests may also be aborted (through the signal passed to <code>get_tile_data</code>) if there are more than <code>max_requests</code> ongoing requests and some of those are for tiles that are no longer visible.</p> <p>If <code>get_tile_data</code> makes fetch requests against an HTTP 1 web server, then max_requests should correlate to the browser's maximum number of concurrent fetch requests. For Chrome, the max is 6 per domain. If you use the data prop and specify multiple domains, you can increase this limit. For example, with Chrome and 3 domains specified, you can set max_requests=18.</p> <p>If the web server supports HTTP/2 (Open Chrome dev tools and look for \"h2\" in the Protocol column), then you can make an unlimited number of concurrent requests (and can set max_requests=-1). Note that this will request data for every tile, no matter how long the tile was visible, and may increase server load.</p>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.max_zoom","title":"max_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_zoom = tag(sync=True)\n</code></pre> <p>The max zoom level of the layer's data. When overzoomed (i.e. <code>zoom &gt; max_zoom</code>), tiles from this level will be displayed.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.min_zoom","title":"min_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_zoom = tag(sync=True)\n</code></pre> <p>The min zoom level of the layer's data. When underzoomed (i.e. <code>zoom &lt; min_zoom</code>), the layer will not display any tiles unless <code>extent</code> is defined, to avoid issuing too many tile requests.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.refinement_strategy","title":"refinement_strategy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>refinement_strategy = tag(sync=True)\n</code></pre> <p>How the tile layer refines the visibility of tiles.</p> <p>When zooming in and out, if the layer only shows tiles from the current zoom level, then the user may observe undesirable flashing while new data is loading. By setting <code>refinement_strategy</code> the layer can attempt to maintain visual continuity by displaying cached data from a different zoom level before data is available.</p> <p>This prop accepts one of the following:</p> <ul> <li><code>\"best-available\"</code>: If a tile in the current viewport is waiting for its data to   load, use cached content from the closest zoom level to fill the empty space. This   approach minimizes the visual flashing due to missing content.</li> <li><code>\"no-overlap\"</code>: Avoid showing overlapping tiles when backfilling with cached   content. This is usually favorable when tiles do not have opaque backgrounds.</li> <li> <p><code>\"never\"</code>: Do not display any tile that is not selected.</p> </li> <li> <p>Type: <code>str</code>, optional</p> </li> <li>Default: <code>\"best-available\"</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.tile_size","title":"tile_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tile_size = tag(sync=True)\n</code></pre> <p>The pixel dimension of the tiles, usually a power of 2.</p> <p>Tile size represents the target pixel width and height of each tile when rendered. Smaller tile sizes display the content at higher resolution, while the layer needs to load more tiles to fill the same viewport.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>512</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.tint_color","title":"tint_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tint_color = VariableLengthTuple(\n    Float(), default_value=None, allow_none=True, minlen=3, maxlen=4\n)\n</code></pre> <p>The color to tint the bitmap by, in <code>[r, g, b]</code>.</p> <ul> <li>Type: <code>List[float]</code>, optional</li> <li>Default: <code>[255, 255, 255]</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.transparent_color","title":"transparent_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transparent_color = VariableLengthTuple(\n    Float(), default_value=None, allow_none=True, minlen=3, maxlen=4\n)\n</code></pre> <p>The color to use for transparent pixels, in <code>[r, g, b, a]</code>.</p> <ul> <li>Type: <code>List[float]</code>, optional</li> <li>Default: <code>[0, 0, 0, 0]</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/bitmap-tile-layer/#lonboard.BitmapTileLayer.zoom_offset","title":"zoom_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zoom_offset = tag(sync=True)\n</code></pre> <p>This offset changes the zoom level at which the tiles are fetched. Needs to be an integer.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/column-layer/","title":"ColumnLayer","text":""},{"location":"api/layers/column-layer/#lonboard.ColumnLayer","title":"lonboard.ColumnLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The ColumnLayer renders extruded cylinders (tessellated regular polygons) at given coordinates.</p>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>angle = tag(sync=True)\n</code></pre> <p>Disk rotation, counter-clockwise in degrees.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.coverage","title":"coverage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coverage = tag(sync=True)\n</code></pre> <p>Radius multiplier, between 0 - 1. The radius of the disk is calculated by <code>coverage * radius</code></p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.disk_resolution","title":"disk_resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disk_resolution = tag(sync=True)\n</code></pre> <p>The number of sides to render the disk as. The disk is a regular polygon that fits inside the given radius. A higher resolution will yield a smoother look close-up, but also need more resources to render.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>20</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.elevation_scale","title":"elevation_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elevation_scale = tag(sync=True)\n</code></pre> <p>Column elevation multiplier. The elevation of column is calculated by <code>elevation_scale * get_elevation(d)</code>. <code>elevation_scale</code> is a handy property to scale all column elevations without updating the data.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.extruded","title":"extruded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extruded = tag(sync=True)\n</code></pre> <p>Whether to extrude the columns. If set to <code>false</code>, all columns will be rendered as flat polygons.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = tag(sync=True)\n</code></pre> <p>Whether to draw a filled column (solid fill).</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.flat_shading","title":"flat_shading  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flat_shading = tag(sync=True)\n</code></pre> <p>If <code>True</code>, the vertical surfaces of the columns use flat shading. If <code>false</code>, use smooth shading. Only effective if <code>extruded</code> is <code>True</code>.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.get_elevation","title":"get_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_elevation = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The elevation of each cell in meters.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all polygons.</li> <li>If an array is provided, each value in the array will be used as the width for   the polygon at the same row index.</li> </ul> </li> <li>Default: <code>1000</code>.</li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The filled color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the filled color for   all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the filled color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The outline color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the outline color for   all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the outline color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.get_line_width","title":"get_line_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The width of the outline of each column, in units specified by <code>line_width_units</code> (default <code>'meters'</code>). Only applies if <code>extruded: false</code> and <code>stroked: true</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the outline width for all columns.</li> <li>If an array is provided, each value in the array will be used as the outline   width for the column at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.line_width_max_pixels","title":"line_width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum outline width in pixels. This can be used to prevent the line from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.line_width_min_pixels","title":"line_width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum outline width in pixels. This can be used to prevent the line from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.line_width_scale","title":"line_width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_scale = tag(sync=True)\n</code></pre> <p>The line width multiplier that multiplied to all outlines if the <code>stroked</code> attribute is <code>True</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.line_width_units","title":"line_width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset = tag(sync=True)\n</code></pre> <p>Disk offset from the position, relative to the radius. By default, the disk is centered at each position.</p> <ul> <li>Type: <code>tuple[float, float]</code>, optional</li> <li>Default: <code>(0, 0)</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.radius","title":"radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius = tag(sync=True)\n</code></pre> <p>Disk size in units specified by <code>radius_units</code> (default meters).</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1000</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.radius_units","title":"radius_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_units = tag(sync=True)\n</code></pre> <p>The units of the radius, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.stroked","title":"stroked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stroked = tag(sync=True)\n</code></pre> <p>Whether to draw an outline around the disks. Only applies if <code>extruded=False</code>.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POINT})\n</code></pre> <p>A GeoArrow table with a Point or MultiPoint column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.wireframe","title":"wireframe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wireframe = tag(sync=True)\n</code></pre> <p>Whether to generate a line wireframe of the column. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex around the disk. Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[ColumnLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/column-layer/#lonboard.ColumnLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[ColumnLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/heatmap-layer/","title":"HeatmapLayer","text":"<p>Warning</p> <p>The <code>HeatmapLayer</code> is not currently working.</p> <p>As of Lonboard v0.10, Lonboard upgraded to version 9.0 of the underlying deck.gl library. deck.gl appears to have a bug with the HeatmapLayer in 9.0, that has not yet been fixed.</p> <p>Please temporarily downgrade to Lonboard v0.9 if you would like to use the <code>HeatmapLayer</code>.</p> <p></p> <p>Screenshot from DuckDB Spatial example</p>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer","title":"lonboard.HeatmapLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>HeatmapLayer</code> visualizes the spatial distribution of data.</p> <p>Example</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, HeatmapLayer\n\n# A GeoDataFrame with Point geometries\ngdf = gpd.GeoDataFrame()\nlayer = HeatmapLayer.from_geopandas(gdf)\nm = Map(layer)\n</code></pre> <p>From geoarrow-rust:</p> <pre><code>from geoarrow.rust.core import read_parquet\nfrom lonboard import Map, HeatmapLayer\n\n# Example: A GeoParquet file with Point geometries\ntable = read_parquet(\"path/to/file.parquet\")\nlayer = HeatmapLayer(\n    table=table,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.aggregation","title":"aggregation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aggregation = tag(sync=True)\n</code></pre> <p>Defines the type of aggregation operation</p> <p>Valid values are 'SUM', 'MEAN'.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>\"SUM\"</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.debounce_timeout","title":"debounce_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debounce_timeout = tag(sync=True)\n</code></pre> <p>Interval in milliseconds during which changes to the viewport don't trigger aggregation.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>500</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.get_weight","title":"get_weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_weight = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The weight of each object.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the weight for all objects.</li> <li>If an array is provided, each value in the array will be used as the weight   for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>intensity = tag(sync=True)\n</code></pre> <p>Value that is multiplied with the total weight at a pixel to obtain the final weight.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.radius_pixels","title":"radius_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_pixels = tag(sync=True)\n</code></pre> <p>Radius of the circle in pixels, to which the weight of an object is distributed.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>30</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POINT})\n</code></pre> <p>A GeoArrow table with a Point column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.threshold","title":"threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>threshold = tag(sync=True)\n</code></pre> <p>Ratio of the fading weight to the max weight, between <code>0</code> and <code>1</code>.</p> <p>For example, <code>0.1</code> affects all pixels with weight under 10% of the max.</p> <p>Ignored when <code>color_domain</code> is specified.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0.05</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.weights_texture_size","title":"weights_texture_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights_texture_size = tag(sync=True)\n</code></pre> <p>Specifies the size of weight texture.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>2048</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[HeatmapLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[HeatmapLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/path-layer/","title":"PathLayer","text":"<p>Screenshot from North America roads example</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer","title":"lonboard.PathLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>PathLayer</code> renders lists of coordinate points as extruded polylines with mitering.</p> <p>Example:</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, PathLayer\n\n# A GeoDataFrame with LineString or MultiLineString geometries\ngdf = gpd.GeoDataFrame()\nlayer = PathLayer.from_geopandas(\n    gdf,\n    get_color=[255, 0, 0],\n    width_min_pixels=2,\n)\nm = Map(layer)\n</code></pre> <p>From geoarrow-rust:</p> <pre><code>from geoarrow.rust.core import read_parquet\nfrom lonboard import Map, PathLayer\n\n# Example: A GeoParquet file with LineString or MultiLineString geometries\ntable = read_parquet(\"path/to/file.parquet\")\nlayer = PathLayer(\n    table=table,\n    get_color=[255, 0, 0],\n    width_min_pixels=2,\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = tag(sync=True)\n</code></pre> <p>If <code>True</code>, extrude the path in screen space (width always faces the camera). If <code>False</code>, the width always faces up.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.cap_rounded","title":"cap_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cap_rounded = tag(sync=True)\n</code></pre> <p>Type of caps. If <code>True</code>, draw round caps. Otherwise draw square caps.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The color of each path in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the color for all   paths.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the color for the path at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.get_width","title":"get_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The width of each path, in units specified by <code>width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.joint_rounded","title":"joint_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>joint_rounded = tag(sync=True)\n</code></pre> <p>Type of joint. If <code>True</code>, draw round joints. Otherwise draw miter joints.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.miter_limit","title":"miter_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>miter_limit = tag(sync=True)\n</code></pre> <p>The maximum extent of a joint in ratio to the stroke width. Only works if <code>jointRounded</code> is <code>False</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>4</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={LINESTRING, MULTILINESTRING})\n</code></pre> <p>A GeoArrow table with a LineString or MultiLineString column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_max_pixels","title":"width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_min_pixels","title":"width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_scale","title":"width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_scale = tag(sync=True)\n</code></pre> <p>The path width multiplier that multiplied to all paths.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_units","title":"width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[PathLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[PathLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/point-cloud-layer/","title":"PointCloudLayer","text":""},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer","title":"lonboard.PointCloudLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>PointCloudLayer</code> renders a point cloud with 3D positions, normals and colors.</p> <p>The <code>PointCloudLayer</code> can be more efficient at rendering large quantities of points than the <code>ScatterplotLayer</code>, but has fewer rendering options. In particular, you can have only one point size across all points in your data.</p> <p>Example:</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, PointCloudLayer\n\n# A GeoDataFrame with Point geometries\ngdf = gpd.GeoDataFrame()\nlayer = PointCloudLayer.from_geopandas(\n    gdf,\n    get_color=[255, 0, 0],\n    point_size=2,\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The color of each path in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the color for all   paths.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the color for the path at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.get_normal","title":"get_normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_normal = NormalAccessor(None, allow_none=True)\n</code></pre> <p>The normal of each object, in <code>[nx, ny, nz]</code>.</p> <ul> <li>Type: NormalAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the normal for all   points.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the normal for the point at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.point_size","title":"point_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_size = tag(sync=True)\n</code></pre> <p>Global radius of all points, in units specified by <code>size_units</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>10</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.size_units","title":"size_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'pixels'</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POINT}, allowed_dimensions={3})\n</code></pre> <p>A GeoArrow table with a Point column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[PointCloudLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/point-cloud-layer/#lonboard.PointCloudLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[PointCloudLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/polygon-layer/","title":"PolygonLayer","text":"<p>Screenshot from Overture Maps example</p>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer","title":"lonboard.PolygonLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>PolygonLayer</code> renders filled, stroked and/or extruded polygons.</p> <p>Note</p> <p>This layer is essentially a combination of a <code>PathLayer</code> and a <code>SolidPolygonLayer</code>. This has some overhead beyond a <code>SolidPolygonLayer</code>, so if you're looking for the maximum performance with large data, you may want to use a <code>SolidPolygonLayer</code> directly.</p> <p>Example:</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, PolygonLayer\n\n# A GeoDataFrame with Polygon or MultiPolygon geometries\ngdf = gpd.GeoDataFrame()\nlayer = PolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n    get_line_color=[0, 100, 100, 150],\n)\nm = Map(layer)\n</code></pre> <p>From geoarrow-rust:</p> <pre><code>from geoarrow.rust.core import read_parquet\nfrom lonboard import Map, PolygonLayer\n\n# Example: A GeoParquet file with Polygon or MultiPolygon geometries\ntable = read_parquet(\"path/to/file.parquet\")\nlayer = PolygonLayer(\n    table=table,\n    get_fill_color=[255, 0, 0],\n    get_line_color=[0, 100, 100, 150],\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.elevation_scale","title":"elevation_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elevation_scale = tag(sync=True)\n</code></pre> <p>Elevation multiplier.</p> <p>The final elevation is calculated by <code>elevationScale * getElevation(d)</code>. <code>elevationScale</code> is a handy property to scale all elevation without updating the data.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.extruded","title":"extruded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extruded = tag(sync=True)\n</code></pre> <p>Whether to extrude the polygons.</p> <p>Based on the elevations provided by the <code>getElevation</code> accessor.</p> <p>If set to <code>false</code>, all polygons will be flat, this generates less geometry and is faster than simply returning 0 from getElevation.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = tag(sync=True)\n</code></pre> <p>Whether to draw a filled polygon (solid fill).</p> <p>Note that only the area between the outer polygon and any holes will be filled.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.get_elevation","title":"get_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_elevation = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The elevation to extrude each polygon with, in meters.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all polygons.</li> <li>If an array is provided, each value in the array will be used as the width for   the polygon at the same row index.</li> </ul> </li> <li>Default: <code>1000</code>.</li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The fill color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the fill color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the fill color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The line color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the line color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the line color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.get_line_width","title":"get_line_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The width of the outline of each polygon, in units specified by <code>line_width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the outline width for all polygons.</li> <li>If an array is provided, each value in the array will be used as the outline   width for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_joint_rounded","title":"line_joint_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_joint_rounded = tag(sync=True)\n</code></pre> <p>Type of joint. If <code>true</code>, draw round joints. Otherwise draw miter joints.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_miter_limit","title":"line_miter_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_miter_limit = tag(sync=True)\n</code></pre> <p>The maximum extent of a joint in ratio to the stroke width.</p> <p>Only works if <code>line_joint_rounded</code> is false.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>4</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_width_max_pixels","title":"line_width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum line width in pixels. This can be used to prevent the line from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_width_min_pixels","title":"line_width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum line width in pixels. This can be used to prevent the line from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_width_scale","title":"line_width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_scale = tag(sync=True)\n</code></pre> <p>The line width multiplier that multiplied to all outlines of <code>Polygon</code> and <code>MultiPolygon</code> features if the <code>stroked</code> attribute is true.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.line_width_units","title":"line_width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.stroked","title":"stroked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stroked = tag(sync=True)\n</code></pre> <p>Whether to draw an outline around the polygon (solid fill).</p> <p>Note that both the outer polygon as well the outlines of any holes will be drawn.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POLYGON, MULTIPOLYGON})\n</code></pre> <p>A GeoArrow table with a Polygon or MultiPolygon column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.wireframe","title":"wireframe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wireframe = tag(sync=True)\n</code></pre> <p>Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul> <p>Remarks:</p> <ul> <li>These lines are rendered with <code>GL.LINE</code> and will thus always be 1 pixel wide.</li> <li>Wireframe and solid extrusions are exclusive, you'll need to create two layers   with the same data if you want a combined rendering effect.</li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[PolygonLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/polygon-layer/#lonboard.PolygonLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[PolygonLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/scatterplot-layer/","title":"ScatterplotLayer","text":"<p>Screenshot from Ookla example.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer","title":"lonboard.ScatterplotLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>ScatterplotLayer</code> renders circles at given coordinates.</p> <p>Example:</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer\n\n# A GeoDataFrame with Point or MultiPoint geometries\ngdf = gpd.GeoDataFrame()\nlayer = ScatterplotLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\n</code></pre> <p>From geoarrow-rust:</p> <pre><code>from geoarrow.rust.core import read_parquet\nfrom lonboard import Map, ScatterplotLayer\n\n# Example: A GeoParquet file with Point or MultiPoint geometries\ntable = read_parquet(\"path/to/file.parquet\")\nlayer = ScatterplotLayer(\n    table=table,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.antialiasing","title":"antialiasing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>antialiasing = tag(sync=True)\n</code></pre> <p>If <code>True</code>, circles are rendered with smoothed edges. If <code>False</code>, circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = tag(sync=True)\n</code></pre> <p>If <code>True</code>, rendered circles always face the camera. If <code>False</code> circles face up (i.e. are parallel with the ground plane).</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = tag(sync=True)\n</code></pre> <p>Draw the filled area of points.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The filled color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the filled color for   all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the filled color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The outline color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the outline color   for all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the outline color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_line_width","title":"get_line_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The width of the outline of each object, in units specified by <code>line_width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the outline width for all objects.</li> <li>If an array is provided, each value in the array will be used as the outline   width for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_radius","title":"get_radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_radius = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The radius of each object, in units specified by <code>radius_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the radius for all objects.</li> <li>If an array is provided, each value in the array will be used as the radius   for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_max_pixels","title":"line_width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum line width in pixels. This can be used to prevent the stroke from getting too thick when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_min_pixels","title":"line_width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum line width in pixels. This can be used to prevent the stroke from getting too thin when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_scale","title":"line_width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_scale = tag(sync=True)\n</code></pre> <p>A global line width multiplier for all points.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_units","title":"line_width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_max_pixels","title":"radius_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum radius in pixels. This can be used to prevent the circle from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_min_pixels","title":"radius_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum radius in pixels. This can be used to prevent the circle from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_scale","title":"radius_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_scale = tag(sync=True)\n</code></pre> <p>A global radius multiplier for all points.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_units","title":"radius_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_units = tag(sync=True)\n</code></pre> <p>The units of the radius, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.stroked","title":"stroked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stroked = tag(sync=True)\n</code></pre> <p>Draw the outline of points.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POINT, MULTIPOINT})\n</code></pre> <p>A GeoArrow table with a Point or MultiPoint column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[ScatterplotLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[ScatterplotLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/solid-polygon-layer/","title":"SolidPolygonLayer","text":""},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer","title":"lonboard.SolidPolygonLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>SolidPolygonLayer</code> renders filled and/or extruded polygons.</p> <p>Note</p> <p>This layer is similar to the <code>PolygonLayer</code> but will not render an outline around polygons. In most cases, you'll want to use the <code>PolygonLayer</code> directly, but for very large datasets not drawing the outline can significantly improve performance, in which case you may want to use this layer.</p> <p>Example:</p> <p>From GeoPandas:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, SolidPolygonLayer\n\n# A GeoDataFrame with Polygon or MultiPolygon geometries\ngdf = gpd.GeoDataFrame()\nlayer = SolidPolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\n</code></pre> <p>From geoarrow-rust:</p> <pre><code>from geoarrow.rust.core import read_parquet\nfrom lonboard import Map, SolidPolygonLayer\n\n# Example: A GeoParquet file with Polygon or MultiPolygon geometries\ntable = read_parquet(\"path/to/file.parquet\")\nlayer = SolidPolygonLayer(\n    table=table,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\n</code></pre>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.elevation_scale","title":"elevation_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elevation_scale = tag(sync=True)\n</code></pre> <p>Elevation multiplier. The final elevation is calculated by <code>elevation_scale * get_elevation(d)</code>. <code>elevation_scale</code> is a handy property to scale all elevation without updating the data.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.extruded","title":"extruded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extruded = tag(sync=True)\n</code></pre> <p>Whether to extrude the polygons (based on the elevations provided by the <code>get_elevation</code> accessor'). If set to <code>False</code>, all polygons will be flat, this generates less geometry and is faster than simply returning <code>0</code> from <code>get_elevation</code>.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = tag(sync=True)\n</code></pre> <p>Whether to fill the polygons (based on the color provided by the <code>get_fill_color</code> accessor).</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_elevation","title":"get_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_elevation = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The elevation to extrude each polygon with, in meters.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all polygons.</li> <li>If an array is provided, each value in the array will be used as the width for   the polygon at the same row index.</li> </ul> </li> <li>Default: <code>1000</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The fill color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the fill color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the fill color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The line color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the line color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the line color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POLYGON, MULTIPOLYGON})\n</code></pre> <p>A GeoArrow table with a Polygon or MultiPolygon column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.wireframe","title":"wireframe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wireframe = tag(sync=True)\n</code></pre> <p>Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul> <p>Remarks:</p> <ul> <li>These lines are rendered with <code>GL.LINE</code> and will thus always be 1 pixel wide.</li> <li>Wireframe and solid extrusions are exclusive, you'll need to create two layers   with the same data if you want a combined rendering effect.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[SolidPolygonLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[SolidPolygonLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/text-layer/","title":"TextLayer","text":""},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer","title":"lonboard.experimental.TextLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>Render text labels at given coordinates.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.background_padding","title":"background_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>background_padding = tag(sync=True)\n</code></pre> <p>The padding of the background.</p> <ul> <li>If an array of 2 is supplied, it is interpreted as <code>[padding_x, padding_y]</code> in   pixels.</li> <li>If an array of 4 is supplied, it is interpreted as <code>[padding_left, padding_top,   padding_right, padding_bottom]</code> in pixels.</li> </ul> <p>default [0, 0, 0, 0]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = tag(sync=True)\n</code></pre> <p>If <code>true</code>, the text always faces camera. Otherwise the text faces up (z).</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.character_set","title":"character_set  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>character_set = tag(sync=True)\n</code></pre> <p>Specifies a list of characters to include in the font. If set to 'auto', will be automatically generated from the data set.</p> <p>default (ASCII characters 32-128)</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_family","title":"font_family  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_family = tag(sync=True)\n</code></pre> <p>CSS font family</p> <p>default 'Monaco, monospace'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_settings","title":"font_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_settings = tag(sync=True)\n</code></pre> <p>Advance options for fine tuning the appearance and performance of the generated shared <code>fontAtlas</code>.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_weight","title":"font_weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_weight = tag(sync=True)\n</code></pre> <p>CSS font weight</p> <p>default 'normal'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_alignment_baseline","title":"get_alignment_baseline  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_alignment_baseline = tag(sync=True)\n</code></pre> <p>Vertical alignment accessor</p> <p>default 'center'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_angle","title":"get_angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_angle = FloatAccessor(None, allow_none=True)\n</code></pre> <p>Label rotation accessor, in degrees</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_background_color","title":"get_background_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_background_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>Background color accessor.</p> <p>default [255, 255, 255, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_border_color","title":"get_border_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_border_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>Border color accessor.</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_border_width","title":"get_border_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_border_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>Border width accessor.</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>Label color accessor</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_pixel_offset","title":"get_pixel_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_pixel_offset = tag(sync=True)\n</code></pre> <p>Label offset from the anchor position, [x, y] in pixels</p> <p>default [0, 0]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_size","title":"get_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_size = FloatAccessor(None, allow_none=True)\n</code></pre> <p>Label size accessor</p> <p>default 32</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_text","title":"get_text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_text = TextAccessor(None, allow_none=True)\n</code></pre> <p>Label text accessor</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_text_anchor","title":"get_text_anchor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_text_anchor = tag(sync=True)\n</code></pre> <p>Horizontal alignment accessor</p> <p>default 'middle'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.line_height","title":"line_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_height = tag(sync=True)\n</code></pre> <p>A unitless number that will be multiplied with the current text size to set the line height.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.max_width","title":"max_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_width = tag(sync=True)\n</code></pre> <p>A unitless number that will be multiplied with the current text size to set the width limit of a string.</p> <p>If specified, when the text is longer than the width limit, it will be wrapped into multiple lines using the strategy of <code>wordBreak</code>.</p> <p>default -1</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.outline_color","title":"outline_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outline_color = tag(sync=True)\n</code></pre> <p>Color of outline around the text, in <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.outline_width","title":"outline_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outline_width = tag(sync=True)\n</code></pre> <p>Width of outline around the text, relative to the text size. Only effective if <code>fontSettings.sdf</code> is <code>true</code>.</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_max_pixels","title":"size_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum size in pixels. When using non-pixel <code>sizeUnits</code>, this prop can be used to prevent the icon from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_min_pixels","title":"size_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum size in pixels. When using non-pixel <code>sizeUnits</code>, this prop can be used to prevent the icon from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_scale","title":"size_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_scale = tag(sync=True)\n</code></pre> <p>Text size multiplier.</p> <ul> <li>Type: <code>float</code>.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_units","title":"size_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_units = tag(sync=True)\n</code></pre> <p>The units of the size, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. default 'pixels'. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'pixels'</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = ArrowTableTrait(allowed_geometry_types={POINT})\n</code></pre> <p>A GeoArrow table with a Point or MultiPoint column.</p> <p>This is the fastest way to plot data from an existing GeoArrow source, such as geoarrow-rust or geoarrow-pyarrow.</p> <p>If you have a GeoPandas <code>GeoDataFrame</code>, use <code>from_geopandas</code> instead.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.word_break","title":"word_break  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>word_break = tag(sync=True)\n</code></pre> <p>Available options are <code>break-all</code> and <code>break-word</code>. A valid <code>maxWidth</code> has to be provided to use <code>wordBreak</code>.</p> <p>default 'break-word'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.from_duckdb","title":"from_duckdb  <code>classmethod</code>","text":"<pre><code>from_duckdb(\n    sql: Union[str, DuckDBPyRelation],\n    con: Optional[DuckDBPyConnection] = None,\n    *,\n    crs: Optional[Union[str, CRS]] = None,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a duckdb-spatial query.</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326 or pass in the existing CRS of the data in the <code>crs</code> keyword parameter.</p> <p>Parameters:</p> <ul> <li> <code>sql</code>               (<code>Union[str, DuckDBPyRelation]</code>)           \u2013            <p>The SQL input to visualize. This can either be a string containing a SQL query or the output of the duckdb <code>sql</code> function.</p> </li> <li> <code>con</code>               (<code>Optional[DuckDBPyConnection]</code>, default:                   <code>None</code> )           \u2013            <p>The current DuckDB connection. This is required when passing a <code>str</code> to the <code>sql</code> parameter or when using a non-global DuckDB connection. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>Optional[Union[str, CRS]]</code>)           \u2013            <p>The CRS of the input data. This can either be a string passed to <code>pyproj.CRS.from_user_input</code> or a <code>pyproj.CRS</code> object. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: GeoDataFrame,\n    *,\n    auto_downcast: bool = True,\n    **kwargs: Unpack[BaseLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>               (<code>GeoDataFrame</code>)           \u2013            <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/trips-layer/","title":"TripsLayer","text":"<p>Screenshot from Air Traffic Control example.</p>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer","title":"lonboard.experimental.TripsLayer","text":"<p>               Bases: <code>BaseArrowLayer</code></p> <p>The <code>TripsLayer</code> renders animated paths that represent moving objects.</p> <p>The easiest way to create a <code>TripsLayer</code> is by using the <code>from_movingpandas</code> constructor, where you can pass in a <code>movingpandas.TrajectoryCollection</code>.</p> <p>Otherwise, this layer requires a specific Arrow input data schema to associate the timestamp of each coordinate with the spatial information in the <code>LineString</code> geometries.</p> <p>In order to animate this layer, call the <code>animate</code> method.</p> <p>Warning</p> <p>The TripsLayer renders data representing a specific instance in time based on the <code>current_time</code> attribute.</p> <p>If you don't see any data, use the <code>animate</code> method to automatically set <code>current_time</code>.</p> <p>Passing in custom Arrow data</p> <p>As with all layers, you can pass an Arrow <code>Table</code> into the <code>table</code> parameter of this layer. In the case of the <code>TripsLayer</code>, there must be one column in the table that is a GeoArrow <code>LineString</code> geometry column, tagged with the <code>geoarrow.linestring</code> extension name. Additionally, the <code>get_timestamps</code> accessor needs to be an Arrow list-typed column with a timestamp-typed child array. The <code>get_timestamps</code> column must have the exact same nesting as the <code>LineString</code> column. That is, there must be one timestamp for every coordinate in the <code>LineString</code> column. This is validated in data input.</p>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = tag(sync=True)\n</code></pre> <p>If <code>True</code>, extrude the path in screen space (width always faces the camera). If <code>False</code>, the width always faces up.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.cap_rounded","title":"cap_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cap_rounded = tag(sync=True)\n</code></pre> <p>Type of caps. If <code>True</code>, draw round caps. Otherwise draw square caps.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.current_time","title":"current_time  <code>property</code>","text":"<pre><code>current_time: datetime\n</code></pre> <p>Get the current time of the map as a <code>datetime</code> object.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>datetime object with current time.</p> </li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions = tag(sync=True, **widget_serialization)\n</code></pre> <p>A list of layer extension objects to add additional features to a layer.</p>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.fade_trail","title":"fade_trail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fade_trail = tag(sync=True)\n</code></pre> <p>Whether or not the path fades out.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor(None, allow_none=True)\n</code></pre> <p>The color of each path in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the color for all   paths.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the color for the path at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.get_timestamps","title":"get_timestamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_timestamps = TimestampAccessor(None, allow_none=True)\n</code></pre> <p>The timestamp of each coordinate.</p> <ul> <li>Type: TimestampAccessor</li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.get_width","title":"get_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_width = FloatAccessor(None, allow_none=True)\n</code></pre> <p>The width of each path, in units specified by <code>width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.highlight_color","title":"highlight_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_color = VariableLengthTuple(\n    Int(), default_value=None, minlen=3, maxlen=4\n)\n</code></pre> <p>RGBA color to blend with the highlighted object (the hovered over object if <code>auto_highlight=true</code>). When the value is a 3 component (RGB) array, a default alpha of 255 is applied.</p> <ul> <li>Type: List or Tuple of integers</li> <li>Default: <code>[0, 0, 128, 128]</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.joint_rounded","title":"joint_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>joint_rounded = tag(sync=True)\n</code></pre> <p>Type of joint. If <code>True</code>, draw round joints. Otherwise draw miter joints.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.miter_limit","title":"miter_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>miter_limit = tag(sync=True)\n</code></pre> <p>The maximum extent of a joint in ratio to the stroke width. Only works if <code>jointRounded</code> is <code>False</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>4</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.trail_length","title":"trail_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trail_length = tag(sync=True)\n</code></pre> <p>Trail length.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>120</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.width_max_pixels","title":"width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_max_pixels = tag(sync=True)\n</code></pre> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.width_min_pixels","title":"width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_min_pixels = tag(sync=True)\n</code></pre> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.width_scale","title":"width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_scale = tag(sync=True)\n</code></pre> <p>The path width multiplier that multiplied to all paths.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.width_units","title":"width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_units = tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.animate","title":"animate","text":"<pre><code>animate(\n    *, step: timedelta, fps: int | float = 50, strftime_fmt: str | None = None\n) -&gt; HBox\n</code></pre> <p>Animate this layer with an <code>ipywidgets.Play</code> controller.</p> <p>You can change how \"fast\" the animation is perceived by either increasing the amount of \"data time\" in each animation step, or by having more animation frames per second.</p> <p>As an example, passing <code>step=timedelta(seconds=60)</code> will set each time step of the animation to be 60 \"data seconds\". Setting <code>fps=50</code> (the default) causes there to be 50 animation frames per second.</p> <p>Note that for large data, it's possible there will be some rendering lag and data may not actually update at the desired frames per second.</p> <p>If you call <code>animate</code> multiple times, only the most recently produced <code>Play</code> widget will be active and linked to the map.</p> <p>Other Parameters:</p> <ul> <li> <code>step</code>               (<code>timedelta</code>)           \u2013            <p>the length of time in the data to progress between each animation frame.</p> </li> <li> <code>fps</code>               (<code>int | float</code>)           \u2013            <p>the number of animation frames per second. Defaults to <code>50</code>.</p> </li> <li> <code>strftime_fmt</code>               (<code>str | None</code>)           \u2013            <p>the format string passed to <code>datetime.strftime</code>. Defaults to an inferred format string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HBox</code>           \u2013            <p>an <code>ipywidgets.HBox</code> containing an <code>ipywidgets.Play</code> controller to manage animation playback and an <code>ipywidgets.Output</code> to display the current datetime of the map.</p> </li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.from_movingpandas","title":"from_movingpandas  <code>classmethod</code>","text":"<pre><code>from_movingpandas(\n    traj_collection: TrajectoryCollection, **kwargs: Unpack[TripsLayerKwargs]\n) -&gt; Self\n</code></pre> <p>Construct a TripsLayer from a MovingPandas <code>TrajectoryCollection</code>.</p> <p>This is the simplest way to construct a <code>TripsLayer</code>. Under the hood, this constructor will convert the <code>TrajectoryCollection</code> to a GeoArrow table with a <code>LineString</code> geometry column for each row. It will also create a Timestamp Arrow column from the TrajectoryCollection's <code>DatetimeIndex</code>.</p> <p>Parameters:</p> <ul> <li> <code>traj_collection</code>               (<code>TrajectoryCollection</code>)           \u2013            <p>the trajectory collection</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Unpack[TripsLayerKwargs]</code>)           \u2013            <p>keyword args to pass to the <code>TripsLayer</code> constructor.</p> </li> </ul>"},{"location":"api/layers/trips-layer/#lonboard.experimental.TripsLayer.stop_animation","title":"stop_animation","text":"<pre><code>stop_animation()\n</code></pre> <p>Stop any existing animation.</p> <p>This will unlink the linking between the <code>Play</code> widget generated by <code>animate</code> and the layer.</p> <p>To reanimate the map, call <code>animate</code> again.</p>"},{"location":"ecosystem/","title":"Ecosystem","text":"<p>Lonboard aims to both integrate closely in the existing Python geospatial ecosystem and be future proof for the next generation of Python geospatial libraries.</p> <p>The pages in this section outline various integrations. If there's a library you think Lonboard should integrate with or you want to document existing compatibility, create an issue to discuss.</p>"},{"location":"ecosystem/duckdb/","title":"DuckDB Spatial","text":"<p>DuckDB is a fast, self-contained analytical database. DuckDB Spatial is an extension to DuckDB that adds geospatial support.</p> <p>You can pass a DuckDB query into the top-level <code>viz</code> function to quickly inspect data:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\nsql = \"SELECT * FROM spatial_table;\"\nquery = duckdb.sql(sql)\nviz(query)\n</code></pre> <p>Additionally, all relevant Lonboard layer classes have a <code>from_duckdb</code> method for DuckDB query input.</p> <pre><code>import duckdb\nfrom lonboard import Map, PolygonLayer\n\nsql = \"SELECT * FROM polygon_table;\"\nquery = duckdb.sql(sql)\nlayer = PolygonLayer.from_duckdb(\n    query,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\nm\n</code></pre> <p>Warning</p> <p>The DuckDB query must be run with <code>duckdb.sql()</code> or <code>duckdb.DuckDBPyConnection.sql()</code> and not with <code>duckdb.execute()</code> or <code>duckdb.DuckDBPyConnection.execute()</code>.</p> <p>For example</p> <pre><code>import duckdb\nfrom lonboard import viz\n\nsql = \"SELECT * FROM spatial_table;\"\nquery = duckdb.sql(sql)\nviz(query)\n</code></pre> <p>Warning</p> <p>DuckDB Spatial does not currently expose coordinate reference system information, so the user must ensure that data has been reprojected to EPSG:4326.</p>"},{"location":"ecosystem/duckdb/#custom-connection","title":"Custom Connection","text":"<p>If you're using a custom DuckDB connection (not the global default connection), ensure that you pass the connection object into the <code>con</code> named parameter of <code>viz</code> or <code>from_duckdb</code>:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\ncon = duckdb.connect()\nsql = \"SELECT * FROM spatial_table;\"\nquery = con.sql(sql)\nviz(query, con=con)\n</code></pre> <p>You can also render an entire table by using the <code>table()</code> method:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\ncon = duckdb.connect()\ncon.execute(\"CREATE TABLE spatial_table AS ...;\")\nviz(con.table(), con=con)\n</code></pre> <p>Or with <code>from_duckdb</code>:</p> <pre><code>import duckdb\nfrom lonboard import Map, PolygonLayer\n\ncon = duckdb.connect()\nsql = \"SELECT * FROM polygon_table;\"\nquery = con.sql(sql)\nlayer = PolygonLayer.from_duckdb(\n    query,\n    con=con,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\nm\n</code></pre> <p>In <code>from_duckdb</code>, you can alternatively just pass the SQL string into the method:</p> <pre><code>import duckdb\nfrom lonboard import Map, PolygonLayer\n\ncon = duckdb.connect()\nlayer = PolygonLayer.from_duckdb(\n    \"SELECT * FROM polygon_table;\",\n    con=con,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\nm\n</code></pre> <p>Warning</p> <p>The DuckDB query must be run with <code>duckdb.DuckDBPyConnection.sql()</code> and not with <code>duckdb.DuckDBPyConnection.execute()</code>.</p> <p>Additionally, ensure you pass in the <code>con</code> parameter:</p> <pre><code>import duckdb\nfrom lonboard import viz\n\ncon = duckdb.connect()\nsql = \"SELECT * FROM spatial_table;\"\nquery = con.sql(sql)\nviz(query, con=con)\n</code></pre>"},{"location":"ecosystem/duckdb/#implementation-notes","title":"Implementation Notes","text":"<p>Lonboard integrates with DuckDB by using its Arrow export support.</p> <p>As of DuckDB Spatial version 0.10.2, DuckDB Spatial's primary <code>GEOMETRY</code> type uses a custom, non-stable binary format. When exported to Python via an Arrow table, this <code>GEOMETRY</code> type is maintained as a binary blob that is impossible to reliably parse in Python. The only way to interpret this column in Python-based tools is to get DuckDB to cast this column to a standardized format like Well-Known Binary (WKB).</p> <p>We could require that users always call <code>ST_AsWKB</code> on the geometry column on every query, but this is unwieldy and easy to forget. Instead, by requiring that the user pass in a <code>DuckDBPyRelation</code> object instead of a <code>DuckDBPyConnection</code>, we're able to use the replacement scan feature of <code>DuckDBPyRelation</code> to call back into DuckDB and perform our own <code>ST_AsWKB</code> call on the data, before it's left DuckDB memory, and then export the WKB geometries out to Arrow.</p> <p>This is why we sometimes need access to the <code>DuckDBPyConnection</code> (the <code>con</code> variable) that created the <code>DuckDBPyRelation</code>, because we need to perform a new query on the same connection to convert the geometry column into WKB.</p> <p>Note that geometry types other than <code>GEOMETRY</code>, namely <code>WKB_BLOB</code>, <code>POINT_2D</code>, <code>LINESTRING_2D</code>, <code>POLYGON_2D</code>, and <code>BOX_2D</code>, do not suffer from this limitation. We can directly interpret those types in Python and do not need to call back into DuckDB.</p>"},{"location":"ecosystem/geoarrow/","title":"GeoArrow","text":"<p>GeoArrow is an in-memory data structure for storing vector geospatial data and associated attributes. Lonboard uses GeoArrow internally and is the primary reason why Lonboard is fast.</p> <p>There's a burgeoning ecosystem of Python libraries that use GeoArrow directly. Creating Lonboard <code>Layer</code> objects from GeoArrow tables is the fastest way to visualize data, as no conversions are needed on the Python side.</p>"},{"location":"ecosystem/geoarrow/#geoarrow-rust","title":"geoarrow-rust","text":"<p>geoarrow-rust is a Python library implementing the GeoArrow specification with efficient spatial operations. This library has \"rust\" in the name because it is implemented based on the GeoArrow Rust implementation.</p> <pre><code>from geoarrow.rust.core import GeoTable, read_geojson\nfrom lonboard import Map, PathLayer\n\npath = \"/path/to/file.geojson\"\ngeo_table = read_geojson(path)\n\n# Assuming the GeoJSON contains LineString or MultiLineString data\nlayer = PathLayer(table=geo_table)\nm = Map(layer)\nm\n</code></pre> <p>Refer to the geoarrow-rust documentation for more information.</p>"},{"location":"ecosystem/geopandas/","title":"GeoPandas","text":"<p>GeoPandas extends the Pandas data frame library to allow spatial operations on geospatial data.</p> <p>You can pass an GeoPandas GeoDataFrame into the top-level <code>viz</code> function to quickly inspect data.</p> <p>Additionally, all relevant Lonboard layer classes have a <code>from_geopandas</code> method for <code>GeoDataFrame</code> input. Some layer types, such as <code>BitmapLayer</code>, don't have a <code>from_geopandas</code> method because the rendering isn't relevant to GeoPandas (i.e. GeoPandas doesn't store image data).</p>"},{"location":"ecosystem/geopandas/#example","title":"Example","text":"<p>Quickly inspecting data with <code>viz</code>:</p> <pre><code>import geodatasets\nimport geopandas as gpd\nfrom lonboard import viz\n\n# New York City boroughs\ngdf = gpd.read_file(geodatasets.get_path('nybb'))\nviz(gdf)\n</code></pre> <p>Customizing display with a Layer constructor:</p> <pre><code>import geodatasets\nimport geopandas as gpd\nfrom lonboard import Map, PolygonLayer\n\n# New York City boroughs\ngdf = gpd.read_file(geodatasets.get_path('nybb'))\n# See PolygonLayer documentation for all rendering parameters\nlayer = PolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\nm = Map(layer)\nm\n</code></pre> <p>We can also pass a column of data into any rendering parameter that starts with <code>get</code>.</p> <p>For example, we can render a random radius for each point in this <code>ScatterplotLayer</code> by constructing an array with the same number of rows and passing it into <code>get_radius</code>.</p> <pre><code>import geopandas as gpd\nimport numpy as np\n\nfrom lonboard import Map, ScatterplotLayer\n\ngdf = gpd.read_file(gpd.datasets.get_path(\"naturalearth_cities\"))\nradii = np.random.random(len(gdf))\nlayer = ScatterplotLayer.from_geopandas(\n    gdf,\n    get_fill_color=\"brown\",\n    get_line_color=\"black\",\n    get_radius=radii,\n    line_width_min_pixels=0.5,\n    radius_scale=10,\n    radius_units=\"pixels\",\n    stroked=True,\n)\nm = Map(layer)\nm\n</code></pre> <p>A random radius per point:</p> <p></p>"},{"location":"ecosystem/jupyter-widgets/","title":"Jupyter Widgets","text":"<p>Jupyter Widgets are interactive browser controls for Jupyter notebooks. While Lonboard's classes are themselves widgets, Jupyter Widgets' design means that widgets integrate with other widgets seamlessly.</p> <p>For example, the <code>ipywidgets</code> Python library includes many core widgets like sliders, dropdowns, color pickers, and file upload elements. Then you can link widgets together. This means that your widget-based slider or chart can create events that change the display of a Lonboard map based on user input events.</p>"},{"location":"ecosystem/panel/","title":"Panel","text":"<p>Panel is a framework for building interactive tools for notebooks, dashboards, and web applications that can run on a server\u2014all using Python.</p>"},{"location":"ecosystem/panel/#prerequisites","title":"Prerequisites","text":"<p>To run the code below, you need to install the following packages:</p> <pre><code>pip install panel colorcet ipywidgets_bokeh geopandas palettable lonboard pyogrio watchfiles\n</code></pre>"},{"location":"ecosystem/panel/#tutorial","title":"Tutorial","text":"<p>In this tutorial, you will learn how to display a <code>lonboard</code> <code>Map</code> via the <code>IPyWidget</code> pane.</p> <p></p> <p>Create a file named <code>app.py</code> with the following content:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer\nimport panel as pn\n\npn.extension(\"ipywidgets\")\n\n@pn.cache\ndef get_data():\n    return gpd.read_file(gpd.datasets.get_path(\"naturalearth_cities\"))\n\ngdf = get_data()\nlayer = ScatterplotLayer.from_geopandas(gdf, radius_min_pixels=2, get_fill_color=\"red\")\ncities_map = Map(layer)\n\n# Fit to the available space\ncities_map.layout.height = cities_map.layout.width = \"100%\"\n\npn.Column(\n    \"# Lonboard Map\",\n    pn.pane.IPyWidget(cities_map, height=500, width=1000),\n).servable()\n</code></pre> <p>Now run:</p> <pre><code>panel serve app.py --autoreload\n</code></pre> <p>Finally, open http://localhost:5006 and you should see the <code>lonboard</code> map.</p>"},{"location":"ecosystem/panel/#how-to","title":"How to","text":""},{"location":"ecosystem/panel/#update-the-map-in-place","title":"Update the Map In Place","text":"<p>Panel supports in-place updates of <code>lonboard</code> <code>Map</code>s, allowing you to update details of a map efficiently without redrawing the entire map. This is useful for updating the map based on user interactions or on a schedule.</p> <p></p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer\nimport panel as pn\n\npn.extension(\"ipywidgets\")\n\ncolors = {\n    \"Red\": [200, 0, 0],\n    \"Green\": [0, 200, 0],\n    \"Blue\": [0, 0, 200],\n}\n\n@pn.cache\ndef get_data():\n    return gpd.read_file(gpd.datasets.get_path(\"naturalearth_cities\"))\n\ngdf = get_data()\nlayer = ScatterplotLayer.from_geopandas(gdf, radius_min_pixels=2, get_fill_color=\"red\")\ncities_map = Map(layer)\n\n# Fit to the available space\ncities_map.layout.height = cities_map.layout.width = \"100%\"\n\ncolor_input = pn.widgets.Select(\n    name=\"Color\", options=list(colors.keys()), description=\"The color of the points\"\n)\n\n@pn.depends(value=color_input, watch=True)\ndef set_fill_color(value):\n    cities_map.layers[0].get_fill_color = colors[value]\n\npn.Column(\n    color_input,\n    pn.pane.IPyWidget(cities_map, height=500, width=1000),\n).servable()\n</code></pre>"},{"location":"ecosystem/panel/#build-an-application","title":"Build an Application","text":"<p>With Panel, you can build reusable components and styled web applications in just a few lines of code.</p> <p>The example below is based on the North America Roads example.</p> <p></p> <pre><code>import colorcet as cc\nimport geopandas as gpd\nimport param\n\nfrom lonboard import Map, PathLayer\nfrom lonboard.colormap import apply_continuous_cmap\nfrom lonboard._viewport import compute_view\nfrom palettable.palette import Palette\n\nimport panel as pn\n\npn.extension(\"ipywidgets\")\n\nurl = \"https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip\"\n\n@pn.cache\ndef get_data():\n    return gpd.read_file(filename=url, engine=\"pyogrio\")\n\ngdf = get_data()\nstate_options = sorted(state for state in gdf[\"state\"].unique() if state)\n\ndescription = \"\"\"# Lonboard\n\nA Python library for **fast, interactive geospatial vector data visualization** in Jupyter (and Panel).\n\nBy utilizing new technologies like `GeoArrow` and `GeoParquet` in conjunction with GPU-based map rendering, Lonboard aims to enable visualizing large geospatial datasets interactively through a simple interface.\"\"\"\n\nlogo = pn.pane.Image(\n    \"https://github.com/developmentseed/lonboard/raw/main/assets/dalle-lonboard.jpg\"\n)\n\ndef to_rgb(hex: str) -&gt; list:\n    h = hex.strip(\"#\")\n    return list(int(h[i : i + 2], 16) for i in (0, 2, 4))\n\ndef to_palette(cmap) -&gt; Palette:\n    \"\"\"Returns the ColorCet colormap as a palettable Palette\"\"\"\n    colors = [to_rgb(item) for item in cmap]\n    return Palette(name=\"colorcet\", map_type=\"colorcet\", colors=colors)\n\nclass StateViewer(pn.viewable.Viewer):\n    value: Map = param.ClassSelector(class_=Map, doc=\"The map object\", constant=True)\n    state: str = param.Selector(default=\"California\", objects=state_options)\n    cmap: str = param.Selector(default=cc.fire, objects=cc.palette, label=\"cmap by Colorcet\")\n    alpha: float = param.Number(default=0.8, bounds=(0, 1))\n\n    data = param.DataFrame()\n\n    def __init__(self, **params):\n        params[\"value\"] = params.get(\"value\", Map(layers=[], view_state={\"longitude\": -119.81446785010868, \"latitude\": 36.08305565437565, \"zoom\": 5}))\n\n        super().__init__(**params)\n\n        self.value.layout.width=self.value.layout.height=\"100%\"\n\n        self.description = pn.Column(pn.pane.Markdown(description, margin=5), logo)\n        self.settings = pn.Column(\n            pn.widgets.Select.from_param(self.param.state, sizing_mode=\"stretch_width\"),\n            pn.widgets.ColorMap.from_param(\n                self.param.cmap,\n                ncols=3,\n                swatch_width=100,\n                name=\"cmap by Colorcet\",\n                sizing_mode=\"stretch_width\",\n            ),\n            pn.widgets.FloatSlider.from_param(\n                self.param.alpha, sizing_mode=\"stretch_width\"\n            ),\n            margin=5,\n            sizing_mode=\"fixed\",\n            width=300,\n        )\n        self.view = pn.Column(\n            self._title, pn.pane.IPyWidget(self.value, sizing_mode=\"stretch_both\")\n        )\n        self._layout = pn.Row(\n            pn.Column(self.settings, sizing_mode=\"fixed\", width=300),\n            self.view,\n            sizing_mode=\"stretch_both\",\n        )\n\n    def __panel__(self):\n        return self._layout\n\n    @param.depends(\"state\", watch=True, on_init=True)\n    def _update_data(self):\n        self.data = gdf[gdf[\"state\"] == self.state]\n\n    def _get_color(self):\n        palette = to_palette(self.cmap)\n        normalized_scale_rank = (self.data[\"scalerank\"] - 3) / 9\n        return apply_continuous_cmap(normalized_scale_rank, palette, alpha=self.alpha)\n\n    @param.depends(\"data\", watch=True)\n    def _update_value(self):\n        layer = PathLayer.from_geopandas(self.data, width_min_pixels=0.8)\n        layer.get_color = self._get_color()\n        self.value.layers = [layer]\n        self._fly_to_center()\n\n    def _fly_to_center(self):\n        computed_view_state = compute_view(self.value.layers)\n        self.value.fly_to(\n            **computed_view_state,\n            duration=1000,\n        )\n\n    @param.depends(\"cmap\", \"alpha\", watch=True)\n    def _update_layer_get_color(self):\n        self.value.layers[0].get_color = self._get_color()\n\n    @param.depends(\"state\")\n    def _title(self):\n        return f\"# North America Roads: {self.state}\"\n\nviewer = StateViewer()\npn.template.FastListTemplate(\n    logo=\"https://panel.holoviz.org/_static/logo_horizontal_dark_theme.png\",\n    title=\"Works with Lonboard\",\n    sidebar=[viewer.description, viewer.settings],\n    main=[viewer.view],\n    main_layout=None,\n).servable()\n</code></pre>"},{"location":"ecosystem/pyodide/","title":"Pyodide","text":"<p>As of Lonboard version 0.10, it's possible to use Lonboard in Pyodide, where Python is running inside your web browser in WebAssembly.</p> <p></p> <p>Demo notebook.</p> <p>There's a few things to keep in mind:</p>"},{"location":"ecosystem/pyodide/#pyodide-specific-dependencies","title":"Pyodide-specific dependencies","text":"<p>Not all Python libraries work out of the box in Pyodide. Any Python libraries that use compiled code need to be loaded in Pyodide with special wheels.</p> <p>Lonboard does not use compiled code itself, but some of its dependencies \u2014 namely <code>arro3</code> \u2014 use compiled code. You may need to manually load <code>arro3</code> wheels before importing <code>lonboard</code>. Refer to the demo notebook for an example.</p>"},{"location":"ecosystem/pyodide/#memory-limits","title":"Memory limits","text":"<p>Pyodide has stricter memory limits than normal Python environments. Take care to delete Python objects you're no longer using with <code>del</code>.</p>"},{"location":"ecosystem/shiny/","title":"Shiny","text":"<p>Shiny is a tool to build interactive web applications and dashboards using Python code. Shiny integrates with Jupyter Widgets, which means that Lonboard is supported out-of-the-box.</p> <p>Pay attention to the \"Efficient updates\" section of the Shiny documentation. This is the most efficient way to create a reactive map. Take care to not recreate the <code>Map</code> widget from scratch on updates, as that will send data from Python to the browser anew.</p>"},{"location":"ecosystem/shiny/#example","title":"Example","text":"<pre><code>import geopandas as gpd\nfrom shiny import reactive\nfrom shiny.express import input, ui\nfrom shinywidgets import render_widget\n\nfrom lonboard import Map, ScatterplotLayer\n\ncolors = {\n    \"Red\": [200, 0, 0],\n    \"Green\": [0, 200, 0],\n    \"Blue\": [0, 0, 200],\n}\n\nui.input_select(\"color_select\", \"Color\", choices=list(colors.keys()))\n\n\n@render_widget\ndef map():\n    gdf = gpd.read_file(gpd.datasets.get_path(\"naturalearth_cities\"))\n    layer = ScatterplotLayer.from_geopandas(gdf, radius_min_pixels=2)\n    return Map(layer)\n\n\n@reactive.effect\ndef set_fill_color():\n    map.widget.layers[0].get_fill_color = colors[input.color_select()]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<ul> <li>Speedtest data  using <code>ScatterplotLayer</code></li> <li>North America roads  using <code>PathLayer</code></li> <li>Overture Maps buildings  using <code>PolygonLayer</code></li> <li>Air Traffic Control animation  using <code>TripsLayer</code></li> <li>Global boundaries  using <code>PolygonLayer</code></li> <li>U.S. County-to-County Migration  using <code>ArcLayer</code> and <code>BrushingExtension</code></li> <li>Scatterplot with GPU data filtering  using <code>ScatterplotLayer</code> and <code>DataFilterExtension</code></li> <li>Motor Vehicle Crashes in NYC  using <code>ScatterplotLayer</code></li> <li>Rivers in Asia  using <code>PathLayer</code></li> <li>Inflation Reduction Act Projects  using <code>ColumnLayer</code></li> <li>Linked Maps </li> </ul>"},{"location":"examples/#integrations","title":"Integrations","text":"<ul> <li>DuckDB Spatial  using <code>HeatmapLayer</code></li> <li>Color picker integration  using <code>SolidPolygonLayer</code></li> <li>JupyterLab Sidecar integration  using <code>ScatterplotLayer</code> and <code>JupyterLab Sidecar</code></li> <li>MovingPandas  using <code>TripsLayer</code></li> </ul>"},{"location":"examples/#third-party-showcase","title":"Third-party showcase","text":"<p>These examples are maintained by external contributors.</p> <ul> <li>American Community Survey exploration  using <code>ScatterplotLayer</code> and <code>DataFilterExtension</code> by @jaanli.</li> <li>Using Lonboard to visualize graph flows  using <code>ArcLayer</code>, <code>PolygonLayer</code>, and <code>BrushingExtension</code> by @knaaptime.</li> </ul>"},{"location":"examples/air-traffic-control/","title":"Air Traffic Control","text":"In\u00a0[\u00a0]: Copied! <pre>from datetime import timedelta\nfrom io import BytesIO\n\nimport requests\nfrom arro3.io import read_parquet\n\nfrom lonboard import Map\nfrom lonboard.experimental import TripsLayer\n</pre> from datetime import timedelta from io import BytesIO  import requests from arro3.io import read_parquet  from lonboard import Map from lonboard.experimental import TripsLayer <p>The bulk ADSB files distributed by adsb.lol are very large (~2GB). To make it easy to use this data in a demo, we've prepared an extract of only the data used in this demo.</p> <p>Information about how this extract was prepared is documented in <code>kylebarron/adsb-extract</code>.</p> <p>The Parquet file we're loading has been constructed in the specific format required by the <code>TripsLayer</code>. Airplane trajectories are stored as GeoArrow LineStrings in the <code>geometry</code> column. Timestamps are stored in the <code>timestamp</code> column in an Arrow list array, with the same nesting as the <code>geometry</code> column, so there's one timestamp per point.</p> In\u00a0[\u00a0]: Copied! <pre># Fetch the Parquet file and parse to an Arrow table\nurl = \"https://github.com/kylebarron/adsb-extract/releases/download/v0.1/2024-10-03_traces.parquet\"\nr = requests.get(url)\ntable = read_parquet(BytesIO(r.content)).read_all()\n</pre> # Fetch the Parquet file and parse to an Arrow table url = \"https://github.com/kylebarron/adsb-extract/releases/download/v0.1/2024-10-03_traces.parquet\" r = requests.get(url) table = read_parquet(BytesIO(r.content)).read_all() <p>Now we can create a <code>TripsLayer</code>. Since we already have Arrow data, we can pass it directly into the <code>table</code> argument.</p> In\u00a0[\u00a0]: Copied! <pre>layer = TripsLayer(\n    table=table,\n    get_timestamps=table[\"timestamp\"],\n    width_min_pixels=2,\n    get_color=[30, 30, 200, 200],\n    trail_length=200,\n    # Turn off tooltip data selection for better performance\n    pickable=False,\n)\n</pre> layer = TripsLayer(     table=table,     get_timestamps=table[\"timestamp\"],     width_min_pixels=2,     get_color=[30, 30, 200, 200],     trail_length=200,     # Turn off tooltip data selection for better performance     pickable=False, ) In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    layer,\n    view_state={\n        \"longitude\": -73.8,\n        \"latitude\": 40.6,\n        \"zoom\": 9.5,\n        \"pitch\": 50.6,\n        \"bearing\": 8.24,\n    },\n    # Increase height of generated map (API subject to change)\n    _height=800,\n)\nm\n</pre> m = Map(     layer,     view_state={         \"longitude\": -73.8,         \"latitude\": 40.6,         \"zoom\": 9.5,         \"pitch\": 50.6,         \"bearing\": 8.24,     },     # Increase height of generated map (API subject to change)     _height=800, ) m <p>Now we can animate the layer! Click the play button to watch the data animate!</p> In\u00a0[\u00a0]: Copied! <pre>layer.animate(step=timedelta(minutes=1), fps=50)\n</pre> layer.animate(step=timedelta(minutes=1), fps=50) <p>If you wish, you can stop the animation either with the UI controls above or with <code>stop_animation</code> below:</p> In\u00a0[\u00a0]: Copied! <pre>layer.stop_animation()\n</pre> layer.stop_animation() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/air-traffic-control/#air-traffic-control","title":"Air Traffic Control\u00b6","text":"<p>In this example we'll visualize air traffic control data for planes that arrive at or depart from three New York City-area airports: JFK, LGA, and EWR.</p> <p>This air traffic control data comes from adsb.lol, an open source project to distribute ADSB data.</p> <p></p>"},{"location":"examples/air-traffic-control/#dependencies","title":"Dependencies\u00b6","text":"<pre><code>pip install lonboard requests\n</code></pre>"},{"location":"examples/air-traffic-control/#imports","title":"Imports\u00b6","text":""},{"location":"examples/air-traffic-control/#notes","title":"Notes\u00b6","text":"<ul> <li>This dataset contains one day of flight data in the UTC time zone. So around 6 AM UTC time the animation will be mostly empty because not many planes are taking off after midnight eastern time.</li> <li>If you see some planes moving very fast between Asia and the U.S. west coast, that's due to issues in data handling around the antimeridian. When creating these data extracts in <code>adsb-extract</code>, I didn't do any special antimeridian handling, and so by default deck.gl thinks data is moving on a euclidean plane. The ideal way to solve this is to split trajectories that cross the antimeridian into two segments, but this is not yet implemented.</li> </ul>"},{"location":"examples/ais-movingpandas/","title":"MovingPandas Integration","text":"In\u00a0[1]: Copied! <pre>from datetime import timedelta\n\nimport geopandas as gpd\nimport movingpandas as mpd\nimport pandas as pd\nimport pyarrow as pa\n\nfrom lonboard import Map, PathLayer, viz\nfrom lonboard.colormap import apply_categorical_cmap\nfrom lonboard.experimental import TripsLayer\n</pre> from datetime import timedelta  import geopandas as gpd import movingpandas as mpd import pandas as pd import pyarrow as pa  from lonboard import Map, PathLayer, viz from lonboard.colormap import apply_categorical_cmap from lonboard.experimental import TripsLayer <pre>/Users/kyle/github/developmentseed/lonboard/.venv/lib/python3.11/site-packages/movingpandas/__init__.py:37: UserWarning: Missing optional dependencies. To use the trajectory smoother classes please install Stone Soup (see https://stonesoup.readthedocs.io/en/latest/#installation).\n  warnings.warn(e.msg, UserWarning)\n</pre> In\u00a0[2]: Copied! <pre>url = \"https://raw.githubusercontent.com/movingpandas/movingpandas-examples/refs/heads/main/data/ais.gpkg\"\ngdf = gpd.read_file(url, use_arrow=True)\n</pre> url = \"https://raw.githubusercontent.com/movingpandas/movingpandas-examples/refs/heads/main/data/ais.gpkg\" gdf = gpd.read_file(url, use_arrow=True) <p>Let's see what the data looks like:</p> In\u00a0[3]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[3]: Timestamp MMSI NavStatus SOG COG Name ShipType geometry 0 05/07/2017 00:00:03 219632000 Under way using engine 0.0 270.4 None Undefined POINT (11.85958 57.68817) 1 05/07/2017 00:00:05 265650970 Under way using engine 0.0 0.5 None Undefined POINT (11.84175 57.66150) 2 05/07/2017 00:00:06 265503900 Under way using engine 0.0 0.0 None Undefined POINT (11.90650 57.69077) 3 05/07/2017 00:00:14 219632000 Under way using engine 0.0 188.4 None Undefined POINT (11.85958 57.68817) 4 05/07/2017 00:00:19 265519650 Under way using engine 0.0 357.2 None Undefined POINT (11.87192 57.68233) <p>And let's plot the raw data on a map. This plots each individual point from all ships.</p> In\u00a0[4]: Copied! <pre>viz(gdf)\n</pre> viz(gdf) Out[4]: <pre>Map(basemap_style=&lt;CartoBasemap.DarkMatter: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json'\u2026</pre> <p>As with the upstream example, let's remove any records where the ships aren't moving.</p> In\u00a0[5]: Copied! <pre>print(f\"Original size: {len(gdf)} rows\")\ngdf = gdf[gdf[\"SOG\"] &gt; 0]\nprint(f\"Reduced to {len(gdf)} rows after removing 0 speed records\")\n</pre> print(f\"Original size: {len(gdf)} rows\") gdf = gdf[gdf[\"SOG\"] &gt; 0] print(f\"Reduced to {len(gdf)} rows after removing 0 speed records\") <pre>Original size: 84702 rows\nReduced to 33593 rows after removing 0 speed records\n</pre> <p>This is drawn directly from the upstream example.</p> In\u00a0[6]: Copied! <pre>gdf[\"t\"] = pd.to_datetime(gdf[\"Timestamp\"], format=\"%d/%m/%Y %H:%M:%S\")\ntraj_collection = mpd.TrajectoryCollection(gdf, \"MMSI\", t=\"t\", min_length=100)\nprint(f\"Finished creating {len(traj_collection)} trajectories\")\n</pre> gdf[\"t\"] = pd.to_datetime(gdf[\"Timestamp\"], format=\"%d/%m/%Y %H:%M:%S\") traj_collection = mpd.TrajectoryCollection(gdf, \"MMSI\", t=\"t\", min_length=100) print(f\"Finished creating {len(traj_collection)} trajectories\") <pre>Finished creating 77 trajectories\n</pre> In\u00a0[7]: Copied! <pre>traj_collection = mpd.MinTimeDeltaGeneralizer(traj_collection).generalize(\n    tolerance=timedelta(minutes=1)\n)\n</pre> traj_collection = mpd.MinTimeDeltaGeneralizer(traj_collection).generalize(     tolerance=timedelta(minutes=1) ) In\u00a0[8]: Copied! <pre>shiptype_to_color = {\n    \"Passenger\": \"blue\",\n    \"HSC\": \"green\",\n    \"Tanker\": \"red\",\n    \"Cargo\": \"orange\",\n    \"Sailing\": \"grey\",\n    \"Other\": \"grey\",\n    \"Tug\": \"grey\",\n    \"SAR\": \"grey\",\n    \"Undefined\": \"grey\",\n    \"Pleasure\": \"grey\",\n    \"Dredging\": \"grey\",\n    \"Law enforcement\": \"grey\",\n    \"Pilot\": \"grey\",\n    \"Fishing\": \"grey\",\n    \"Diving\": \"grey\",\n    \"Spare 2\": \"grey\",\n}\n</pre> shiptype_to_color = {     \"Passenger\": \"blue\",     \"HSC\": \"green\",     \"Tanker\": \"red\",     \"Cargo\": \"orange\",     \"Sailing\": \"grey\",     \"Other\": \"grey\",     \"Tug\": \"grey\",     \"SAR\": \"grey\",     \"Undefined\": \"grey\",     \"Pleasure\": \"grey\",     \"Dredging\": \"grey\",     \"Law enforcement\": \"grey\",     \"Pilot\": \"grey\",     \"Fishing\": \"grey\",     \"Diving\": \"grey\",     \"Spare 2\": \"grey\", } <p>We'll extract the ship type from each trajectory. In general, you'd expect this to be consistent, but in this dataset apparently some trajectories have multiple values for this, so we'll take the first unique value.</p> In\u00a0[9]: Copied! <pre>ship_types = []\nfor traj in traj_collection.trajectories:\n    unique_vals = traj.df[\"ShipType\"].unique()\n    # Apparently this is not always consistent\n    # assert len(unique_vals) == 1, \"Expected single ship type per trajectory\"\n    ship_types.append(unique_vals[0])\n</pre> ship_types = [] for traj in traj_collection.trajectories:     unique_vals = traj.df[\"ShipType\"].unique()     # Apparently this is not always consistent     # assert len(unique_vals) == 1, \"Expected single ship type per trajectory\"     ship_types.append(unique_vals[0]) <p>Now we'll use <code>apply_categorical_cmap</code> to get colors from this data and color mapping.</p> In\u00a0[10]: Copied! <pre>get_color = apply_categorical_cmap(pa.array(ship_types), shiptype_to_color)\n</pre> get_color = apply_categorical_cmap(pa.array(ship_types), shiptype_to_color) <p>Then we can pass our data to <code>TripsLayer.from_movingpandas</code>:</p> In\u00a0[11]: Copied! <pre>trips_layer = TripsLayer.from_movingpandas(\n    traj_collection, get_color=get_color, width_min_pixels=5, trail_length = 200\n)\n</pre> trips_layer = TripsLayer.from_movingpandas(     traj_collection, get_color=get_color, width_min_pixels=5, trail_length = 200 ) <pre>/Users/kyle/github/developmentseed/lonboard/lonboard/experimental/traits.py:146: UserWarning: Reducing precision of input timestamp data to 's' to fit into available GPU precision.\n  warnings.warn(\n</pre> In\u00a0[12]: Copied! <pre>m = Map(trips_layer, _height=600)\nm\n</pre> m = Map(trips_layer, _height=600) m Out[12]: <pre>Map(custom_attribution='', layers=(TripsLayer(get_color=arro3.core.ChunkedArray&lt;FixedSizeList(Field { name: \"\"\u2026</pre> <p>Now we can animate our data! Click the play button after running the following cell to watch the animation:</p> In\u00a0[13]: Copied! <pre>trips_layer.animate(step=timedelta(seconds=30), fps=50)\n</pre> trips_layer.animate(step=timedelta(seconds=30), fps=50) Out[13]: <pre>HBox(children=(Play(value=-16777216, interval=20, max=-16690894, min=-16777216, repeat=True, step=30), Output(\u2026</pre> In\u00a0[14]: Copied! <pre>linestring_layer = PathLayer(\n    table=trips_layer.table, get_color=get_color, width_min_pixels=1, opacity=0.005\n)\n</pre> linestring_layer = PathLayer(     table=trips_layer.table, get_color=get_color, width_min_pixels=1, opacity=0.005 ) <p>And we'll add that layer to the existing map:</p> In\u00a0[15]: Copied! <pre>m.add_layer(linestring_layer)\n</pre> m.add_layer(linestring_layer) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/ais-movingpandas/#movingpandas-integration","title":"MovingPandas Integration\u00b6","text":"<p>This tutorial is derived from an upstream MovingPandas example.</p> <p>We'll plot and animate AIS ship data published by the Danish Maritime Authority.</p> <p></p>"},{"location":"examples/ais-movingpandas/#dependencies","title":"Dependencies\u00b6","text":"<pre><code>pip install lonboard movingpandas \"geopandas&gt;=1\" pyarrow\n</code></pre>"},{"location":"examples/ais-movingpandas/#imports","title":"Imports\u00b6","text":""},{"location":"examples/ais-movingpandas/#loading-sample-ais-data","title":"Loading sample AIS data\u00b6","text":"<p>We'll load the same AIS data as the upstream notebook.</p>"},{"location":"examples/ais-movingpandas/#creating-trajectories","title":"Creating trajectories\u00b6","text":""},{"location":"examples/ais-movingpandas/#plotting-trajectories","title":"Plotting trajectories\u00b6","text":""},{"location":"examples/ais-movingpandas/#adding-the-full-trajectories","title":"Adding the full trajectories\u00b6","text":"<p>We can use the same Arrow data from the above <code>TripsLayer</code> and pass that into a <code>PathLayer</code>. The Arrow data from the <code>TripsLayer</code> is accessed with <code>trips_layer.table</code> and can be passed directly into the <code>table</code> argument of the <code>PathLayer</code>.</p> <p>We'll set the opacity pretty low as we want the full trajectories to be background information:</p>"},{"location":"examples/column-layer/","title":"ColumnLayer Example","text":"In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\nfrom lonboard import Map, ColumnLayer\n</pre> import geopandas as gpd from lonboard import Map, ColumnLayer In\u00a0[\u00a0]: Copied! <pre>DATA_URL = 'https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson'\n</pre> DATA_URL = 'https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson' In\u00a0[\u00a0]: Copied! <pre>df = gpd.read_file(DATA_URL, use_arrow=True)\n</pre> df = gpd.read_file(DATA_URL, use_arrow=True) In\u00a0[\u00a0]: Copied! <pre>layer = ColumnLayer.from_geopandas(\n    df, \n    get_elevation=df[\"FUNDING_NUMERIC\"], \n    get_fill_color = [255, 255, 0, 140],\n    elevation_scale=.01,\n    radius=10000,\n    pickable=True,\n    auto_highlight=True,\n)\n</pre> layer = ColumnLayer.from_geopandas(     df,      get_elevation=df[\"FUNDING_NUMERIC\"],      get_fill_color = [255, 255, 0, 140],     elevation_scale=.01,     radius=10000,     pickable=True,     auto_highlight=True, ) In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    layer,\n    view_state={\"longitude\": -100, \"latitude\": 35, \"zoom\": 4, \"pitch\": 45, \"bearing\": 0},\n)\nm\n</pre> m = Map(     layer,     view_state={\"longitude\": -100, \"latitude\": 35, \"zoom\": 4, \"pitch\": 45, \"bearing\": 0}, ) m"},{"location":"examples/column-layer/#columnlayer-example","title":"ColumnLayer Example\u00b6","text":"<p>This is a quick example notebook to show how to use the <code>ColumnLayer</code>.</p> <p>This is derived from <code>@cboettig</code>'s example in this issue.</p> <p></p>"},{"location":"examples/column-layer/#dependencies","title":"Dependencies\u00b6","text":"<pre><code>pip install lonboard geopandas pyarrow\n</code></pre>"},{"location":"examples/column-layer/#imports","title":"Imports\u00b6","text":""},{"location":"examples/data-filter-extension/","title":"DataFilterExtension","text":"<p>As with the <code>ScatterplotLayer</code> example, this example will use data from Ookla's Speed Test application and shared publicly in the AWS Open Data Registry.</p> In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nimport geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom ipywidgets import FloatRangeSlider, jsdlink\nfrom palettable.colorbrewer.diverging import BrBG_10\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\nfrom lonboard.controls import MultiRangeSlider\nfrom lonboard.layer_extension import DataFilterExtension\n</pre> from pathlib import Path  import geopandas as gpd import numpy as np import pandas as pd import shapely from ipywidgets import FloatRangeSlider, jsdlink from palettable.colorbrewer.diverging import BrBG_10  from lonboard import Map, ScatterplotLayer from lonboard.colormap import apply_continuous_cmap from lonboard.controls import MultiRangeSlider from lonboard.layer_extension import DataFilterExtension In\u00a0[3]: Copied! <pre>url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\"\nlocal_path = Path(\"data-filter-extension.parquet\")\nif local_path.exists():\n    gdf = gpd.read_parquet(local_path)\nelse:\n    columns = [\"avg_d_kbps\", \"avg_u_kbps\", \"avg_lat_ms\", \"devices\", \"tile\"]\n    df = pd.read_parquet(url, columns=columns)\n\n    tile_geometries = shapely.from_wkt(df[\"tile\"])\n    tile_centroids = shapely.centroid(tile_geometries)\n    non_geom_columns = [col for col in columns if col != \"tile\"]\n    gdf = gpd.GeoDataFrame(df[non_geom_columns], geometry=tile_centroids, crs=\"EPSG:4326\")\n    gdf.to_parquet(local_path)\n</pre> url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\" local_path = Path(\"data-filter-extension.parquet\") if local_path.exists():     gdf = gpd.read_parquet(local_path) else:     columns = [\"avg_d_kbps\", \"avg_u_kbps\", \"avg_lat_ms\", \"devices\", \"tile\"]     df = pd.read_parquet(url, columns=columns)      tile_geometries = shapely.from_wkt(df[\"tile\"])     tile_centroids = shapely.centroid(tile_geometries)     non_geom_columns = [col for col in columns if col != \"tile\"]     gdf = gpd.GeoDataFrame(df[non_geom_columns], geometry=tile_centroids, crs=\"EPSG:4326\")     gdf.to_parquet(local_path) <p>Taking a quick look at this data, we see that we have 3.2 million records.</p> In\u00a0[4]: Copied! <pre>gdf\n</pre> gdf Out[4]: avg_d_kbps avg_u_kbps avg_lat_ms devices geometry 0 5983 7886 68 1 POINT (-160.01862 70.63722) 1 3748 5841 78 2 POINT (-160.04059 70.63357) 2 3364 6200 78 2 POINT (-160.04059 70.63175) 3 2381 2328 86 1 POINT (-160.03510 70.63357) 4 3047 5356 75 1 POINT (-160.03510 70.63175) ... ... ... ... ... ... 3231240 19528 3200 68 1 POINT (169.81842 -46.29571) 3231241 15693 10359 56 1 POINT (169.81293 -46.30710) 3231242 26747 9674 58 2 POINT (169.66461 -46.42082) 3231243 67995 13564 63 1 POINT (169.65912 -46.45110) 3231244 1230 1798 55 1 POINT (168.85162 -46.56075) <p>3231245 rows \u00d7 5 columns</p> <p>Since we want to cross-filter on three attributes at once, we create a <code>DataFilterExtension</code> instance with <code>filter_size=3</code>.</p> In\u00a0[5]: Copied! <pre>filter_extension = DataFilterExtension(filter_size=3)\n</pre> filter_extension = DataFilterExtension(filter_size=3) <p>Similar to the <code>ScatterplotLayer</code> example notebook, we create a normalized download speed to use for a per-point color and radius.</p> In\u00a0[6]: Copied! <pre>min_bound = 5000\nmax_bound = 50000\nnormalized_download_speed = (gdf[\"avg_d_kbps\"] - min_bound) / (max_bound - min_bound)\nfill_color = apply_continuous_cmap(normalized_download_speed, BrBG_10)\nradius = normalized_download_speed * 200\n</pre> min_bound = 5000 max_bound = 50000 normalized_download_speed = (gdf[\"avg_d_kbps\"] - min_bound) / (max_bound - min_bound) fill_color = apply_continuous_cmap(normalized_download_speed, BrBG_10) radius = normalized_download_speed * 200 <p>Next we prepare the columns that we want to filter on. In this case, we'll filter on the download speed, upload speed, and latency values. These need to be passed in as a single two-dimensional numpy array, so we use <code>numpy.column_stack</code>. Only numeric arrays can be used for GPU-based filtering.</p> <p>We also define initial filter ranges for each of these columns.</p> In\u00a0[7]: Copied! <pre>filter_values = np.column_stack(\n    [gdf[\"avg_d_kbps\"], gdf[\"avg_u_kbps\"], gdf[\"avg_lat_ms\"]]\n)\ninitial_filter_range = [\n    [10_000, 50_000],\n    [1000, 10_000],\n    [0, 100],\n]\n</pre> filter_values = np.column_stack(     [gdf[\"avg_d_kbps\"], gdf[\"avg_u_kbps\"], gdf[\"avg_lat_ms\"]] ) initial_filter_range = [     [10_000, 50_000],     [1000, 10_000],     [0, 100], ] <p>Next we create a <code>ScatterplotLayer</code> with our desired attributes. Keep in mind that you must pass the <code>DataFilterExtension</code> instance to the <code>extensions</code> parameter in order to activate its functionality on the layer.</p> In\u00a0[8]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(\n    gdf,\n    extensions=[filter_extension],\n    get_fill_color=fill_color,\n    get_radius=radius,\n    get_filter_value=filter_values,\n    filter_range=initial_filter_range,\n    radius_units=\"meters\",\n    radius_min_pixels=0.1,\n)\nm = Map(layer)\nm\n</pre> layer = ScatterplotLayer.from_geopandas(     gdf,     extensions=[filter_extension],     get_fill_color=fill_color,     get_radius=radius,     get_filter_value=filter_values,     filter_range=initial_filter_range,     radius_units=\"meters\",     radius_min_pixels=0.1, ) m = Map(layer) m Out[8]: <p>Only the points that are within all of our initial filter ranges are shown, but we'd like something more interactive. Let's connect sliders to the map.</p> <p>Here we create a separate slider for each attribute and then connect them using a <code>MultiRangeSlider</code>. This defines the slider element but it won't be connected to the map until we use <code>ipywidgets.jsdlink</code> later.</p> In\u00a0[9]: Copied! <pre>download_slider = FloatRangeSlider(value=initial_filter_range[0], min=0, max=70_000, step=0.1, description=\"Download: \")\nupload_slider = FloatRangeSlider(value=initial_filter_range[1], min=0, max=50_000, step=1, description=\"Upload: \")\nlatency_slider = FloatRangeSlider(value=initial_filter_range[2], min=0, max=500, step=1, description=\"Latency: \")\nmulti_slider = MultiRangeSlider([download_slider, upload_slider, latency_slider])\nmulti_slider\n</pre> download_slider = FloatRangeSlider(value=initial_filter_range[0], min=0, max=70_000, step=0.1, description=\"Download: \") upload_slider = FloatRangeSlider(value=initial_filter_range[1], min=0, max=50_000, step=1, description=\"Upload: \") latency_slider = FloatRangeSlider(value=initial_filter_range[2], min=0, max=500, step=1, description=\"Latency: \") multi_slider = MultiRangeSlider([download_slider, upload_slider, latency_slider]) multi_slider Out[9]: <p>In order to propagate the changes in our sliders to the <code>ScatterplotLayer</code> instance, we use <code>jsdlink</code>. See Linking Widgets in the ipywidgets documentation for more info.</p> In\u00a0[10]: Copied! <pre>_ = jsdlink((multi_slider, \"value\"), (layer, \"filter_range\"))\n</pre> _ = jsdlink((multi_slider, \"value\"), (layer, \"filter_range\")) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/data-filter-extension/#datafilterextension","title":"DataFilterExtension\u00b6","text":"<p>The <code>DataFilterExtension</code> adds GPU-based data filtering functionalities to layers, allowing the layer to show/hide objects based on user-defined properties.</p> <p>In this demo we'll use the <code>DataFilterExtension</code> to filter millions of points based on three numeric attributes.</p>"},{"location":"examples/data-filter-extension/#imports","title":"Imports\u00b6","text":""},{"location":"examples/data-filter-extension/#fetch-data","title":"Fetch data\u00b6","text":"<p>We use the same data as the <code>ScatterplotLayer</code> example except that here we download extra columns from the dataset to use for filtering.</p> <p>Columns:</p> <ul> <li><code>avg_d_kbps</code>: the average download speed for that data point in kbps</li> <li><code>avg_u_kbps</code>: the average upload speed for that data point in kbps</li> <li><code>avg_lat_ms</code>: the average latency for that data point in milliseconds</li> <li><code>devices</code>: the number of unique devices contributing tests in the tile.</li> <li><code>tile</code>: the WKT string representing a given zoom-16 Web Mercator tile</li> </ul> <p>We cache the downloaded file locally to <code>data-filter-extension.parquet</code> so that the second time running this notebook will be faster.</p>"},{"location":"examples/duckdb/","title":"DuckDB Spatial","text":"In\u00a0[\u00a0]: Copied! <pre>import duckdb\nfrom lonboard import HeatmapLayer, Map\n</pre> import duckdb from lonboard import HeatmapLayer, Map <p>Create a database connection and install and load the Spatial extension:</p> In\u00a0[\u00a0]: Copied! <pre>con = duckdb.connect()\nduckdb.install_extension(\"spatial\", connection=con)\nduckdb.load_extension(\"spatial\", connection=con)\n</pre> con = duckdb.connect() duckdb.install_extension(\"spatial\", connection=con) duckdb.load_extension(\"spatial\", connection=con) <p>We load this data directly from the New York City taxi dataset webpage, here loading data from March 2010 (later years of data do not have exact longitude-latitude locations). We also create a geometry column with the <code>ST_Point</code> constructor, passing in the drop off longitude and latitude columns.</p> <p>There are a few incorrect location values in this dataset with longitude/latitude near \"null island\" at (0, 0), so we pass in bounding-box filtering around the New York City region.</p> <p>Then we execute this query in our connection.</p> In\u00a0[\u00a0]: Copied! <pre>sql = \"\"\"\nCREATE TABLE rides AS\nSELECT \n    *,\n    ST_Point(dropoff_longitude, dropoff_latitude) as geometry\nFROM \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-03.parquet\" \nWHERE\n    dropoff_longitude &gt;= -74.6087 AND\n    dropoff_latitude &gt;= 40.2738 AND\n    dropoff_longitude &lt;= -73.4928 AND\n    dropoff_latitude &lt;= 41.1757 AND\n    total_amount &gt; 0\nLIMIT 1_000_000;\n\"\"\"\ncon.execute(sql)\n</pre> sql = \"\"\" CREATE TABLE rides AS SELECT      *,     ST_Point(dropoff_longitude, dropoff_latitude) as geometry FROM \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-03.parquet\"  WHERE     dropoff_longitude &gt;= -74.6087 AND     dropoff_latitude &gt;= 40.2738 AND     dropoff_longitude &lt;= -73.4928 AND     dropoff_latitude &lt;= 41.1757 AND     total_amount &gt; 0 LIMIT 1_000_000; \"\"\" con.execute(sql) <p>Inspecting this table, we can see a variety of columns, plus our <code>geometry</code> column:</p> In\u00a0[\u00a0]: Copied! <pre>con.table(\"rides\")\n</pre> con.table(\"rides\") <p>To pass this data into Lonboard, we can pass a string query or \"relation object\" into the <code>from_duckdb</code> class method, plus a reference to our connection. Here the <code>con.table(\"rides\")</code> call creates a relation that refers to the entire <code>rides</code> table.</p> In\u00a0[\u00a0]: Copied! <pre>layer = HeatmapLayer.from_duckdb(con.table(\"rides\"), con)\n</pre> layer = HeatmapLayer.from_duckdb(con.table(\"rides\"), con) In\u00a0[\u00a0]: Copied! <pre>m = Map(layer)\nm\n</pre> m = Map(layer) m <p>DuckDB Spatial does not currently export coordinate reference system information, but in this case we know the data is already in the EPSG:4326 (WGS84) coordinate system, so we can ignore the generated warning.</p> <p>The heatmap by default assigns a weight of 1 to each row, so the heatmap shows the unweighted density of rides. We can change this by modifying the <code>get_weight</code> attribute.</p> <p>Let's weight the heatmap by the cost of the ride. We can do this by passing in a column from <code>total_amount</code>. We can access this column by selecting a table with only that data:</p> In\u00a0[\u00a0]: Copied! <pre>total_amount_table = con.sql(\"SELECT total_amount from rides\").arrow()\n</pre> total_amount_table = con.sql(\"SELECT total_amount from rides\").arrow() <p>We want a single column to pass in to the layer, so we select the <code>total_amount</code> column:</p> In\u00a0[\u00a0]: Copied! <pre>total_amount = total_amount_table[\"total_amount\"]\n</pre> total_amount = total_amount_table[\"total_amount\"] <p>Then we assign this onto the <code>get_weight</code> accessor</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_weight = total_amount\n</pre> layer.get_weight = total_amount <p>Note that the heatmap around airports such as LaGuardia is now darker. There are fewer total rides dropping off at the airport, but each one is expensive!</p>"},{"location":"examples/duckdb/#duckdb-spatial","title":"DuckDB Spatial\u00b6","text":"<p>This is a short example notebook to show how to use DuckDB Spatial with Lonboard. We'll create a HeatmapLayer with NYC Taxi data.</p> <p>For full information on how to use DuckDB with Lonboard, refer to the documentation.</p>"},{"location":"examples/global-boundaries/","title":"Municipal Boundaries","text":"In\u00a0[1]: Copied! <pre>! pip --quiet install pyogrio lonboard requests pyarrow geopandas tqdm\n</pre> ! pip --quiet install pyogrio lonboard requests pyarrow geopandas tqdm <pre>\n[notice] A new release of pip is available: 23.3.2 -&gt; 24.0\n[notice] To update, run: pip install --upgrade pip\n</pre> In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nimport geopandas as gpd\nimport requests\nfrom tqdm import tqdm\n\nfrom lonboard import Map, PolygonLayer\n</pre> from pathlib import Path  import geopandas as gpd import requests from tqdm import tqdm  from lonboard import Map, PolygonLayer <p>The URL for a large data file of CGAZ at ADM1 Districts level:</p> In\u00a0[3]: Copied! <pre>url = \"https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM1.geojson\"\nfilepath = \"geoBoundariesCGAZ_ADM1.geojson\"\n</pre> url = \"https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM1.geojson\" filepath = \"geoBoundariesCGAZ_ADM1.geojson\" <p>We'll go ahead and fetch the GeoJSON data in that format. If this notebook has already been run once and the file exists locally, we'll skip downloading it again.</p> In\u00a0[4]: Copied! <pre>if not Path(filepath).exists():\n    # Make a GET request to download the file\n    # Streaming, so we can iterate over the response and create a progress bar for this large file\n    response = requests.get(url, stream=True)\n\n    # Sizes in bytes.\n    total_size = int(response.headers.get(\"content-length\", 0))\n    block_size = 1024\n\n    with tqdm(total=total_size, unit=\"B\", unit_scale=True) as progress_bar:\n        with open(filepath, \"wb\") as file:\n            for data in response.iter_content(block_size):\n                progress_bar.update(len(data))\n                file.write(data)\n\n    if total_size != 0 and progress_bar.n != total_size:\n        raise RuntimeError(\"Could not download file\")\n</pre> if not Path(filepath).exists():     # Make a GET request to download the file     # Streaming, so we can iterate over the response and create a progress bar for this large file     response = requests.get(url, stream=True)      # Sizes in bytes.     total_size = int(response.headers.get(\"content-length\", 0))     block_size = 1024      with tqdm(total=total_size, unit=\"B\", unit_scale=True) as progress_bar:         with open(filepath, \"wb\") as file:             for data in response.iter_content(block_size):                 progress_bar.update(len(data))                 file.write(data)      if total_size != 0 and progress_bar.n != total_size:         raise RuntimeError(\"Could not download file\") In\u00a0[5]: Copied! <pre>gdf = gpd.read_file(filepath, engine=\"pyogrio\", use_arrow=True)\n\n# Keep columns necessary for our visualization\ncols = [\"shapeName\", \"shapeID\", \"geometry\"]\ngdf = gdf[cols]\n</pre> gdf = gpd.read_file(filepath, engine=\"pyogrio\", use_arrow=True)  # Keep columns necessary for our visualization cols = [\"shapeName\", \"shapeID\", \"geometry\"] gdf = gdf[cols] <p>We can take a quick look at the shape of this data:</p> In\u00a0[6]: Copied! <pre>gdf.head(10)\n</pre> gdf.head(10) Out[6]: shapeName shapeID geometry 0 Kandahar 12653393B40111500734429 POLYGON ((65.24153 32.28630, 65.12687 32.03679... 1 Zabul 12653393B56617740339660 POLYGON ((67.60666 31.44378, 67.70162 31.51373... 2 Uruzgan 12653393B46006342616872 POLYGON ((66.27519 32.42550, 66.35907 32.60925... 3 Daykundi 12653393B78791504725813 POLYGON ((66.76157 33.25547, 66.92827 33.59694... 4 Ghanzi 12653393B29313712249365 POLYGON ((68.06945 32.04564, 68.06011 32.45619... 5 Paktika 12653393B93572570471663 MULTIPOLYGON (((68.10797 31.74752, 68.10807 31... 6 Khost 12653393B66876919073955 POLYGON ((69.50619 33.02954, 69.50620 33.02954... 7 Paktia 12653393B16859990709200 POLYGON ((68.76070 33.41986, 68.95811 33.18136... 8 Logar 12653393B769191277822 POLYGON ((68.78347 33.62259, 68.99623 33.62635... 9 Wardak 12653393B94990201402617 POLYGON ((68.68691 33.72585, 68.86023 34.01301... <p>Without doing any simplification, the geometries in this dataset contain nearly 9 million coordinates (You can verify this with <code>shapely.get_num_coordinates(gdf[\"geometry\"]).sum()</code>).</p> <p>On recent computers, Lonboard should be able to visualize the entire dataset, but to ensure this dataset works on all computers, we'll select only rows whose geometries are at least partially in the eastern hemisphere:</p> In\u00a0[7]: Copied! <pre>eastern_hemisphere = gdf.cx[0:180, -90:90]\n</pre> eastern_hemisphere = gdf.cx[0:180, -90:90] In\u00a0[8]: Copied! <pre>layer = PolygonLayer.from_geopandas(\n    eastern_hemisphere,\n    get_line_width=20,  # width in default units (meters)\n    line_width_min_pixels=0.2,  # minimum width when zoomed out\n    get_fill_color=[204, 251, 254],  # light blue\n    get_line_color=[37, 36, 34],  # dark border color\n)\n</pre> layer = PolygonLayer.from_geopandas(     eastern_hemisphere,     get_line_width=20,  # width in default units (meters)     line_width_min_pixels=0.2,  # minimum width when zoomed out     get_fill_color=[204, 251, 254],  # light blue     get_line_color=[37, 36, 34],  # dark border color ) In\u00a0[9]: Copied! <pre>m = Map(layer)\nm\n</pre> m = Map(layer) m Out[9]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/global-boundaries/#municipal-boundaries","title":"Municipal Boundaries\u00b6","text":"<p>This example will use data from GeoBoundaries.org's data set of Comprehensive Global Administrative Zones (CGAZ).</p> <p>CGAZ is a set of global composites for administrative boundaries. There are two important distinctions between our global product and individual country downloads. First, extensive simplification is performed to ensure that file sizes are small enough to be used in most traditional desktop software. Second, disputed areas are removed and replaced with polygons following US Department of State definitions. Attribution: www.geoboundaries.org</p> <p>Note: This notebook incurs downloading a 360MB file. To successfully follow this example, please ensure sufficient storage space. The time to download this data will vary based on internet connection speed. We've added a download progress bar to the data retrieval section of this notebook to allow you to view progress and a time estimate for downloading the visualization data.</p>"},{"location":"examples/global-boundaries/#imports","title":"Imports\u00b6","text":""},{"location":"examples/global-boundaries/#visualize-global-boundaries","title":"Visualize Global Boundaries\u00b6","text":"<p>Let's visualize this dataset.</p> <p>We'll start by loading the data into GeoPandas. It's recommended to use the newer <code>pyogrio</code> library for faster data loading.</p>"},{"location":"examples/global-boundaries/#visualizing-the-data","title":"Visualizing the data\u00b6","text":"<p>We can use a <code>PolygonLayer</code> to customize the rendering of this data.</p>"},{"location":"examples/internet-speeds/","title":"Speedtest Data","text":"In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n\nimport geopandas as gpd\nimport pandas as pd\nimport shapely\nfrom palettable.colorbrewer.diverging import BrBG_10\nfrom sidecar import Sidecar\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> from pathlib import Path  import geopandas as gpd import pandas as pd import shapely from palettable.colorbrewer.diverging import BrBG_10 from sidecar import Sidecar  from lonboard import Map, ScatterplotLayer from lonboard.colormap import apply_continuous_cmap <p>The URL for a single data file for mobile network speeds in the first quarter of 2019:</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\"\n</pre> url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\" <p>The data used in this example is relatively large. In the cell below, we cache the downloading and preparation of the dataset so that it's faster to run this notebook the second time.</p> <p>We fetch two columns \u2014 <code>avg_d_kbps</code> and <code>tile</code> \u2014 from this data file directly from AWS. The <code>pd.read_parquet</code> command will perform a network request for these columns from the data file, so it may take a while on a slow network connection. <code>avg_d_kbps</code> is the average download speed for that data point in kilobits per second. <code>tile</code> is the WKT string representing a given zoom-16 Web Mercator tile.</p> <p>The <code>tile</code> column contains strings representing WKT-formatted geometries. We need to parse those strings into geometries. Then for simplicity we'll convert into their centroids.</p> In\u00a0[\u00a0]: Copied! <pre>local_path = Path(\"internet-speeds.parquet\")\nif local_path.exists():\n    gdf = gpd.read_parquet(local_path)\nelse:\n    columns = [\"avg_d_kbps\", \"tile\"]\n    df = pd.read_parquet(url, columns=columns)\n\n    tile_geometries = shapely.from_wkt(df[\"tile\"])\n    tile_centroids = shapely.centroid(tile_geometries)\n    gdf = gpd.GeoDataFrame(df[[\"avg_d_kbps\"]], geometry=tile_centroids, crs=\"EPSG:4326\")\n    gdf.to_parquet(local_path)\n</pre> local_path = Path(\"internet-speeds.parquet\") if local_path.exists():     gdf = gpd.read_parquet(local_path) else:     columns = [\"avg_d_kbps\", \"tile\"]     df = pd.read_parquet(url, columns=columns)      tile_geometries = shapely.from_wkt(df[\"tile\"])     tile_centroids = shapely.centroid(tile_geometries)     gdf = gpd.GeoDataFrame(df[[\"avg_d_kbps\"]], geometry=tile_centroids, crs=\"EPSG:4326\")     gdf.to_parquet(local_path) <p>We can take a quick look at this data:</p> In\u00a0[\u00a0]: Copied! <pre>gdf.head()\n</pre> gdf.head() <p>To ensure that this demo is snappy on most computers, we'll filter to a bounding box over Europe.</p> <p>If you're on a recent computer, feel free to comment out the next line.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gdf.cx[-11.83:25.5, 34.9:59]\n</pre> gdf = gdf.cx[-11.83:25.5, 34.9:59] <p>Even this filtered data frame still has 800,000 rows, so it's still a lot of data to explore:</p> In\u00a0[\u00a0]: Copied! <pre>gdf\n</pre> gdf <p>To render point data, first create a <code>ScatterplotLayer</code> and then add it to a <code>Map</code> object:</p> In\u00a0[\u00a0]: Copied! <pre>sidecar = Sidecar()\n</pre> sidecar = Sidecar() In\u00a0[\u00a0]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nm = Map(layer, _height=800)\nwith sidecar:\n    display(m)\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) m = Map(layer, _height=800) with sidecar:     display(m) <p>We can look at the documentation for <code>ScatterplotLayer</code> to see what other rendering options it allows. Let's set the fill color to something other than black:</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_fill_color = [0, 0, 200, 200]\n</pre> layer.get_fill_color = [0, 0, 200, 200] <p>Blue is pretty, but the map would be more informative if we colored each point by a relevant characteristic. In this case, we have the download speed associated with each location, so let's use that!</p> <p>Here we compute a linear statistic for the download speed. Given a minimum bound of <code>5000</code> and a maximum bound of <code>50,000</code> the normalized speed is linearly scaled to between 0 and 1.</p> In\u00a0[\u00a0]: Copied! <pre>min_bound = 5000\nmax_bound = 50000\ndownload_speed = gdf[\"avg_d_kbps\"]\nnormalized_download_speed = (download_speed - min_bound) / (max_bound - min_bound)\n</pre> min_bound = 5000 max_bound = 50000 download_speed = gdf[\"avg_d_kbps\"] normalized_download_speed = (download_speed - min_bound) / (max_bound - min_bound) <p><code>normalized_download_speed</code> is now linearly scaled based on the bounds provided above. Keep in mind that the input range of the colormap is 0-1. So any values that are below 0 will receive the left-most color in the colormap, while any values above 1 will receive the right-most color in the colormap.</p> In\u00a0[\u00a0]: Copied! <pre>normalized_download_speed\n</pre> normalized_download_speed <p>We can use any colormap provided by the <code>palettable</code> package. Let's inspect the <code>BrBG_10</code> diverging colormap below:</p> In\u00a0[\u00a0]: Copied! <pre>BrBG_10.mpl_colormap\n</pre> BrBG_10.mpl_colormap <p>Now let's apply the colormap on <code>normalized_download_speed</code> using a helper provided by <code>lonboard</code>. We can set it on <code>layer.get_fill_color</code> to update the existing colors.</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_fill_color = apply_continuous_cmap(\n    normalized_download_speed, BrBG_10, alpha=0.7\n)\n</pre> layer.get_fill_color = apply_continuous_cmap(     normalized_download_speed, BrBG_10, alpha=0.7 ) <p>After running the above cell, you should see the map above update with a different color per point!</p> <p>We can pass an array into any of the \"accessors\" supported by the layer (this is any attribute that starts with <code>get_*</code>).</p> <p>For demonstration purposes, let's also set <code>get_radius</code> to <code>normalized_download_speed</code>.</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_radius = normalized_download_speed * 200\nlayer.radius_units = \"meters\"\nlayer.radius_min_pixels = 0.5\n</pre> layer.get_radius = normalized_download_speed * 200 layer.radius_units = \"meters\" layer.radius_min_pixels = 0.5 <p>After running the above cell, you should see the map updated to have a different radius per point!</p>"},{"location":"examples/internet-speeds/#speedtest-data","title":"Speedtest Data\u00b6","text":"<p>This example will use data collected from Ookla's Speed Test application and shared publicly in the AWS Open Data Registry. From the AWS page:</p> <p>Global fixed broadband and mobile (cellular) network performance, allocated to zoom level 16 web mercator tiles (approximately 610.8 meters by 610.8 meters at the equator). Data is provided in both Shapefile format as well as Apache Parquet with geometries represented in Well Known Text (WKT) projected in EPSG:4326. Download speed, upload speed, and latency are collected via the Speedtest by Ookla applications for Android and iOS and averaged for each tile.</p> <p>You can view a hosted version of this notebook on Notebook Sharing Space (35MB download).</p>"},{"location":"examples/internet-speeds/#dependencies","title":"Dependencies\u00b6","text":"<pre><code>pip install lonboard \"geopandas&gt;=1\" palettable sidecar\n</code></pre>"},{"location":"examples/internet-speeds/#imports","title":"Imports\u00b6","text":""},{"location":"examples/internet-speeds/#fetch-data","title":"Fetch data\u00b6","text":""},{"location":"examples/linked-maps/","title":"Linked maps","text":"In\u00a0[\u00a0]: Copied! <pre>from functools import partial\nfrom typing import List\n\nimport ipywidgets as widgets\nimport traitlets\n\nimport lonboard\nfrom lonboard import Map\nfrom lonboard.basemap import CartoBasemap\nfrom lonboard.models import ViewState\n</pre> from functools import partial from typing import List  import ipywidgets as widgets import traitlets  import lonboard from lonboard import Map from lonboard.basemap import CartoBasemap from lonboard.models import ViewState In\u00a0[\u00a0]: Copied! <pre>## Create postitron map focused on the arch\npositron_map = Map(\n    layers=[],\n    basemap_style=CartoBasemap.Positron,\n    view_state={\n        \"longitude\": -90.1849,\n        \"latitude\": 38.6245,\n        \"zoom\": 16,\n        \"pitch\": 0,\n        \"bearing\": 0,\n    },\n    layout=widgets.Layout(flex=\"1\"),\n)\n\n## Create postitron map focused on the lady liberty\ndarkmatter_map = Map(\n    layers=[],\n    basemap_style=CartoBasemap.DarkMatter,\n    view_state={\n        \"longitude\": -74.04454,\n        \"latitude\": 40.6892,\n        \"zoom\": 16,\n        \"pitch\": 0,\n        \"bearing\": 0,\n    },\n    layout=widgets.Layout(flex=\"1\"),\n)\n\nmaps_box = widgets.HBox([positron_map, darkmatter_map])\nmaps_box\n</pre> ## Create postitron map focused on the arch positron_map = Map(     layers=[],     basemap_style=CartoBasemap.Positron,     view_state={         \"longitude\": -90.1849,         \"latitude\": 38.6245,         \"zoom\": 16,         \"pitch\": 0,         \"bearing\": 0,     },     layout=widgets.Layout(flex=\"1\"), )  ## Create postitron map focused on the lady liberty darkmatter_map = Map(     layers=[],     basemap_style=CartoBasemap.DarkMatter,     view_state={         \"longitude\": -74.04454,         \"latitude\": 40.6892,         \"zoom\": 16,         \"pitch\": 0,         \"bearing\": 0,     },     layout=widgets.Layout(flex=\"1\"), )  maps_box = widgets.HBox([positron_map, darkmatter_map]) maps_box In\u00a0[\u00a0]: Copied! <pre>def sync_positron_to_darkmatter(event: traitlets.utils.bunch.Bunch) -&gt; None:\n    if isinstance(event.get(\"new\"), ViewState):\n        darkmatter_map.view_state = positron_map.view_state\n\n\npositron_map.observe(sync_positron_to_darkmatter)\n\n\ndef sync_darkmatter_to_positron(event: traitlets.utils.bunch.Bunch) -&gt; None:\n    if isinstance(event.get(\"new\"), ViewState):\n        positron_map.view_state = darkmatter_map.view_state\n\n\ndarkmatter_map.observe(sync_darkmatter_to_positron)\n</pre> def sync_positron_to_darkmatter(event: traitlets.utils.bunch.Bunch) -&gt; None:     if isinstance(event.get(\"new\"), ViewState):         darkmatter_map.view_state = positron_map.view_state   positron_map.observe(sync_positron_to_darkmatter)   def sync_darkmatter_to_positron(event: traitlets.utils.bunch.Bunch) -&gt; None:     if isinstance(event.get(\"new\"), ViewState):         positron_map.view_state = darkmatter_map.view_state   darkmatter_map.observe(sync_darkmatter_to_positron) In\u00a0[\u00a0]: Copied! <pre>def link_maps(event: traitlets.utils.bunch.Bunch, other_maps: List[Map] = []):\n    if isinstance(event.get(\"new\"), ViewState):\n        for lonboard_map in other_maps:\n            lonboard_map.view_state = event[\"new\"]\n\n\npositron_map.observe(partial(link_maps, other_maps=[darkmatter_map]))\ndarkmatter_map.observe(partial(link_maps, other_maps=[positron_map]))\n</pre> def link_maps(event: traitlets.utils.bunch.Bunch, other_maps: List[Map] = []):     if isinstance(event.get(\"new\"), ViewState):         for lonboard_map in other_maps:             lonboard_map.view_state = event[\"new\"]   positron_map.observe(partial(link_maps, other_maps=[darkmatter_map])) darkmatter_map.observe(partial(link_maps, other_maps=[positron_map])) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/linked-maps/#linked-maps","title":"Linked Maps\u00b6","text":"<p>This notebook demonstrates how you can link two different Lonboard maps using the <code>ipywidgets.observe</code> method, so panning/zooming one map will automatically pan/zoom the other map.</p> <p>Linked maps can be useful in a variety of situations:</p> <ul> <li>Before/After maps, where one map shows data before something happened and the other after the event</li> <li>To showcase results of different processing methodologies</li> <li>To simply present multiple maps with different data that doesn't easily fit on one map</li> </ul>"},{"location":"examples/linked-maps/#create-the-maps","title":"Create the maps\u00b6","text":"<p>Because layers don't matter for this example, we are going to create two maps without any layers, one map using the Positron basemap, and another using the Dark Matter basemap.</p> <p>To start, the view state on the Positron map to be focused on the Gateway Arch in St. Louis Missouri, and the Dark Matter map will be centered on the Statue of Liberty in New York City, New York.</p> <p>We'll present the two maps side by side in an ipywidgets HBox to keep them tidy. Setting the layout of the maps to \"flex='1'\" will allow the maps to display inside the HBox.</p>"},{"location":"examples/linked-maps/#linking-the-maps-the-easy-way-to-understand","title":"Linking the Maps (the easy way to understand)\u00b6","text":"<p>If you haven't yet run the cells below, you'll see that you can pan/zoom the two maps independent of one another. \u00a0Panning/zooming one map will not affect the other map. \u00a0After we run the code below though, the two maps will synchronize with each other, when we pan/zoom one map, the other map will automatically match the map that was modified.</p> <p>To achieve the view state synchronization, we'll write two simple callback function for each of the maps. The functions will receive events from the interaction with the maps, and if the interaction with the map changed the view_state, we'll set the view_state on the other map to match the view_state of the the map that we interacted with.</p>"},{"location":"examples/linked-maps/#linking-the-maps-the-more-elegantrobust-way","title":"Linking the Maps (the more elegant/robust way)\u00b6","text":"<p>In the block above we are typing a lot of code, and the two functions are basically the same, just with hard coded maps to target in the functions, and we're explicitly calling the originating map's <code>view_state</code> even though the <code>event[\"new\"]</code> actually is the view state. \u00a0Additionally if we had a lot of maps to sync, this would get out of hand quickly.\u00a0None of that is idea, but it makes the concept easy to understand.\u00a0Below is a better way to sync the maps, albeit a bit more abstract.</p> <p>Luckily <code>functools.partial</code> can help us out.\u00a0Instead of writing a function per map, we can write one function that take the same events from the widget, but also another parameter which is a list of Lonboard maps.\u00a0Then when we register the callback function with the map's <code>observe()</code> method, we pass partial as the function and tell partial to use the <code>link_maps</code> function and provide the list of the other maps to sync with this map.\u00a0This way we have one function that we wrote which can be used to sync any map with any number of other maps.</p>"},{"location":"examples/migration/","title":"U.S. County-to-County Migration","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport pyarrow as pa\nimport requests\nimport shapely\nfrom matplotlib.colors import Normalize\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.experimental import ArcLayer\nfrom lonboard.layer_extension import BrushingExtension\n</pre> import geopandas as gpd import numpy as np import pandas as pd import pyarrow as pa import requests import shapely from matplotlib.colors import Normalize  from lonboard import Map, ScatterplotLayer from lonboard.experimental import ArcLayer from lonboard.layer_extension import BrushingExtension <p>Fetch the data from the version in the <code>deck.gl-data</code> repository.</p> In\u00a0[2]: Copied! <pre>url = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/arc/counties.json\"\nr = requests.get(url)\nsource_data = r.json()\n</pre> url = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/arc/counties.json\" r = requests.get(url) source_data = r.json() <p>The following cell may be a little hard to follow, but what it's doing is taking the raw data, which represents a graph of the data and normalizing it to a table structure where each row represents one \"arc\" between a source and target county.</p> <p>This is ported from the original JavaScript here.</p> In\u00a0[3]: Copied! <pre>arcs = []\ntargets = []\nsources = []\npairs = {}\n\nfeatures = source_data[\"features\"]\nfor i, county in enumerate(features):\n    flows = county[\"properties\"][\"flows\"]\n    target_centroid = county[\"properties\"][\"centroid\"]\n    total_value = {\n        \"gain\": 0,\n        \"loss\": 0,\n    }\n\n    for to_id, value in flows.items():\n        if value &gt; 0:\n            total_value[\"gain\"] += value\n        else:\n            total_value[\"loss\"] += value\n\n        # If number is too small, ignore it\n        if abs(value) &lt; 50:\n            continue\n\n        pair_key = \"-\".join(map(str, sorted([i, int(to_id)])))\n        source_centroid = features[int(to_id)][\"properties\"][\"centroid\"]\n        gain = np.sign(flows[to_id])\n\n        # add point at arc source\n        sources.append(\n            {\n                \"position\": source_centroid,\n                \"target\": target_centroid,\n                \"name\": features[int(to_id)][\"properties\"][\"name\"],\n                \"radius\": 3,\n                \"gain\": -gain,\n            }\n        )\n        # eliminate duplicate arcs\n        if pair_key in pairs.keys():\n            continue\n\n        pairs[pair_key] = True\n\n        if gain &gt; 0:\n            arcs.append(\n                {\n                    \"target\": target_centroid,\n                    \"source\": source_centroid,\n                    \"value\": flows[to_id],\n                }\n            )\n        else:\n            arcs.append(\n                {\n                    \"target\": source_centroid,\n                    \"source\": target_centroid,\n                    \"value\": flows[to_id],\n                }\n            )\n\n    # add point at arc target\n    targets.append(\n        {\n            **total_value,\n            \"position\": [target_centroid[0], target_centroid[1], 10],\n            \"net\": total_value[\"gain\"] + total_value[\"loss\"],\n            \"name\": county[\"properties\"][\"name\"],\n        }\n    )\n\n# sort targets by radius large -&gt; small\ntargets = sorted(targets, key=lambda d: abs(d[\"net\"]), reverse=True)\nnormalizer = Normalize(0, abs(targets[0][\"net\"]))\n</pre> arcs = [] targets = [] sources = [] pairs = {}  features = source_data[\"features\"] for i, county in enumerate(features):     flows = county[\"properties\"][\"flows\"]     target_centroid = county[\"properties\"][\"centroid\"]     total_value = {         \"gain\": 0,         \"loss\": 0,     }      for to_id, value in flows.items():         if value &gt; 0:             total_value[\"gain\"] += value         else:             total_value[\"loss\"] += value          # If number is too small, ignore it         if abs(value) &lt; 50:             continue          pair_key = \"-\".join(map(str, sorted([i, int(to_id)])))         source_centroid = features[int(to_id)][\"properties\"][\"centroid\"]         gain = np.sign(flows[to_id])          # add point at arc source         sources.append(             {                 \"position\": source_centroid,                 \"target\": target_centroid,                 \"name\": features[int(to_id)][\"properties\"][\"name\"],                 \"radius\": 3,                 \"gain\": -gain,             }         )         # eliminate duplicate arcs         if pair_key in pairs.keys():             continue          pairs[pair_key] = True          if gain &gt; 0:             arcs.append(                 {                     \"target\": target_centroid,                     \"source\": source_centroid,                     \"value\": flows[to_id],                 }             )         else:             arcs.append(                 {                     \"target\": source_centroid,                     \"source\": target_centroid,                     \"value\": flows[to_id],                 }             )      # add point at arc target     targets.append(         {             **total_value,             \"position\": [target_centroid[0], target_centroid[1], 10],             \"net\": total_value[\"gain\"] + total_value[\"loss\"],             \"name\": county[\"properties\"][\"name\"],         }     )  # sort targets by radius large -&gt; small targets = sorted(targets, key=lambda d: abs(d[\"net\"]), reverse=True) normalizer = Normalize(0, abs(targets[0][\"net\"])) <p>We define some color constants, as well as a color lookup array.</p> <p>A nice trick in numpy is that if you have a two-dimensional array like:</p> <pre>[\n  [166, 3, 3],\n  [35, 181, 184]\n]\n</pre> <p>you can perform a lookup based on the index to transform data from one dimensionality to another. In this case, we'll use <code>0</code> and <code>1</code> \u2014 the two available indexes of the array's first dimension \u2014 to create an array of colors.</p> <p>So when we call <code>COLORS[colors_lookup]</code> that creates an output array of something like:</p> <pre>[\n  [166, 3, 3],\n  [35, 181, 184],\n  [166, 3, 3],\n  [166, 3, 3]\n]\n</pre> <p>equal to the number of rows in our dataset. We can then pass this to any parameter that accepts a ColorAccessor.</p> In\u00a0[4]: Copied! <pre># migrate out\nSOURCE_COLOR = [166, 3, 3]\n# migrate in\nTARGET_COLOR = [35, 181, 184]\n# Combine into a single arr to use as a lookup table\nCOLORS = np.vstack(\n    [np.array(SOURCE_COLOR, dtype=np.uint8), np.array(TARGET_COLOR, dtype=np.uint8)]\n)\nSOURCE_LOOKUP = 0\nTARGET_LOOKUP = 1\n</pre> # migrate out SOURCE_COLOR = [166, 3, 3] # migrate in TARGET_COLOR = [35, 181, 184] # Combine into a single arr to use as a lookup table COLORS = np.vstack(     [np.array(SOURCE_COLOR, dtype=np.uint8), np.array(TARGET_COLOR, dtype=np.uint8)] ) SOURCE_LOOKUP = 0 TARGET_LOOKUP = 1 In\u00a0[5]: Copied! <pre>brushing_extension = BrushingExtension()\nbrushing_radius = 200000\n</pre> brushing_extension = BrushingExtension() brushing_radius = 200000 <p>Convert the <code>sources</code> list of dictionaries into a GeoPandas <code>GeoDataFrame</code> to pass into a <code>ScatterplotLayer</code>.</p> In\u00a0[6]: Copied! <pre>source_arr = np.array([source[\"position\"] for source in sources])\nsource_positions = shapely.points(source_arr[:, 0], source_arr[:, 1])\nsource_gdf = gpd.GeoDataFrame(\n    pd.DataFrame.from_records(sources)[[\"name\", \"radius\", \"gain\"]],\n    geometry=source_positions,\n    crs=\"EPSG:4326\",\n)\n# We use a lookup table (`COLORS`) to apply either the target color or the source color\n# to the array\nsource_colors_lookup = np.where(source_gdf[\"gain\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP)\nsource_fill_colors = COLORS[source_colors_lookup]\n</pre> source_arr = np.array([source[\"position\"] for source in sources]) source_positions = shapely.points(source_arr[:, 0], source_arr[:, 1]) source_gdf = gpd.GeoDataFrame(     pd.DataFrame.from_records(sources)[[\"name\", \"radius\", \"gain\"]],     geometry=source_positions,     crs=\"EPSG:4326\", ) # We use a lookup table (`COLORS`) to apply either the target color or the source color # to the array source_colors_lookup = np.where(source_gdf[\"gain\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP) source_fill_colors = COLORS[source_colors_lookup] <p>Create a <code>ScatterplotLayer</code> for source points:</p> In\u00a0[7]: Copied! <pre>source_layer = ScatterplotLayer.from_geopandas(\n    source_gdf,\n    get_fill_color=source_fill_colors,\n    radius_scale=3000,\n    pickable=False,\n    extensions=[brushing_extension],\n    brushing_radius=brushing_radius,\n)\n</pre> source_layer = ScatterplotLayer.from_geopandas(     source_gdf,     get_fill_color=source_fill_colors,     radius_scale=3000,     pickable=False,     extensions=[brushing_extension],     brushing_radius=brushing_radius, ) In\u00a0[8]: Copied! <pre>targets_arr = np.array([target[\"position\"] for target in targets])\ntarget_positions = shapely.points(targets_arr[:, 0], targets_arr[:, 1])\ntarget_gdf = gpd.GeoDataFrame(\n    pd.DataFrame.from_records(targets)[[\"name\", \"gain\", \"loss\", \"net\"]],\n    geometry=target_positions,\n    crs=\"EPSG:4326\",\n)\n# We use a lookup table (`COLORS`) to apply either the target color or the source color\n# to the array\ntarget_line_colors_lookup = np.where(\n    target_gdf[\"net\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP\n)\ntarget_line_colors = COLORS[target_line_colors_lookup]\n</pre> targets_arr = np.array([target[\"position\"] for target in targets]) target_positions = shapely.points(targets_arr[:, 0], targets_arr[:, 1]) target_gdf = gpd.GeoDataFrame(     pd.DataFrame.from_records(targets)[[\"name\", \"gain\", \"loss\", \"net\"]],     geometry=target_positions,     crs=\"EPSG:4326\", ) # We use a lookup table (`COLORS`) to apply either the target color or the source color # to the array target_line_colors_lookup = np.where(     target_gdf[\"net\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP ) target_line_colors = COLORS[target_line_colors_lookup] <p>Create a <code>ScatterplotLayer</code> for target points:</p> In\u00a0[9]: Copied! <pre>target_ring_layer = ScatterplotLayer.from_geopandas(\n    target_gdf,\n    get_line_color=target_line_colors,\n    radius_scale=4000,\n    pickable=True,\n    stroked=True,\n    filled=False,\n    line_width_min_pixels=2,\n    extensions=[brushing_extension],\n    brushing_radius=brushing_radius,\n)\n</pre> target_ring_layer = ScatterplotLayer.from_geopandas(     target_gdf,     get_line_color=target_line_colors,     radius_scale=4000,     pickable=True,     stroked=True,     filled=False,     line_width_min_pixels=2,     extensions=[brushing_extension],     brushing_radius=brushing_radius, ) <p>Note: the <code>ArcLayer</code> can't currently be created from a GeoDataFrame because it needs two point columns, not one. This is a large part of why it's still marked under the \"experimental\" module.</p> <p>Here we pass a numpy array for each point column. This is allowed as long as the shape of the array is <code>(N, 2)</code> or <code>(N, 3)</code> (i.e. 2D or 3D coordinates).</p> In\u00a0[10]: Copied! <pre>value = np.array([arc[\"value\"] for arc in arcs])\nget_source_position = np.array([arc[\"source\"] for arc in arcs])\nget_target_position = np.array([arc[\"target\"] for arc in arcs])\ntable = pa.table({\"value\": value})\n\narc_layer = ArcLayer(\n    table=table,\n    get_source_position=get_source_position,\n    get_target_position=get_target_position,\n    get_source_color=SOURCE_COLOR,\n    get_target_color=TARGET_COLOR,\n    get_width=1,\n    opacity=0.4,\n    pickable=False,\n    extensions=[brushing_extension],\n    brushing_radius=brushing_radius,\n)\n</pre> value = np.array([arc[\"value\"] for arc in arcs]) get_source_position = np.array([arc[\"source\"] for arc in arcs]) get_target_position = np.array([arc[\"target\"] for arc in arcs]) table = pa.table({\"value\": value})  arc_layer = ArcLayer(     table=table,     get_source_position=get_source_position,     get_target_position=get_target_position,     get_source_color=SOURCE_COLOR,     get_target_color=TARGET_COLOR,     get_width=1,     opacity=0.4,     pickable=False,     extensions=[brushing_extension],     brushing_radius=brushing_radius, ) <p>Now we can create a map using these three layers we've created.</p> <p>As you hover over the map, it should render only the arcs near your cursor.</p> <p>You can modify <code>brushing_extension.brushing_radius</code> to control how large the brush is around your cursor.</p> In\u00a0[11]: Copied! <pre>map_ = Map([source_layer, target_ring_layer, arc_layer], picking_radius=10)\nmap_\n</pre> map_ = Map([source_layer, target_ring_layer, arc_layer], picking_radius=10) map_ Out[11]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/migration/#us-county-to-county-migration","title":"U.S. County-to-County Migration\u00b6","text":"<p>This notebook is derived from the original deck.gl example in JavaScript, which you can see here.</p> <p>This dataset originally came from the U.S. Census Bureau and represents people moving in and out of each county between 2009-2013.</p> <p>You can view a hosted version of this notebook on Notebook Sharing Space (6MB download).</p>"},{"location":"examples/migration/#imports","title":"Imports\u00b6","text":""},{"location":"examples/north-america-roads/","title":"North America Roads","text":"In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\nimport palettable.colorbrewer.diverging\n\nfrom lonboard import Map, PathLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd import palettable.colorbrewer.diverging  from lonboard import Map, PathLayer from lonboard.colormap import apply_continuous_cmap <p>The \"public\" URL for this dataset from the Natural Earth website is</p> <pre><code>https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_roads_north_america.zip\n</code></pre> <p>That doesn't appear to work directly inside a notebook, so we'll use the URL the above redirects to:</p> <pre><code>https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip\n</code></pre> <p>It's possible this \"private\" URL will change in the future.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip\"\n</pre> url = \"https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip\" <p>We'll use GeoPandas to fetch this data (45MB) over the internet and load it into a <code>GeoDataFrame</code>. This uses the <code>pyogrio</code> engine, which is faster. Ensure you have <code>pyogrio</code> installed.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(url, engine=\"pyogrio\")\n</pre> gdf = gpd.read_file(url, engine=\"pyogrio\") <p>This dataframe has a variety of attributes, plus a geometry column with a <code>LineString</code> type.</p> In\u00a0[\u00a0]: Copied! <pre>gdf.head()\n</pre> gdf.head() <p>To ensure that this demo is snappy on most computers, we'll filter to only the contiguous U.S. If you're on a recent computer, feel free to comment out this line.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gdf[gdf[\"state\"] == \"California\"]\n</pre> gdf = gdf[gdf[\"state\"] == \"California\"] <p>To render <code>LineString</code> data, first create a <code>PathLayer</code> and then add it to a <code>Map</code> object.</p> In\u00a0[\u00a0]: Copied! <pre>layer = PathLayer.from_geopandas(gdf, width_min_pixels=0.8)\nmap_ = Map(layer)\nmap_\n</pre> layer = PathLayer.from_geopandas(gdf, width_min_pixels=0.8) map_ = Map(layer) map_ <p>We can look at the documentation for <code>PathLayer</code> to see what other rendering options it allows. Let's set the path color to something other than black:</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_color = [200, 0, 200]\n</pre> layer.get_color = [200, 0, 200] <p>Ok, so we can see the data! That's great! But let's customize the rendering based on an attribute!</p> <p>The <code>scalerank</code> column tells how important the road is in the road network. Let's see what the distribution of values is for this column:</p> In\u00a0[\u00a0]: Copied! <pre>gdf[\"scalerank\"].value_counts().sort_index()\n</pre> gdf[\"scalerank\"].value_counts().sort_index() <p>Ok, so the values range from <code>3</code> to <code>12</code>. To assign a colormap to this column, we need \"normalized\" values that span between 0 and 1:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_scale_rank = (gdf[\"scalerank\"] - 3) / 9\n</pre> normalized_scale_rank = (gdf[\"scalerank\"] - 3) / 9 <p>The values of this array now range from 0 to 1:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_scale_rank.min(), normalized_scale_rank.max()\n</pre> normalized_scale_rank.min(), normalized_scale_rank.max() <p>Let's select a colormap to apply to this data:</p> In\u00a0[\u00a0]: Copied! <pre>cmap = palettable.colorbrewer.diverging.PuOr_10\n</pre> cmap = palettable.colorbrewer.diverging.PuOr_10 In\u00a0[\u00a0]: Copied! <pre>cmap.mpl_colormap\n</pre> cmap.mpl_colormap <p>Now we'll use <code>apply_continuous_cmap</code> onto this array to generate colors for our data. Just set this new array onto the existing layer, and you'll see the map update with the new colors!</p> In\u00a0[\u00a0]: Copied! <pre>layer.get_color = apply_continuous_cmap(\n    normalized_scale_rank, palettable.colorbrewer.diverging.PuOr_10, alpha=0.8\n)\n</pre> layer.get_color = apply_continuous_cmap(     normalized_scale_rank, palettable.colorbrewer.diverging.PuOr_10, alpha=0.8 ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/north-america-roads/#north-america-roads","title":"North America Roads\u00b6","text":"<p>This example uses data from Natural Earth to plot the road network in North America. Refer to the data documentation for more information about this dataset.</p> <p>You can view a hosted version of this notebook on Notebook Sharing Space (6MB download).</p>"},{"location":"examples/north-america-roads/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li>lonboard</li> <li>pyogrio</li> </ul>"},{"location":"examples/north-america-roads/#imports","title":"Imports\u00b6","text":""},{"location":"examples/overture-maps/","title":"Overture Maps Buildings","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport overturemaps\nfrom matplotlib.colors import LogNorm\nfrom palettable.colorbrewer.sequential import Oranges_9\n\nfrom lonboard import Map, PolygonLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import numpy as np import overturemaps from matplotlib.colors import LogNorm from palettable.colorbrewer.sequential import Oranges_9  from lonboard import Map, PolygonLayer from lonboard.colormap import apply_continuous_cmap <p>Using this bounding box tool we can find a bounding box covering Manhattan. Choose \"CSV\" in the drop down box, then paste the result in the following cell:</p> In\u00a0[\u00a0]: Copied! <pre>bbox = -74.02169, 40.696423, -73.891338, 40.831263\n</pre> bbox = -74.02169, 40.696423, -73.891338, 40.831263 <p>Ensure you pass the bbox into <code>overturemaps.record_batch_reader</code> as in the next line.</p> <p><code>record_batch_reader</code> returns a RecordBatchReader, an iterator of Arrow RecordBatches. We call <code>.read_all()</code> to materialize all batches into memory. This cell fetches the relevant data from the cloud (AWS S3), so it may take a minute to download.</p> In\u00a0[\u00a0]: Copied! <pre>table = overturemaps.record_batch_reader(\"building\", bbox).read_all()\n</pre> table = overturemaps.record_batch_reader(\"building\", bbox).read_all() <p>Let's color the buildings by their heights. First, convert the \"height\" column to a numpy array, then replace any null values with <code>1</code>.</p> In\u00a0[\u00a0]: Copied! <pre>heights = table[\"height\"].to_numpy()\nheights = np.nan_to_num(heights, nan=1)\n</pre> heights = table[\"height\"].to_numpy() heights = np.nan_to_num(heights, nan=1) <p>Building heights tend to scale non-linearly. That is, the vast majority of buildings are relatively low, but a few buildings are very tall. So that the low buildings aren't completely washed out, we'll use matplotlib's <code>LogNorm</code> to normalize these values according to a log scale.</p> In\u00a0[\u00a0]: Copied! <pre>normalizer = LogNorm(1, heights.max(), clip=True)\nnormalized_heights = normalizer(heights)\n</pre> normalizer = LogNorm(1, heights.max(), clip=True) normalized_heights = normalizer(heights) <p>Then we can apply a colormap to these heights. For this case, we'll use the <code>Oranges_9</code> colormap.</p> In\u00a0[\u00a0]: Copied! <pre>Oranges_9.mpl_colormap\n</pre> Oranges_9.mpl_colormap <p>Using <code>apply_continuous_cmap</code>, we can apply our values onto this colormap.</p> In\u00a0[\u00a0]: Copied! <pre>colors = apply_continuous_cmap(normalized_heights, Oranges_9)\n</pre> colors = apply_continuous_cmap(normalized_heights, Oranges_9) <p>We create a <code>PolygonLayer</code> with our data, passing in the heights and colors from before.</p> In\u00a0[\u00a0]: Copied! <pre>layer = PolygonLayer(\n    # Select only a few attribute columns from the table\n    table=table.select([\"id\", \"height\", \"geometry\", \"names\"]),\n    extruded=True,\n    get_elevation=heights,\n    get_fill_color=colors,\n)\n</pre> layer = PolygonLayer(     # Select only a few attribute columns from the table     table=table.select([\"id\", \"height\", \"geometry\", \"names\"]),     extruded=True,     get_elevation=heights,     get_fill_color=colors, ) <p>We manually set the view state here for the original NYC data so that the map will start pitched. Remove or change this <code>view_state</code> call if you change the input dataset.</p> In\u00a0[\u00a0]: Copied! <pre>view_state = {\n    \"longitude\": -73.98416810282863,\n    \"latitude\": 40.72651721370669,\n    \"zoom\": 12.726630492730596,\n    \"pitch\": 59.80465353190481,\n    \"bearing\": 13.243243243243244,\n}\nm = Map(layer, view_state=view_state)\nm\n</pre> view_state = {     \"longitude\": -73.98416810282863,     \"latitude\": 40.72651721370669,     \"zoom\": 12.726630492730596,     \"pitch\": 59.80465353190481,     \"bearing\": 13.243243243243244, } m = Map(layer, view_state=view_state) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/overture-maps/#overture-maps-buildings","title":"Overture Maps Buildings\u00b6","text":"<p>This notebook will give a quick overview of using the new Overture Maps Python library with Lonboard.</p> <p>We'll pass in a bounding box covering New York City and the Overture Python API will fetch only the data inside that bounding box. While Overture's buildings dataset contains 2.3 billion rows, by using a relatively small bounding box, we can download data for our query relatively quickly (around 30 seconds on my internet connection).</p> <p>This uses the latest advancements of the GeoParquet specification. Data is fetched directly from the cloud with no server in the middle!</p> <p>You can view a hosted version of this notebook on Notebook Sharing Space (26MB download).</p>"},{"location":"examples/overture-maps/#dependencies","title":"Dependencies\u00b6","text":"<p>This notebook requires Lonboard (tested with version 0.8) and <code>overturemaps</code> (tested with version 0.4). To install <code>overturemaps</code>, run:</p> <pre><code>pip install overturemaps\n</code></pre>"},{"location":"examples/overture-maps/#imports","title":"Imports\u00b6","text":""},{"location":"examples/integrations/color-picker/","title":"ColorPicker","text":"<p>Example gif:</p> <p></p> In\u00a0[1]: Copied! <pre>import geodatasets\nimport geopandas as gpd\nimport ipywidgets\n\nfrom lonboard import Map, SolidPolygonLayer\n</pre> import geodatasets import geopandas as gpd import ipywidgets  from lonboard import Map, SolidPolygonLayer <p><code>geodatasets.get_path</code> will download the dataset if it hasn't been downloaded and cached before.</p> In\u00a0[2]: Copied! <pre>gdf = gpd.read_file(geodatasets.get_path(\"nybb\"))\n</pre> gdf = gpd.read_file(geodatasets.get_path(\"nybb\")) <p>Create our basic map:</p> In\u00a0[3]: Copied! <pre>layer = SolidPolygonLayer.from_geopandas(gdf)\nmap_ = Map(layers=[layer])\nmap_\n</pre> layer = SolidPolygonLayer.from_geopandas(gdf) map_ = Map(layers=[layer]) map_ <pre>/Users/kyle/github/developmentseed/lonboard/lonboard/_layer.py:99: UserWarning: GeoDataFrame being reprojected to EPSG:4326\n  warnings.warn(\"GeoDataFrame being reprojected to EPSG:4326\")\n</pre> Out[3]: <pre>Map(layers=[SolidPolygonLayer(table=pyarrow.Table\nBoroCode: int64\nBoroName: string\nShape_Leng: double\nShape_Ar\u2026</pre> <p>Create the <code>ColorPicker</code> widget:</p> In\u00a0[4]: Copied! <pre>color_picker = ipywidgets.ColorPicker()\ncolor_picker\n</pre> color_picker = ipywidgets.ColorPicker() color_picker Out[4]: <pre>ColorPicker(value='black')</pre> <p>Note that the \"data\" contained by the <code>color_picker</code> instance is held by the <code>value</code> attribute:</p> In\u00a0[5]: Copied! <pre>color_picker.value\n</pre> color_picker.value Out[5]: <pre>'black'</pre> <p>We'll now link the two widgets together, so that whenever the color picker is updated, <code>ipywidgets</code> will update the value of <code>get_fill_color</code> on the layer.</p> <p>The format of <code>dlink</code> is:</p> <ul> <li>tuple: (source widget, attribute of source widget)</li> <li>tuple: (target widget, attribute of target widget)</li> </ul> <p>So we use the below syntax to link <code>color_picker.value</code> to <code>layer.get_fill_color</code>.</p> <p>We need to use <code>dlink</code>, not <code>link</code>, which creates a one-directional link (from the color picker to the layer) and not a bi-directional link. This is because the color picker and the layer have a different color representation under the hood (<code>ColorPicker</code> stores a hex string; the <code>SolidPolygonLayer</code> works in terms of RGBA color integers).</p> In\u00a0[6]: Copied! <pre>ipywidgets.dlink(\n    (color_picker, 'value'),\n    (layer, 'get_fill_color')\n)\n</pre> ipywidgets.dlink(     (color_picker, 'value'),     (layer, 'get_fill_color') ) Out[6]: <pre>&lt;traitlets.traitlets.directional_link at 0x168822610&gt;</pre> <p>Now click on the color widget and change the color! You need to press Enter to select a specific color.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/integrations/color-picker/#colorpicker","title":"ColorPicker\u00b6","text":"<p>Use lonboard with an ipywidgets ColorPicker object.</p>"},{"location":"examples/integrations/color-picker/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li><p>lonboard</p> </li> <li><p>geodatasets</p> <p>Run <code>pip install geodatasets</code> if needed.</p> </li> </ul>"},{"location":"examples/integrations/color-picker/#imports","title":"Imports\u00b6","text":""},{"location":"examples/integrations/sidecar/","title":"Sidecar","text":"<p>The goal of this notebook is to show how using Jupyter Sidecar can help to interactively explore and understand your data.</p> <p>Note that sidecar only works in JupyterLab and will not work in other notebook frontends like Colab.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\nimport ipywidgets\nimport matplotlib as mpl\nimport pandas as pd\nfrom palettable.colorbrewer.diverging import BrBG_10\nfrom sidecar import Sidecar\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd import ipywidgets import matplotlib as mpl import pandas as pd from palettable.colorbrewer.diverging import BrBG_10 from sidecar import Sidecar  from lonboard import Map, ScatterplotLayer from lonboard.colormap import apply_continuous_cmap <p>For this example, we'll use a dataset of abandoned cars in Chicago. Since this is a CSV file, we need to pass in the names of the X and Y columns into the \"open options\" to pass to OGR.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://geodacenter.github.io/data-and-lab/data/Abandoned_Vehicles_Map.csv\"\ngdf = gpd.read_file(\n    url,\n    engine=\"pyogrio\",\n    use_arrow=True,\n    X_POSSIBLE_NAMES=\"Longitude\",\n    Y_POSSIBLE_NAMES=\"Latitude\",\n    KEEP_GEOM_COLUMNS=\"NO\",\n)\ngdf = gdf.set_crs(\"EPSG:4326\")\n</pre> url = \"https://geodacenter.github.io/data-and-lab/data/Abandoned_Vehicles_Map.csv\" gdf = gpd.read_file(     url,     engine=\"pyogrio\",     use_arrow=True,     X_POSSIBLE_NAMES=\"Longitude\",     Y_POSSIBLE_NAMES=\"Latitude\",     KEEP_GEOM_COLUMNS=\"NO\", ) gdf = gdf.set_crs(\"EPSG:4326\") <p>This dataset has some null values for geometries. We'll remove these first:</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gdf[gdf.geometry != None]\n</pre> gdf = gdf[gdf.geometry != None] <p>Let's also remove empty values from another column to make later steps easier (when modifying a single map object with lonboard, you can't change the number of rows).</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gdf[gdf[\"How Many Days Has the Vehicle Been Reported as Parked?\"] != \"\"]\n</pre> gdf = gdf[gdf[\"How Many Days Has the Vehicle Been Reported as Parked?\"] != \"\"] <p>We'll now initialize the <code>Sidecar</code> object, which splits the JupyterLab screen in half, creating the output area for our widget.</p> In\u00a0[\u00a0]: Copied! <pre>sc = Sidecar(title='My Map')\n</pre> sc = Sidecar(title='My Map') <p>Now let's create a map layer from our <code>GeoDataFrame</code>.</p> <p>The default map height is 500 pixels, but we'd like to have a taller map because it's vertical. This API may change in the future.</p> In\u00a0[\u00a0]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nmap_ = Map(layers=[layer])\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) map_ = Map(layers=[layer]) <p>Now we can render this inside the sidecar. You should see the map appear on the right side of your screen.</p> In\u00a0[\u00a0]: Copied! <pre>with sc:\n    display(map_)\n</pre> with sc:     display(map_) <p>It's great that we can see the map, but let's customize the rendering a bit. There's a column in the data titled</p> <p>How Many Days Has the Vehicle Been Reported as Parked?</p> <p>Let's use this column to visualize how long it takes to remove a car in different areas of the city.</p> <p>This is a string column, so first let's convert it to a numeric value.</p> In\u00a0[\u00a0]: Copied! <pre>colname = \"How Many Days Has the Vehicle Been Reported as Parked?\"\ngdf[colname] = pd.to_numeric(gdf[colname])\n</pre> colname = \"How Many Days Has the Vehicle Been Reported as Parked?\" gdf[colname] = pd.to_numeric(gdf[colname]) <p>In order to apply a colormap onto our data, we need to normalize our values to the range of <code>0-1</code>. Matplotlib offers several normalization options. See the tutorial and the <code>matplotlib.colors</code> module.</p> <p>To start, we'll do a simple linear normalization, converting from 0-90 to 0-1. Any values below 0 will be clamped to 0, and any values above 90 will be clamped to 1.</p> In\u00a0[\u00a0]: Copied! <pre>normalizer = mpl.colors.Normalize(0, 90)\nnormalized_values = normalizer(gdf[colname])\n</pre> normalizer = mpl.colors.Normalize(0, 90) normalized_values = normalizer(gdf[colname]) <p>These values now range between 0 and 1:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_values\n</pre> normalized_values In\u00a0[\u00a0]: Copied! <pre>BrBG_10.mpl_colormap\n</pre> BrBG_10.mpl_colormap In\u00a0[\u00a0]: Copied! <pre>layer.radius_min_pixels = 0.5\nlayer.get_fill_color = apply_continuous_cmap(normalized_values, BrBG_10)\n</pre> layer.radius_min_pixels = 0.5 layer.get_fill_color = apply_continuous_cmap(normalized_values, BrBG_10) <p>Now the circles on the map have colors based on the time they've been parked.</p> <p>But this dataset is skewed with a long tail. Most cars have been sitting way less than 90 days, but a few have been sitting even longer.</p> <p>A logarithmic normalization (aka matplotlib's <code>LogNorm</code>) might be more useful here:</p> In\u00a0[\u00a0]: Copied! <pre>log_normalizer = mpl.colors.LogNorm(3, 90, clip=True)\nlog_values = log_normalizer(gdf[colname])\n</pre> log_normalizer = mpl.colors.LogNorm(3, 90, clip=True) log_values = log_normalizer(gdf[colname]) In\u00a0[\u00a0]: Copied! <pre>layer.get_fill_color = apply_continuous_cmap(log_values, BrBG_10)\nlayer.get_radius = log_values * 50\nlayer.radius_units = \"meters\"\n</pre> layer.get_fill_color = apply_continuous_cmap(log_values, BrBG_10) layer.get_radius = log_values * 50 layer.radius_units = \"meters\" In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/integrations/sidecar/#sidecar","title":"Sidecar\u00b6","text":""},{"location":"examples/integrations/sidecar/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li>lonboard</li> <li>sidecar</li> <li>pyogrio</li> </ul> <p>Run</p> <pre><code>pip install sidecar pyogrio\n</code></pre> <p>if needed. You may need to restart Jupyter and/or refresh your browser tab after installing <code>sidecar</code>.</p>"},{"location":"examples/integrations/sidecar/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/1-points/","title":"30 Day Map Challenge: Day 1 (Points)","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport matplotlib as mpl\nimport numpy as np\nimport pandas as pd\nimport shapely\n\nfrom lonboard import Map, ScatterplotLayer\n</pre> import geopandas as gpd import matplotlib as mpl import numpy as np import pandas as pd import shapely  from lonboard import Map, ScatterplotLayer In\u00a0[2]: Copied! <pre>path = \"/Users/kyle/Downloads/Motor_Vehicle_Collisions_-_Crashes_20231101.csv\"\n</pre> path = \"/Users/kyle/Downloads/Motor_Vehicle_Collisions_-_Crashes_20231101.csv\" <p>Read the data:</p> In\u00a0[3]: Copied! <pre>df = pd.read_csv(path, dtype={\"ZIP CODE\": str})\n</pre> df = pd.read_csv(path, dtype={\"ZIP CODE\": str}) <p>Let's first take a peek at our data:</p> In\u00a0[4]: Copied! <pre>pd.options.display.max_columns = None\ndf.head()\n</pre> pd.options.display.max_columns = None df.head() Out[4]: CRASH DATE CRASH TIME BOROUGH ZIP CODE LATITUDE LONGITUDE LOCATION ON STREET NAME CROSS STREET NAME OFF STREET NAME NUMBER OF PERSONS INJURED NUMBER OF PERSONS KILLED NUMBER OF PEDESTRIANS INJURED NUMBER OF PEDESTRIANS KILLED NUMBER OF CYCLIST INJURED NUMBER OF CYCLIST KILLED NUMBER OF MOTORIST INJURED NUMBER OF MOTORIST KILLED CONTRIBUTING FACTOR VEHICLE 1 CONTRIBUTING FACTOR VEHICLE 2 CONTRIBUTING FACTOR VEHICLE 3 CONTRIBUTING FACTOR VEHICLE 4 CONTRIBUTING FACTOR VEHICLE 5 COLLISION_ID VEHICLE TYPE CODE 1 VEHICLE TYPE CODE 2 VEHICLE TYPE CODE 3 VEHICLE TYPE CODE 4 VEHICLE TYPE CODE 5 0 09/11/2021 2:39 NaN NaN NaN NaN NaN WHITESTONE EXPRESSWAY 20 AVENUE NaN 2.0 0.0 0 0 0 0 2 0 Aggressive Driving/Road Rage Unspecified NaN NaN NaN 4455765 Sedan Sedan NaN NaN NaN 1 03/26/2022 11:45 NaN NaN NaN NaN NaN QUEENSBORO BRIDGE UPPER NaN NaN 1.0 0.0 0 0 0 0 1 0 Pavement Slippery NaN NaN NaN NaN 4513547 Sedan NaN NaN NaN NaN 2 06/29/2022 6:55 NaN NaN NaN NaN NaN THROGS NECK BRIDGE NaN NaN 0.0 0.0 0 0 0 0 0 0 Following Too Closely Unspecified NaN NaN NaN 4541903 Sedan Pick-up Truck NaN NaN NaN 3 09/11/2021 9:35 BROOKLYN 11208 40.667202 -73.866500 (40.667202, -73.8665) NaN NaN 1211      LORING AVENUE 0.0 0.0 0 0 0 0 0 0 Unspecified NaN NaN NaN NaN 4456314 Sedan NaN NaN NaN NaN 4 12/14/2021 8:13 BROOKLYN 11233 40.683304 -73.917274 (40.683304, -73.917274) SARATOGA AVENUE DECATUR STREET NaN 0.0 0.0 0 0 0 0 0 0 NaN NaN NaN NaN NaN 4486609 NaN NaN NaN NaN NaN <p>There are a bunch of columns in this dataset:</p> In\u00a0[5]: Copied! <pre>df.columns\n</pre> df.columns Out[5]: <pre>Index(['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LATITUDE',\n       'LONGITUDE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME',\n       'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n       'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED',\n       'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED',\n       'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED',\n       'NUMBER OF MOTORIST KILLED', 'CONTRIBUTING FACTOR VEHICLE 1',\n       'CONTRIBUTING FACTOR VEHICLE 2', 'CONTRIBUTING FACTOR VEHICLE 3',\n       'CONTRIBUTING FACTOR VEHICLE 4', 'CONTRIBUTING FACTOR VEHICLE 5',\n       'COLLISION_ID', 'VEHICLE TYPE CODE 1', 'VEHICLE TYPE CODE 2',\n       'VEHICLE TYPE CODE 3', 'VEHICLE TYPE CODE 4', 'VEHICLE TYPE CODE 5'],\n      dtype='object')</pre> <p>Let's keep only specific columns that we care about:</p> In\u00a0[6]: Copied! <pre>keep_cols = [\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"LATITUDE\",\n    \"LONGITUDE\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n    \"COLLISION_ID\",\n]\ndf = df[keep_cols]\n</pre> keep_cols = [     \"CRASH DATE\",     \"CRASH TIME\",     \"LATITUDE\",     \"LONGITUDE\",     \"NUMBER OF PERSONS INJURED\",     \"NUMBER OF PERSONS KILLED\",     \"NUMBER OF PEDESTRIANS INJURED\",     \"NUMBER OF PEDESTRIANS KILLED\",     \"NUMBER OF CYCLIST INJURED\",     \"NUMBER OF CYCLIST KILLED\",     \"NUMBER OF MOTORIST INJURED\",     \"NUMBER OF MOTORIST KILLED\",     \"COLLISION_ID\", ] df = df[keep_cols] <p>About 11% of the data have missing locations. For this quick demo, I don't have the ability to georeference those rows based on street name, so we'll just remove them. Hopefully there isn't a skew where crashes in some areas are more likely to not be georeferenced.</p> In\u00a0[7]: Copied! <pre>(df[\"LONGITUDE\"].isnull() | df[\"LATITUDE\"].isnull()).mean()\n</pre> (df[\"LONGITUDE\"].isnull() | df[\"LATITUDE\"].isnull()).mean() Out[7]: <pre>0.11342612579376604</pre> <p>Keep only the rows where longitude and latitude are not null.</p> In\u00a0[8]: Copied! <pre>df = df[(df[\"LONGITUDE\"].notnull() &amp; df[\"LATITUDE\"].notnull())]\n</pre> df = df[(df[\"LONGITUDE\"].notnull() &amp; df[\"LATITUDE\"].notnull())] <p>This dataset has crash data from the end of 2021, all of 2022, and thus far in 2023. For simplicity and regularity, let's choose only data from 2022.</p> <p>We'll convert the date to a datetime column and then select rows where the date happened in 2022:</p> In\u00a0[9]: Copied! <pre>df[\"CRASH DATE\"] = pd.to_datetime(df[\"CRASH DATE\"])\ndf = df[df[\"CRASH DATE\"].dt.year == 2022]\n</pre> df[\"CRASH DATE\"] = pd.to_datetime(df[\"CRASH DATE\"]) df = df[df[\"CRASH DATE\"].dt.year == 2022] <p>Let's also convert the time column from a string to a timestamp.</p> In\u00a0[10]: Copied! <pre>df[\"CRASH TIME\"] = pd.to_datetime(df[\"CRASH TIME\"], format=\"%H:%M\")\n</pre> df[\"CRASH TIME\"] = pd.to_datetime(df[\"CRASH TIME\"], format=\"%H:%M\") <p>If we look at the data types in our data, they were inferred as <code>int64</code> and <code>float64</code> data types:</p> In\u00a0[11]: Copied! <pre>df.dtypes\n</pre> df.dtypes Out[11]: <pre>CRASH DATE                       datetime64[ns]\nCRASH TIME                       datetime64[ns]\nLATITUDE                                float64\nLONGITUDE                               float64\nNUMBER OF PERSONS INJURED               float64\nNUMBER OF PERSONS KILLED                float64\nNUMBER OF PEDESTRIANS INJURED             int64\nNUMBER OF PEDESTRIANS KILLED              int64\nNUMBER OF CYCLIST INJURED                 int64\nNUMBER OF CYCLIST KILLED                  int64\nNUMBER OF MOTORIST INJURED                int64\nNUMBER OF MOTORIST KILLED                 int64\nCOLLISION_ID                              int64\ndtype: object</pre> <p>Knowing that our data holds small values, we can downcast to smaller data types:</p> In\u00a0[12]: Copied! <pre>for numeric_col_name in df.select_dtypes(\"number\").columns:\n    df[numeric_col_name] = pd.to_numeric(df[numeric_col_name], downcast=\"unsigned\")\n</pre> for numeric_col_name in df.select_dtypes(\"number\").columns:     df[numeric_col_name] = pd.to_numeric(df[numeric_col_name], downcast=\"unsigned\") <p>Now our data types are much smaller:</p> In\u00a0[13]: Copied! <pre>df.dtypes\n</pre> df.dtypes Out[13]: <pre>CRASH DATE                       datetime64[ns]\nCRASH TIME                       datetime64[ns]\nLATITUDE                                float64\nLONGITUDE                               float64\nNUMBER OF PERSONS INJURED                 uint8\nNUMBER OF PERSONS KILLED                  uint8\nNUMBER OF PEDESTRIANS INJURED             uint8\nNUMBER OF PEDESTRIANS KILLED              uint8\nNUMBER OF CYCLIST INJURED                 uint8\nNUMBER OF CYCLIST KILLED                  uint8\nNUMBER OF MOTORIST INJURED                uint8\nNUMBER OF MOTORIST KILLED                 uint8\nCOLLISION_ID                             uint32\ndtype: object</pre> <p>Now let's construct a GeoDataFrame from this data.</p> In\u00a0[14]: Copied! <pre>geometry = shapely.points(df.pop(\"LONGITUDE\"), df.pop(\"LATITUDE\"))\ngdf = gpd.GeoDataFrame(df, geometry=geometry)\n</pre> geometry = shapely.points(df.pop(\"LONGITUDE\"), df.pop(\"LATITUDE\")) gdf = gpd.GeoDataFrame(df, geometry=geometry) In\u00a0[15]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[15]: CRASH DATE CRASH TIME NUMBER OF PERSONS INJURED NUMBER OF PERSONS KILLED NUMBER OF PEDESTRIANS INJURED NUMBER OF PEDESTRIANS KILLED NUMBER OF CYCLIST INJURED NUMBER OF CYCLIST KILLED NUMBER OF MOTORIST INJURED NUMBER OF MOTORIST KILLED COLLISION_ID geometry 37 2022-07-12 1900-01-01 17:50:00 0 0 0 0 0 0 0 0 4545699 POINT (-73.96049 40.66330) 40 2022-04-24 1900-01-01 16:45:00 1 0 0 0 0 0 1 0 4521660 POINT (-74.13892 40.60768) 41 2022-04-24 1900-01-01 04:49:00 0 0 0 0 0 0 0 0 4521759 POINT (-73.86990 40.85597) 42 2022-04-22 1900-01-01 17:17:00 1 0 1 0 0 0 0 0 4522226 POINT (-73.93960 40.79028) 43 2022-04-24 1900-01-01 01:30:00 0 0 0 0 0 0 0 0 4522015 POINT (-74.01621 40.64299) <p>If we look at the bounding box of our data, we see that some points are way outside of NYC. Let's filter to include only the data in the NYC region:</p> In\u00a0[16]: Copied! <pre>gdf.total_bounds\n</pre> gdf.total_bounds Out[16]: <pre>array([-74.25496 ,   0.      ,   0.      ,  40.912167])</pre> In\u00a0[17]: Copied! <pre>nyc_bbox = [-74.382742, 40.428857, -73.452477, 41.092696]\n</pre> nyc_bbox = [-74.382742, 40.428857, -73.452477, 41.092696] In\u00a0[18]: Copied! <pre>gdf = gdf[gdf.intersects(shapely.box(*nyc_bbox))]\n</pre> gdf = gdf[gdf.intersects(shapely.box(*nyc_bbox))] In\u00a0[19]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nmap = Map(layers=[layer], _height=800)\nmap\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) map = Map(layers=[layer], _height=800) map Out[19]: <pre>Map(layers=[ScatterplotLayer(table=pyarrow.Table\nCRASH DATE: timestamp[ns]\nCRASH TIME: timestamp[ns]\nNUMBER OF\u2026</pre> <p>Ok cool, we can see something on the map, but let's make our visualization more interesting.</p> <p>Let's compute the number of non-motorists injured in each collision:</p> In\u00a0[20]: Copied! <pre>num_injured = gdf[\"NUMBER OF PEDESTRIANS INJURED\"] + gdf[\"NUMBER OF CYCLIST INJURED\"]\n</pre> num_injured = gdf[\"NUMBER OF PEDESTRIANS INJURED\"] + gdf[\"NUMBER OF CYCLIST INJURED\"] <p>We can see a quick distribution with <code>value_counts</code></p> In\u00a0[21]: Copied! <pre>num_injured.value_counts()\n</pre> num_injured.value_counts() Out[21]: <pre>0    80613\n1    12057\n2      356\n3       37\n4        3\n5        3\nName: count, dtype: int64</pre> In\u00a0[22]: Copied! <pre>layer.get_radius = np.array(num_injured + 1)\nlayer.radius_scale = 50\nlayer.opacity = 0.05\n</pre> layer.get_radius = np.array(num_injured + 1) layer.radius_scale = 50 layer.opacity = 0.05 <p>Next, let's color each dot by time of day. We'll use a cyclic colormap that starts and ends on the same color, because the time of day is cyclic.</p> In\u00a0[23]: Copied! <pre>colormap = mpl.colormaps[\"twilight\"]\ncolormap\n</pre> colormap = mpl.colormaps[\"twilight\"] colormap Out[23]: twilight  underbad over  <p>Next get the minute of day of the crash:</p> In\u00a0[24]: Copied! <pre>minute_of_day = gdf[\"CRASH TIME\"].dt.hour * 60 + gdf[\"CRASH TIME\"].dt.minute\n</pre> minute_of_day = gdf[\"CRASH TIME\"].dt.hour * 60 + gdf[\"CRASH TIME\"].dt.minute <p>To apply a colormap, we need to normalize the <code>minute_of_day</code> series to <code>0-1</code>. We can do this with matplotlib's <code>Normalize</code>. We set the minimum value to 0 and the maximum value to the number of minutes in a day.</p> In\u00a0[25]: Copied! <pre>normalizer = mpl.colors.Normalize(0, 24 * 60)\nnormalized_minutes = normalizer(minute_of_day)\n</pre> normalizer = mpl.colors.Normalize(0, 24 * 60) normalized_minutes = normalizer(minute_of_day) <p>Now <code>normalized_minutes</code> ranges from 0-1:</p> In\u00a0[26]: Copied! <pre>normalized_minutes\n</pre> normalized_minutes Out[26]: <pre>masked_array(data=[0.74305556, 0.69791667, 0.20069444, ..., 0.54166667,\n                   0.625     , 0.60069444],\n             mask=False,\n       fill_value=1e+20)</pre> <p>Next we can apply the matplotlib colormap on our normalized values. We set <code>bytes=True</code> to ensure the output is of <code>uint8</code> data type.</p> In\u00a0[27]: Copied! <pre>colors = colormap(normalized_minutes, bytes=True)\n</pre> colors = colormap(normalized_minutes, bytes=True) In\u00a0[28]: Copied! <pre>colors\n</pre> colors Out[28]: <pre>array([[175,  81,  81, 255],\n       [156,  57,  79, 255],\n       [109, 144, 191, 255],\n       ...,\n       [ 63,  17,  60, 255],\n       [115,  29,  78, 255],\n       [ 99,  24,  75, 255]], dtype=uint8)</pre> In\u00a0[29]: Copied! <pre>layer.get_fill_color = colors\n</pre> layer.get_fill_color = colors In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map_challenge/1-points/#30-day-map-challenge-day-1-points","title":"30 Day Map Challenge: Day 1 (Points)\u00b6","text":"<p>This is a notebook for day 1 of 30 Day Map Challenge.</p>"},{"location":"examples/map_challenge/1-points/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/1-points/#access-the-data","title":"Access the data\u00b6","text":"<p>This data comes from NYC Open Data, where we use Motor Vehicle Collisions - Crashes. First download this data via <code>Export &gt; CSV</code>, save it somewhere on disk, and update the <code>path</code> variable in the next cell for that location.</p>"},{"location":"examples/map_challenge/6-asia/","title":"30 Day Map Challenge: Day 6 (Asia)","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nfrom palettable.colorbrewer.sequential import Blues_8\n\nfrom lonboard import Map, PathLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd from palettable.colorbrewer.sequential import Blues_8  from lonboard import Map, PathLayer from lonboard.colormap import apply_continuous_cmap In\u00a0[2]: Copied! <pre>url = \"https://storage.googleapis.com/fao-maps-catalog-data/geonetwork/aquamaps/rivers_asia_37331.zip\"\n</pre> url = \"https://storage.googleapis.com/fao-maps-catalog-data/geonetwork/aquamaps/rivers_asia_37331.zip\" In\u00a0[3]: Copied! <pre>gdf = gpd.read_file(url, engine=\"pyogrio\")\n</pre> gdf = gpd.read_file(url, engine=\"pyogrio\") <p>The <code>Strahler</code> column seems to refer to how important/central the particular river is. It ranges from 1-7.</p> In\u00a0[4]: Copied! <pre>gdf['Strahler'].value_counts()\n</pre> gdf['Strahler'].value_counts() Out[4]: <pre>Strahler\n1    80503\n2    39100\n3    19655\n4     8960\n5     4547\n6     1901\n7      484\nName: count, dtype: int64</pre> <p>We'll use <code>Strahler</code> to plot more central rivers in both a darker blue and with a wider line.</p> In\u00a0[5]: Copied! <pre>layer = PathLayer.from_geopandas(gdf)\nlayer.get_color = apply_continuous_cmap(gdf['Strahler'] / 7, Blues_8)\nlayer.get_width = gdf['Strahler']\nlayer.width_scale = 3000\nlayer.width_min_pixels = 0.5\n\nm = Map(layers=[layer])\nm\n</pre> layer = PathLayer.from_geopandas(gdf) layer.get_color = apply_continuous_cmap(gdf['Strahler'] / 7, Blues_8) layer.get_width = gdf['Strahler'] layer.width_scale = 3000 layer.width_min_pixels = 0.5  m = Map(layers=[layer]) m Out[5]: <pre>Map(layers=[PathLayer(get_color=&lt;pyarrow.lib.FixedSizeListArray object at 0x107cbb220&gt;\n[\n  [\n    8,\n    69,\n  \u2026</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map_challenge/6-asia/#30-day-map-challenge-day-6-asia","title":"30 Day Map Challenge: Day 6 (Asia)\u00b6","text":"<p>This is a notebook for day 6 of 30 Day Map Challenge.</p> <p>This data comes from the UN's \"Rivers of South and East Asia\".</p>"},{"location":"examples/map_challenge/6-asia/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/6-asia/#fetch-the-data","title":"Fetch the data\u00b6","text":""},{"location":"how-it-works/","title":"How it works?","text":"<p>Lonboard is built on four foundational technologies: deck.gl, GeoArrow, GeoParquet, and anywidget.</p> <ul> <li>deck.gl is a JavaScript geospatial data visualization library. Because deck.gl uses the GPU in your computer to render data, it's capable of performantly rendering very large quantities of data.</li> <li>GeoArrow is a memory format for efficiently representing geospatial vector data. As a memory format, GeoArrow is not compressed and can be used directly.</li> <li>GeoParquet is a file format for efficiently encoding and decoding geospatial vector data. As a file format, GeoParquet contains very efficient compression, and needs to be parsed before it can be used. <sup>1</sup></li> <li>anywidget is a framework for building custom Jupyter widgets that makes the process much easier than before.</li> </ul>"},{"location":"how-it-works/#how-is-it-so-fast","title":"How is it so fast?","text":"<p>Lonboard is so fast because it moves data from Python to JavaScript (in your browser) and then from JavaScript to your Graphics Processing Unit (GPU) more efficiently than ever before.</p> <p>Other Python libraries for interactive maps exist (such as <code>ipyleaflet</code>), and even existing bindings to deck.gl exist (such as <code>pydeck</code>). But those libraries encode data as GeoJSON to copy from Python to the browser. GeoJSON is extremely slow to read and write and results in a very large data file that has to be copied to the browser.</p> <p>With lonboard, the entire pipeline is binary. In Python, GeoPandas to GeoArrow to GeoParquet avoids a text encoding like GeoJSON and results in a compressed binary buffer that can be efficiently copied to the browser. In JavaScript, GeoParquet to GeoArrow offers efficient decoding (in WebAssembly). Then deck.gl is able to interpret the GeoArrow table directly without any parsing (thanks to <code>@geoarrow/deck.gl-layers</code>).</p> <p>GeoPandas is the primary interface for users to add data, allowing lonboard to internally manage the conversion to GeoArrow and its transport to the browser for rendering.</p> <p>Lonboard's goal is to abstract the technical bits of representing and moving data so it can attain its dual goals of performance and ease of use for a vast audience.</p> <ol> <li> <p>lonboard currently doesn't use \"official\" GeoParquet 1.0, because the 1.0 spec requires encoding geometries as Well-Known Binary (WKB) inside of the Parquet file. lonboard uses the highly-efficient GeoArrow encoding inside of GeoParquet (which may become part of the GeoParquet spec in 1.1). This is faster and easier to write when the writer and reader are both using GeoArrow anyways.\u00a0\u21a9</p> </li> </ol>"},{"location":"how-it-works/internals/","title":"Internal Architecture","text":"<p>Last edited April 2024.</p> <p>This document will outline Lonboard's internal architecture, and hopefully should be useful for potential contributors.</p>"},{"location":"how-it-works/internals/#pydeck","title":"Pydeck","text":"<p>Before we consider Lonboard, we should briefly cover how Pydeck manages data transit.</p> <p>Pydeck uses the loaders.gl ecosystem natively supported in deck.gl. This means that pydeck passes the user input directly into the <code>data</code> prop of any given layer. When <code>data</code> is a string, it's interpreted as a URL, passed into loaders.gl machinery to parse the given data format to a list of GeoJSON features. In order to do data-driven styling, users pass in strings like <code>\"@@=properties.valuePerSqm\"</code> to describe the JavaScript callback that should be applied to each GeoJSON feature.</p> <p>In my opinion, this presents performance pitfalls and gives Pydeck a stifling amount of flexibility. The Python API isn't able to do much of anything because the user input could be anything and users end up writing a sort of JavaScript in Python strings.</p>"},{"location":"how-it-works/internals/#lonboard","title":"Lonboard","text":""},{"location":"how-it-works/internals/#goals-and-target-user-persona","title":"Goals and target user persona","text":"<p>While I was never a primary pydeck developer and can't speak to their goals, I can say that Lonboard has a well-formed idea of the target user.</p> <p>When I was learning geospatial data processing in Python, I learned that GeoPandas, Shapely, and others were amazing tools. But I would perform operations and not have a deep understanding of what the output looked like. I wanted some way to quickly get a picture of what my data looked like. This drove me to build <code>keplergl_cli</code>, a single function or CLI command to visualize data in an interactive HTML map. The desire for this simplicity lives on in Lonboard's <code>viz</code> function.</p> <p>This experience informs the target user of Lonboard:</p> <ul> <li>A Python user who does not know or want to know JavaScript.</li> <li>Wants fast exploratory data analysis.</li> <li>Already working with data in Python.</li> <li>A reasonably fast internet connection on a desktop computer.</li> </ul>"},{"location":"how-it-works/internals/#python-classes","title":"Python classes","text":"<p>The <code>Map</code> class is the primary and only widget associated with JavaScript that renders anything. <code>Map</code> subclasses from <code>anywidget.AnyWidget</code>, which dynamically fetches Lonboard's JavaScript ESM bundle. The <code>Map</code> class emulates deck.gl's <code>Deck</code> class. It synchronizes map state and can be passed a sequence of <code>Layer</code> objects.</p> <p><code>Layer</code> classes are designed to map to each underlying deck.gl layer. Most <code>Layer</code> classes subclass from <code>BaseArrowLayer</code>, which stores a <code>pyarrow.Table</code> in the dataclass. This data object gets serialized to Parquet and rendered in a layer provided by <code>@geoarrow/deck.gl-layers</code> as described later on. The primary API for each of these Arrow-based layers is <code>from_geopandas</code>, which converts a <code>GeoDataFrame</code> to a <code>pyarrow.Table</code> with a GeoArrow-represented geometry column. A few layers are not Arrow-based and do not subclass from <code>BaseArrowLayer</code>: primarily <code>BitmapLayer</code> and <code>BitmapTileLayer</code>. These pass user data input directly into a core deck.gl layer.</p> <p>These <code>Layer</code> classes subclass from <code>ipywidgets.Widget</code> but are not associated with any JavaScript of their own. But by being widgets themselves, their data is synced with JavaScript and Python data changes are propagated as events to the core <code>Map</code> object.</p> <p>Each layer has parameters that map to deck.gl accessors and render properties. Each of these has validation on the Python side to catch invalid input early. Accessors are modeled with \"trait\" objects. Scalar accessors are stored as a scalar int/string/float. Function accessors are evaluated in Python and stored as a <code>pyarrow.Array</code>.</p> <p>A variety of layer extensions are supported, which map to deck.gl's upstream layer extensions. These layer extensions dynamically add more parameters to the layers on which they're assigned.</p>"},{"location":"how-it-works/internals/#data-loading","title":"Data loading","text":"<p>While pydeck allows users to pass in URLs to remote files, at the moment this is not possible in Lonboard. With only a few exceptions (e.g. the <code>BitmapLayer</code> and <code>BitmapTileLayer</code>), only data originating in Python is supported in Lonboard. This reduction in scope vastly simplifies Lonboard's internals while not providing much of a hurdle for Lonboard's core audience.</p> <p>Jupyter provides a WebSocket connection between Python and JavaScript. Jupyter widget state from Python classes is serialized over this WebSocket and received in JavaScript. While most widgets synchronize objects through JSON, widgets fully support binary data as well, which Lonboard utilizes.</p>"},{"location":"how-it-works/internals/#simplicity-of-code","title":"Simplicity of code","text":"<p>Supporting only a single data provenance and format makes the internals of Lonboard much more maintainable. Lonboard's JavaScript bindings only need to include a single data parser and can optimize performance for Parquet and Arrow data.</p>"},{"location":"how-it-works/internals/#parquet","title":"Parquet","text":"<p>Parquet was chosen as the underlying data transmission format for its excellent compression, fast read and write speeds, compatibility with GeoArrow and, in turn, compatibility with deck.gl's binary API.</p> <p>I tested with data from the speed test example (3 million points). Saving GeoArrow to Parquet was 135x faster than saving a GeoDataFrame to GeoJSON. The resulting file was 26x smaller. And parsing the Parquet to Arrow on the frontend was 5.6x faster than <code>JSON.parse</code> (including moving the Arrow from WebAssembly to JS).</p> <p>Note that what is sent over the wire is not GeoParquet. GeoParquet 1.0 requires special metadata and WKB-encoded geometries. Using that would require code on the frontend to parse WKB-encoded geometries into GeoArrow. The upcoming GeoParquet 1.1 includes support for GeoArrow but only its \"separated\" coordinates, where <code>x</code> and <code>y</code> coordinate values are in two different buffers (i.e. <code>xxxx</code>, <code>yyyy</code>). deck.gl's binary API currently does not support passing separated coordinates. Therefore Lonboard uses the \"interleaved\" coordinate variant, where <code>x</code> and <code>y</code> coordinates are stored in the same buffer (i.e. <code>xyxyxyxy</code>).</p>"},{"location":"how-it-works/internals/#bootstrapping-geoarrow","title":"Bootstrapping GeoArrow","text":"<p>For performance reasons, Lonboard is very focused on using GeoArrow throughout the pipeline in both Python and JavaScript. At the time when Lonboard was started, there were no user-friendly tools for converting data to GeoArrow in client-side JavaScript. By supporting only data from Python and only Parquet data, we could focus on making data conversions from GeoPandas to GeoArrow in Python efficient and stable. This enables GeoArrow to be \"just an implementation detail\" and out of any primary public APIs while also working to bootstrap a GeoArrow ecosystem in Python and JavaScript.</p>"},{"location":"how-it-works/internals/#authentication","title":"Authentication","text":"<p>Since all data is loaded via Python over the Jupyter-provided WebSocket, Lonboard doesn't need to implement any sort of authentication itself. The user is able to use whatever credentials they're familiar with, say for S3, to access data. Those credentials never need to be passed to the browser.</p> <p>In contrast, having the JavaScript side load data directly from a URL requires some way for users to specify authorization headers or API keys for access to private datasets.</p>"},{"location":"how-it-works/internals/#layer-creation","title":"Layer Creation","text":"<p>With the exception of the <code>BitmapLayer</code>, no direct deck.gl layers are used. deck.gl layers are used exclusively through the <code>@geoarrow/deck.gl-layers</code> glue library. This library connects GeoArrow data to the low-level binary data API of each deck.gl layer. All accessors are passed in directly as binary buffers.</p> <p>This means that in JavaScript the data never leaves an Arrow binary representation. It's parsed from Parquet to Arrow in WebAssembly, the Arrow buffers are copied out of WebAssembly memory, but never parsed to JSON strings or JavaScript objects.</p>"},{"location":"how-it-works/internals/#accessors-and-data-driven-rendering","title":"Accessors and data-driven rendering","text":"<p>Loading data from Python also helps to simplify data-driven rendering.</p>"},{"location":"how-it-works/internals/#no-function-serialization","title":"No function serialization","text":"<p>If we can make the data movement between Python and JavaScript fast enough, we can serialize computed rendering properties rather than the function to generate them. Lonboard serializes data, not functions.</p> <p>Any accessor used to style data is computed in Python, stored as a binary array, serialized to Parquet and sent to the frontend. Other than parsing the input Parquet buffers to Arrow, no data transformations or modifications are done on the JavaScript side.</p> <p>In Pydeck users had to pass something like</p> <pre><code>getRadius=\"@@=properties.valuePerSqm\"\n</code></pre> <p>which would be expanded into</p> <pre><code>getRadius: (object) =&gt; object.properties.valuePerSqm\n</code></pre> <p>on the JavaScript side.</p> <p>I find this syntax to be horrible UX. The user is no longer writing Python, they need to learn a new DSL just for this.</p> <p>RGB Colors for 3 million points take up 9MiB in memory (or 12MiB for RGBA). In the example of speed test data, 12MiB of RGBA data compressed down to 4MiB for transit. Float32 radii values for 3 million points take up 12MiB in memory and 9MiB compressed.</p> <p>Even for users on remote Python environments, this takes no more than a couple seconds to download, and then can render almost instantly. For non-point datasets with a fewer number of geometries, the byte size of accessors are even smaller relative to the geometry buffers.</p>"},{"location":"how-it-works/internals/#update-styling-without-re-sending-data","title":"Update styling without re-sending data","text":"<p>With Lonboard's widget architecture, any accessors other than the geometry are stored separately to the main Arrow table. This means that all accessors and rendering properties can be updated in isolation. The core table does not need to be synced again when a property is updated.</p>"},{"location":"how-it-works/internals/#uses-familiar-objects","title":"Uses familiar objects","text":"<p>Accessors are defined in terms of Numpy arrays, Pandas Series or PyArrow Arrays, which are familiar to Python data scientists.</p>"},{"location":"how-it-works/internals/#full-access-to-python","title":"Full access to Python","text":"<p>Because we serialize data to JavaScript instead of a function in a custom DSL, the user has the full spectrum of Python available to them. They can use one of matplotlib's many normalization helpers before applying a colormap. Or they can use apply some ML model and use its outputs for point radii.</p>"}]}