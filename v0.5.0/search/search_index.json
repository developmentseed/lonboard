{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lonboard","text":"<p>A Python library for fast, interactive geospatial vector data visualization in Jupyter.</p> <p>Building on cutting-edge technologies like GeoArrow and GeoParquet in conjunction with GPU-based map rendering, lonboard aims to enable visualizing large geospatial datasets interactively through a simple interface.</p> <p></p> <p>3 million points rendered from a geopandas <code>GeoDataFrame</code> in JupyterLab.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install lonboard\n</code></pre>"},{"location":"#get-started","title":"Get Started","text":"<p>For the simplest rendering, pass geospatial data into the top-level <code>viz</code> function.</p> <pre><code>import geopandas as gpd\nfrom lonboard import viz\n\ngdf = gpd.GeoDataFrame(...)\nviz(gdf)\n</code></pre> <p>Under the hood, this delegates to a <code>ScatterplotLayer</code>, <code>PathLayer</code>, or <code>SolidPolygonLayer</code>. Refer to the documentation and examples for more control over rendering.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation at developmentseed.org/lonboard.</p>"},{"location":"#why-the-name","title":"Why the name?","text":"<p>This is a new binding to the deck.gl geospatial data visualization library. A \"deck\" is the part of a skateboard you ride on. What's a fast, geospatial skateboard? A lonboard.</p> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#050-2023-12-01","title":"[0.5.0] - 2023-12-01","text":""},{"location":"CHANGELOG/#new-features","title":"New Features","text":"<ul> <li>Improve map height by @vgeorge in developmentseed/lonboard!220</li> <li>Add method to apply a categorical colormap by @kylebarron in developmentseed/lonboard!251</li> <li>Deduce environment and set map height in colab and vscode by @kylebarron in developmentseed/lonboard!252</li> <li>Add various carto basemaps as options by @kylebarron in developmentseed/lonboard!268</li> <li>Sync the clicked index back to Python by @kylebarron in developmentseed/lonboard!270</li> <li>Set <code>width_min_pixels</code> in PathLayer example by @kylebarron in developmentseed/lonboard!276</li> <li>Bump deck.gl layers for performance benefits by @kylebarron in developmentseed/lonboard!277</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.2...v0.5.0</p>"},{"location":"CHANGELOG/#042-2023-11-13","title":"[0.4.2] - 2023-11-13","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed ScatterplotLayer rendering by @kylebarron in developmentseed/lonboard!246</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.1...v0.4.2</p>"},{"location":"CHANGELOG/#041-2023-11-13","title":"[0.4.1] - 2023-11-13","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed Polygon rendering by @kylebarron in developmentseed/lonboard!243</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.4.0...v0.4.1</p>"},{"location":"CHANGELOG/#040-2023-11-10","title":"[0.4.0] - 2023-11-10","text":""},{"location":"CHANGELOG/#new-features_1","title":"New Features","text":"<ul> <li>New <code>HeatmapLayer</code></li> <li>New <code>experimental</code> module, with new layers (<code>ArcLayer</code>, <code>TextLayer</code>) and \"layer extensions\" (<code>BrushingExtension</code>, <code>CollisionFilterExtension</code>).</li> <li>New \"migration\" notebook using the experimental <code>ArcLayer</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Add pandas v2 requirement by @kylebarron in developmentseed/lonboard!229</li> <li>bump anywidget to 0.7.1 by @kylebarron in developmentseed/lonboard!233</li> </ul> <p>This should error when the JS files have not been included when packaging.</p> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.3.0...v0.4.0</p>"},{"location":"CHANGELOG/#030-2023-11-07","title":"[0.3.0] - 2023-11-07","text":""},{"location":"CHANGELOG/#new-features_2","title":"New Features","text":"<ul> <li>Save widget to standalone HTML file by @kylebarron in developmentseed/lonboard!199</li> <li>Support for rendering inside Visual Studio Code</li> <li>Allow customized picking radius by @kylebarron in developmentseed/lonboard!212</li> <li>New example notebooks</li> <li>Automatically downcast data types in <code>from_geopandas</code> by @kylebarron in developmentseed/lonboard!195</li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Allow pandas series as accessor to FloatAccessor by @kylebarron in developmentseed/lonboard!208</li> <li>Raise error when creating class with unknown keyword argument by @kylebarron in developmentseed/lonboard!209</li> <li>fix tooltip rendering when not hovering over an object by @kylebarron in developmentseed/lonboard!215</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.2.0...v0.3.0</p>"},{"location":"CHANGELOG/#020-2023-11-01","title":"[0.2.0] - 2023-11-01","text":""},{"location":"CHANGELOG/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Layers no longer render a map object. Instead, pass one or more layer instances into a <code>lonboard.Map</code> and display that.</li> </ul>"},{"location":"CHANGELOG/#new-features_3","title":"New Features","text":"<ul> <li>Support multiple layers on a single map.</li> <li>Tooltip with data information on hover.</li> <li>Allow hex string color input to ColorAccessor.</li> <li>Versioned documentation website</li> <li>New examples</li> <li>Experimental API to change map height</li> </ul>"},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Fix handling of 3d coordinates by @kylebarron in developmentseed/lonboard!160</li> <li>Improved validation error messages by @kylebarron in developmentseed/lonboard!161</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@chrisgervang made their first contribution in developmentseed/lonboard!150</li> </ul> <p>Full Changelog: github.com/developmentseed/lonboard/compare/v0.1.2...v0.2.0</p>"},{"location":"CHANGELOG/#012-2023-10-24","title":"[0.1.2] - 2023-10-24","text":"<ul> <li>Actually update <code>@geoarrow/deck.gl-layers</code> to version 0.2.0, whoops \ud83d\ude05</li> </ul>"},{"location":"CHANGELOG/#011-2023-10-23","title":"[0.1.1] - 2023-10-23","text":"<ul> <li>Updates to <code>@geoarrow/deck.gl-layers</code> version 0.2.0:</li> <li>Fixed MultiPolygon rendering</li> <li>Fixed rendering of polygons with holes.</li> <li>Polygon rendering is roughly 35% faster.</li> </ul>"},{"location":"CHANGELOG/#010-2023-10-17","title":"[0.1.0] - 2023-10-17","text":"<ul> <li>Initial public release.</li> <li>Initial support for <code>ScatterplotLayer</code>, <code>PathLayer</code>, and <code>SolidPolygonLayer</code>.</li> </ul>"},{"location":"alternatives/","title":"Alternatives to Lonboard","text":""},{"location":"alternatives/#lonboard-vs-ipyleaflet","title":"Lonboard vs ipyleaflet","text":"<p>ipyleaflet is a great rendering library for small- and medium-sized datasets. ipyleaflet supports a broad range of data types and formats and gives the user broad control over how to render data.</p> <p>The downside of ipyleaflet is that it doesn't support large datasets as well. It uses GeoJSON to transfer data to the frontend, which is slow to write, slow to read, and large in transit. Additionally, leaflet's primary goal is not to support very large quantities of data.</p>"},{"location":"alternatives/#lonboard-vs-pydeck","title":"Lonboard vs pydeck","text":"<p>Pydeck is a full-featured binding from Python to deck.gl. Pydeck attempts to cover most of the deck.gl API. It's harder to use binary data transport with pydeck, and similarly to ipyleaflet will usually serialize data to GeoJSON.</p> <p>Lonboard does not try to cover deck.gl's full API, but rather has an opinionated approach that nudges users to the fastest rendering for many common use cases.</p>"},{"location":"alternatives/#why-not-contribute-back-to-pydeck","title":"Why not contribute back to pydeck?","text":"<p>Pydeck and lonboard have very different goals.</p> <p>A stated goal of pydeck is to be non-opinionated and to allow users with various data sources (GeoJSON strings, URLs to arbitrary data sources, etc.) to render. It makes sense for \"official\" bindings to be non-opinionated, but lonboard takes an opposite tack. By forcing users to use Arrow, we can get reliably fast performance the very common use case of rendering <code>GeoDataFrame</code>s. A downside here is that an Arrow-based implementation has required dependencies that pydeck wouldn't want. <code>pyarrow</code> on the Python side is 90MB on disk. Arrow JS on the JS side is ~200kb, and the default <code>parquet-wasm</code> build is ~1MB.</p> <p>Pydeck is tightly tied into the deck.gl JSON renderer, which allows describing a map state fully in JSON. It's not clear how this would work with the JavaScript GeoArrow layers.</p> <p>Aside from this, pydeck and lonboard use different widget architectures. Pydeck is built on the historical ipywidget layout, using the widget cookiecutter as inspiration and having a separate Jupyter Widget package published to NPM. Lonboard takes a newer approach (unavailable at the time pydeck was created) that uses Anywidget, vastly simplifying the widget process.</p>"},{"location":"alternatives/#lonboard-vs-keplergl-jupyter","title":"Lonboard vs kepler.gl-jupyter","text":"<p>kepler.gl is a JavaScript application focused on presenting a simple, high-level visualization and analysis toolkit to browser-based users. Just like Lonboard, it's built on top of deck.gl. It also has Python bindings via kepler.gl-jupyter.</p> <p>kepler.gl is a very good tool for data analysis and exploration in the browser. On the contrary, Lonboard targets users who plan to do most analysis in Python, but want the best performance to visualize the maximum amount of data. Lonboard should have better rendering performance, but has no user interface to analyze data in the browser.</p> <p>kepler.gl-jupyter serializes to GeoJSON and kepler.gl uses GeoJSON-like JavaScript objects internally; it therefore has the downside of creating a large text string in Python and serializing that to JavaScript. kepler.gl-jupyter is great for creating standalone static HTML files containing a dataset, but those files tend to be very large, since they contain embedded GeoJSON.</p>"},{"location":"alternatives/#lonboard-vs-datashader","title":"Lonboard vs datashader","text":"<p>Datashader is a truly scalable rendering library. Datashader will re-render your data from scratch when panning around in a map. This allows datashader to aggregate the source data before rendering. Datashader minimizes the amount of data being rendered and thus, in theory, Datashader should perform well for datasets as large as your computer's memory.</p> <p>Lonboard is not scalable in the same sense. It doesn't minimize the amount of data being rendered. If you ask to plot a GeoDataFrame with 3 million points, every single one of those points is transferred to the GPU and drawn to your screen. In contrast to Datashader, Lonboard should perform well for datasets whose geometries fit in your computer's GPU memory, which is usually much smaller than your computer's total memory.</p>"},{"location":"how-it-works/","title":"How it works?","text":"<p>Lonboard is built on four foundational technologies: deck.gl, GeoArrow, GeoParquet, and anywidget.</p> <ul> <li>deck.gl is a JavaScript geospatial data visualization library. Because deck.gl uses the GPU in your computer to render data, it's capable of performantly rendering very large quantities of data.</li> <li>GeoArrow is a memory format for efficiently representing geospatial vector data. As a memory format, GeoArrow is not compressed and can be used directly.</li> <li>GeoParquet is a file format for efficiently encoding and decoding geospatial vector data. As a file format, GeoParquet contains very efficient compression, and needs to be parsed before it can be used. <sup>1</sup></li> <li>anywidget is a framework for building custom Jupyter widgets that makes the process much easier than before.</li> </ul>"},{"location":"how-it-works/#how-is-it-so-fast","title":"How is it so fast?","text":"<p>Lonboard is so fast because it moves data from Python to JavaScript (in your browser) and then from JavaScript to your Graphics Processing Unit (GPU) more efficiently than ever before.</p> <p>Other Python libraries for interactive maps exist (such as <code>ipyleaflet</code>), and even existing bindings to deck.gl exist (such as <code>pydeck</code>). But those libraries encode data as GeoJSON to copy from Python to the browser. GeoJSON is extremely slow to read and write and results in a very large data file that has to be copied to the browser.</p> <p>With lonboard, the entire pipeline is binary. In Python, GeoPandas to GeoArrow to GeoParquet avoids a text encoding like GeoJSON and results in a compressed binary buffer that can be efficiently copied to the browser. In JavaScript, GeoParquet to GeoArrow offers efficient decoding (in WebAssembly). Then deck.gl is able to interpret the GeoArrow table directly without any parsing (thanks to <code>@geoarrow/deck.gl-layers</code>).</p> <p>GeoPandas is the primary interface for users to add data, allowing lonboard to internally manage the conversion to GeoArrow and its transport to the browser for rendering.</p> <p>Lonboard's goal is to abstract the technical bits of representing and moving data so it can attain its dual goals of performance and ease of use for a vast audience.</p> <ol> <li> <p>lonboard currently doesn't use \"official\" GeoParquet 1.0, because the 1.0 spec requires encoding geometries as Well-Known Binary (WKB) inside of the Parquet file. lonboard uses the highly-efficient GeoArrow encoding inside of GeoParquet (which may become part of the GeoParquet spec in 1.1). This is faster and easier to write when the writer and reader are both using GeoArrow anyways.\u00a0\u21a9</p> </li> </ol>"},{"location":"performance/","title":"Performance","text":"<p>Performance is a critical goal of lonboard. Below are a couple pieces of information you should know to understand lonboard's performance characteristics, as well as some advice for how to get the best performance.</p>"},{"location":"performance/#performance-characteristics","title":"Performance Characteristics","text":"<p>There are two distinct parts to the performance of lonboard: one is the performance of transferring data to the browser and the other is the performance of rendering the data once it's there.</p> <p>In general, these parts are completely distinct. Even if it takes a while to load the data in your browser, the map might be snappy once it loads, and vice versa.</p>"},{"location":"performance/#data-transfer","title":"Data Transfer","text":"<p>Lonboard creates an interactive visualization of your data in your browser. In order to do this, your GeoDataFrame needs to be transferred from your Python environment to your browser.</p> <p>In the case where your Python session is running locally (on the same machine as your browser), this data transfer is extremely fast: less than a second in most cases.</p> <p>However, in the case where your Python session is running on a remote server (such as Google Colab, Binder, or a JupyterHub instance), this data transfer means downloading the data to your local browser. Therefore, when running lonboard from a remote server, your internet speed and the quantity of data you pass into a layer will have large impacts on the data transfer speed.</p> <p>Under the hood, lonboard uses efficient compression (in the form of GeoParquet) to transfer data to the browser, but compression can only do so much; the data still needs to be downloaded.</p>"},{"location":"performance/#rendering-performance","title":"Rendering Performance","text":"<p>Once the data has been transfered from your Python session to your browser, it needs to be rendered.</p> <p>The biggest thing to note is that \u2014 in contrast to projects like datashader \u2014 lonboard does not minimize the amount of data being rendered. If you pass a GeoDataFrame with 10 million coordinates, lonboard will attempt to render all 10 million coordinates at once.</p> <p>The primary determinant of the maximum amount of data you can render with lonboard is your computer's hardware. Via the underlying deck.gl library, lonboard ultimately renders geometries using your computer's Graphics Processing Unit (GPU). If you have a better GPU card, you'll be able to visualize more data.</p> <p>Lonboard is more efficient at rendering than previous libraries, but there will always be some quantity of data beyond which your browser tab is likely to crash while attempting to render. Testing on a recent MacBook Pro M2 computer, lonboard has been able to render a few million points with minimal lag.</p>"},{"location":"performance/#performance-advice","title":"Performance Advice","text":""},{"location":"performance/#use-a-local-python-session","title":"Use a local Python session","text":"<p>Moving from a remote Python environment to a local Python environment is often impractical, but this change will make it much faster to visualize data, especially over slow internet connections.</p>"},{"location":"performance/#mutate-an-existing-map-where-possible","title":"Mutate an existing map where possible","text":"<p>Whenever you create a new map object, all the data will be transfered from your Python environment to your browser. Whenever mutating an existing map object, only the changed data will be sent to the browser.</p> <p>Therefore, unless changing the content of the data being rendered, do not create a new map object. If you're changing the rendering options of an existing map, prefer mutating the existing map object.</p> <p>Bad</p> <pre><code>map1 = ScatterplotLayer.from_geopandas(my_geodataframe)\n\n# Next cell\nmap2 = ScatterplotLayer.from_geopandas(\n    my_geodataframe,\n    get_fill_color=[255, 0, 0]\n)\n</code></pre> <p>Good</p> <pre><code>map1 = ScatterplotLayer.from_geopandas(my_geodataframe)\n\n# Next cell\nmap1.get_fill_color = [255, 0, 0]\n</code></pre> <p>In the first (bad) case, the content of <code>my_geodataframe</code> will be sent twice to the browser. In the second (good) case, the content of <code>my_geodataframe</code> will be sent only once to the browser, and only the tiny array <code>[255, 0, 0]</code> will be transfered on the second call.</p>"},{"location":"performance/#remove-columns-before-rendering","title":"Remove columns before rendering","text":"<p>All columns included in the <code>GeoDataFrame</code> will be transferred to the browser for visualization. (In the future, these other columns will be used to display a tooltip when hovering over/clicking on a geometry.)</p> <p>Especially in the case of a remote Python session, excluding unnecessary attribute columns will make data transfer to the browser faster.</p>"},{"location":"performance/#use-arrow-based-data-types-in-pandas","title":"Use Arrow-based data types in Pandas","text":"<p>As of Pandas 2.0, Pandas supports two backends for data types: either the original numpy-based data types or new data types based on Arrow and the pyarrow library.</p> <p>The first thing that lonboard does when visualizing data is converting from Pandas to an Arrow representation. Any non-geometry attribute columns will be converted to Arrow, so if you're using Arrow-based data types in Pandas already, this step will be \"free\" as no conversion is needed.</p> <p>If you're loading data from a geospatial file format, as of <code>pyogrio</code> version 0.7, you can load data to Arrow-based columns with</p> <pre><code>import pyogrio\nimport pandas as pd\n\narrow_to_pandas_kwargs = {\n    'types_mapper': lambda pa_dtype: pd.ArrowDtype(pa_dtype)\n}\ngdf = pyogrio.read_dataframe(\n    \"path/to/file\",\n    use_arrow=True,\n    arrow_to_pandas_kwargs=arrow_to_pandas_kwargs\n)\n</code></pre> <p>or directly from GeoPandas with <code>geopandas.read_file</code> with <code>engine=\"pyogrio\"</code>:</p> <pre><code>import geopandas as gpd\nimport pandas as pd\n\narrow_to_pandas_kwargs = {\n    'types_mapper': lambda pa_dtype: pd.ArrowDtype(pa_dtype)\n}\ngdf = gpd.read_file(\n    \"path/to/file\",\n    engine=\"pyogrio\",\n    use_arrow=True,\n    arrow_to_pandas_kwargs=arrow_to_pandas_kwargs\n)\n</code></pre> <p>See the pandas guide on data types and the <code>pandas.ArrowDtype</code> class for more information.</p>"},{"location":"performance/#simplify-geometries-before-rendering","title":"Simplify geometries before rendering","text":"<p>Simplifying geometries before rendering reduces the total number of coordinates and can make a visualization snappier. At this point, lonboard does not offer built-in geometry simplification. This is something you would need to do before passing data to lonboard.</p>"},{"location":"api/basemap/","title":"lonboard.basemap","text":""},{"location":"api/basemap/#lonboard.basemap.CartoBasemap","title":"lonboard.basemap.CartoBasemap","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Basemap styles provided by Carto.</p> <p>Refer to Carto documentation for information on styles.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.DarkMatter","title":"DarkMatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DarkMatter = 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json'\n</code></pre> <p>A dark map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.DarkMatterNoLabels","title":"DarkMatterNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DarkMatterNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A dark map style without labels.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.Positron","title":"Positron  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Positron = 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'\n</code></pre> <p>A light map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.PositronNoLabels","title":"PositronNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PositronNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/positron-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A light map style without labels.</p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.Voyager","title":"Voyager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Voyager = 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json'\n</code></pre> <p>A light, colored map style with labels.</p> <p></p>"},{"location":"api/basemap/#lonboard.basemap.CartoBasemap.VoyagerNoLabels","title":"VoyagerNoLabels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VoyagerNoLabels = (\n    \"https://basemaps.cartocdn.com/gl/voyager-nolabels-gl-style/style.json\"\n)\n</code></pre> <p>A light, colored map style without labels.</p>"},{"location":"api/colormap/","title":"lonboard.colormap","text":""},{"location":"api/colormap/#lonboard.colormap.apply_continuous_cmap","title":"lonboard.colormap.apply_continuous_cmap","text":"<pre><code>apply_continuous_cmap(\n    values: NDArray[np.floating],\n    cmap: Palette,\n    *,\n    alpha: Union[float, int, NDArray[np.floating], None] = None\n) -&gt; NDArray[np.uint8]\n</code></pre> <p>Apply a colormap to a column of continuous values.</p> <p>This is described as \"continuous\" because it uses matplotlib's LinearSegmentedColormap under the hood. As described in Matplotlib's referenced docstring:</p> <p>The lookup table is generated using linear interpolation for each primary color, with the 0-1 domain divided into any number of segments.</p> <p>This means that input values are linearly combined from the two nearest colormap colors.</p> <p>If you want to snap to the \"nearest\" colormap value, you should use another function (not yet implemented) to snap to the strictly nearest color value.</p> <p>Parameters:</p> <ul> <li> <code>values</code>             (<code>NDArray[floating]</code>)         \u2013          <p>A numpy array of floating point values ranging from 0 to 1.</p> </li> <li> <code>cmap</code>             (<code>Palette</code>)         \u2013          <p>Any <code>Palette</code> object from the <code>palettable</code> package.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>alpha</code>             (<code>Union[float, int, NDArray[floating], None]</code>)         \u2013          <p>Alpha must be a scalar between 0 and 1, a sequence of such floats with shape matching <code>values</code>, or None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[uint8]</code>         \u2013          <p>A two dimensional numpy array with data type np.uint8. The second dimension will have a length of either <code>3</code> if <code>alpha</code> is <code>None</code>, or <code>4</code> is each color has an alpha value.</p> </li> </ul>"},{"location":"api/colormap/#lonboard.colormap.RGBColor","title":"lonboard.colormap.RGBColor  <code>module-attribute</code>","text":"<pre><code>RGBColor = Union[Tuple[int, int, int], Tuple[int, int, int, int], Sequence[int]]\n</code></pre> <p>A type definition for an RGB or RGBA color value</p> <p>All values must range between 0 and 255 (inclusive). If only three values are provided, the fourth (alpha) channel will be inferred as 255 (meaning full opacity, no transparency).</p>"},{"location":"api/colormap/#lonboard.colormap.DiscreteColormap","title":"lonboard.colormap.DiscreteColormap  <code>module-attribute</code>","text":"<pre><code>DiscreteColormap = Dict[Any, RGBColor]\n</code></pre> <p>A type definition for a discrete colormap.</p> <p>For example, for a land cover colormap, you may want to use the following dict:</p> <pre><code>color_map = {\n    \"Open Water\": [70, 107, 159],\n    \"Perennial Snow/Ice\": [209, 222, 248],\n    \"Developed, Open Space\": [222, 197, 197],\n    \"Developed, Low Intensity\": [217, 146, 130],\n    \"Developed, Medium Intensity\": [235, 0, 0],\n    \"Developed, High Intensity\": [171, 0, 0],\n    \"Barren Land\": [179, 172, 159],\n    \"Deciduous Forest\": [104, 171, 95],\n    \"Evergreen Forest\": [28, 95, 44],\n    \"Mixed Forest\": [181, 197, 143],\n    \"Shrub/Scrub\": [204, 184, 121],\n    \"Herbaceous\": [223, 223, 194],\n    \"Hay/Pasture\": [220, 217, 57],\n    \"Cultivated Crops\": [171, 108, 40],\n    \"Woody Wetlands\": [184, 217, 235],\n    \"Emergent Herbaceous Wetlands\": [108, 159, 184],\n}\n</code></pre> <p>This corresponds to the following well-known color palette from the National Land Cover Database.</p> <p> </p> <p>Keep in mind that the type of the key of the <code>color_map</code> dictionary is important. If your data is represented as a string, the keys of the <code>color_map</code> must also be represented as strings. If your data is represented as an integer, the keys of the colormap should be integers.</p>"},{"location":"api/colormap/#lonboard.colormap.apply_categorical_cmap","title":"lonboard.colormap.apply_categorical_cmap","text":"<pre><code>apply_categorical_cmap(\n    values: Union[NDArray, pd.Series, pa.Array, pa.ChunkedArray],\n    cmap: DiscreteColormap,\n    *,\n    alpha: Optional[int] = None\n) -&gt; NDArray[np.uint8]\n</code></pre> <p>Apply a colormap to a column of categorical values.</p> <p>If you're working with categorical data in Pandas or GeoPandas, and especially when those categories are strings, you should use the pandas Categorical type. This will use much less memory and be faster to operate on. <code>apply_categorical_cmap</code> will be 2-3x faster (and use less memory itself) when your data is already represented as a categorical data type.</p> <p>The key of the colormap must be the same as the data type of the column of values you pass in. Usually this will be string, when you perform the lookup on a string column of data.</p> <p>Parameters:</p> <ul> <li> <code>values</code>             (<code>Union[NDArray, Series, Array, ChunkedArray]</code>)         \u2013          <p>A numpy array, pandas Series, pyarrow Array or pyarrow ChunkedArray of data. The data type of this column must match the keys of the colormap.</p> </li> <li> <code>cmap</code>             (<code>DiscreteColormap</code>)         \u2013          <p>A dictionary mapping keys to colors. See [DiscreteColormap] for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>alpha</code>             (<code>Optional[int]</code>)         \u2013          <p>The default alpha value for entries in the colormap that do not have an alpha value defined. Alpha must be an integer between 0 and 255 (inclusive).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[uint8]</code>         \u2013          <p>A two dimensional numpy array with data type np.uint8. The second dimension will have a length of either <code>3</code> if <code>alpha</code> is <code>None</code>, or <code>4</code> is each color has an alpha value.</p> </li> </ul>"},{"location":"api/map/","title":"Map","text":""},{"location":"api/map/#lonboard.Map","title":"lonboard.Map","text":"<p>The top-level class used to display a map in a Jupyter Widget.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer, SolidPolygonLayer\n\n# A GeoDataFrame with Point geometries\npoint_gdf = gpd.GeoDataFrame()\npoint_layer = ScatterplotLayer.from_geopandas(\n    point_gdf,\n    get_fill_color=[255, 0, 0],\n)\n\n# A GeoDataFrame with Polygon geometries\npolygon_gdf = gpd.GeoDataFrame()\npolygon_layer = SolidPolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\n\nmap_ = Map(layers=[point_layer, polygon_layer])\n</code></pre>"},{"location":"api/map/#lonboard.Map._height","title":"_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>_height = traitlets.Int(default_value=DEFAULT_HEIGHT, allow_none=True).tag(\n    sync=True\n)\n</code></pre> <p>Height of the map in pixels.</p> <p>This API is not yet stabilized and may change in the future.</p>"},{"location":"api/map/#lonboard.Map._initial_view_state","title":"_initial_view_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>_initial_view_state = traitlets.Dict().tag(sync=True)\n</code></pre> <p>The initial view state of the map.</p> <ul> <li>Type: <code>dict</code>, optional</li> <li>Default: Automatically inferred from the data passed to the map.</li> </ul> <p>The keys must include:</p> <ul> <li><code>longitude</code>: longitude at the map center.</li> <li><code>latitude</code>: latitude at the map center.</li> <li><code>zoom</code>: zoom level.</li> </ul> <p>Keys may additionally include:</p> <ul> <li><code>pitch</code> (float, optional) - pitch angle in degrees. Default <code>0</code> (top-down).</li> <li><code>bearing</code> (float, optional) - bearing angle in degrees. Default <code>0</code> (north).</li> <li><code>maxZoom</code> (float, optional) - max zoom level. Default <code>20</code>.</li> <li><code>minZoom</code> (float, optional) - min zoom level. Default <code>0</code>.</li> <li><code>maxPitch</code> (float, optional) - max pitch angle. Default <code>60</code>.</li> <li><code>minPitch</code> (float, optional) - min pitch angle. Default <code>0</code>.</li> </ul> <p>Note that currently no camel-case/snake-case translation occurs for this method, and so keys must be in camel case.</p> <p>This API is not yet stabilized and may change in the future.</p>"},{"location":"api/map/#lonboard.Map.basemap_style","title":"basemap_style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>basemap_style = traitlets.Unicode(CartoBasemap.PositronNoLabels).tag(sync=True)\n</code></pre> <p>A MapLibre-compatible basemap style.</p> <p>Various styles are provided in <code>lonboard.basemap</code>.</p> <ul> <li>Type: <code>str</code></li> <li>Default   <code>lonboard.basemap.CartoBasemap.PositronNoLabels</code></li> </ul>"},{"location":"api/map/#lonboard.Map.layers","title":"layers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers = traitlets.List(trait=traitlets.Instance(BaseLayer)).tag(\n    sync=True, **ipywidgets.widget_serialization\n)\n</code></pre> <p>One or more <code>Layer</code> objects to display on this map.</p>"},{"location":"api/map/#lonboard.Map.picking_radius","title":"picking_radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>picking_radius = traitlets.Int(5).tag(sync=True)\n</code></pre> <p>Extra pixels around the pointer to include while picking (such as for a tooltip).</p> <p>This is helpful when rendered objects are difficult to target, for example irregularly shaped icons, small moving circles or interaction by touch.</p> <ul> <li>Type: <code>int</code></li> <li>Default: <code>5</code></li> </ul>"},{"location":"api/map/#lonboard.Map.show_tooltip","title":"show_tooltip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_tooltip = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether to render a tooltip on hover on the map.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/map/#lonboard.Map.to_html","title":"to_html","text":"<pre><code>to_html(filename: Union[str, Path]) -&gt; None\n</code></pre> <p>Save the current map as a standalone HTML file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>Union[str, Path]</code>)         \u2013          <p>where to save the generated HTML file.</p> </li> </ul>"},{"location":"api/traits/","title":"lonboard.traits","text":""},{"location":"api/traits/#lonboard.traits.ColorAccessor","title":"lonboard.traits.ColorAccessor","text":"<p>             Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl color accessor.</p> <p>Various input is allowed:</p> <ul> <li>A <code>list</code> or <code>tuple</code> with three or four integers, ranging between 0 and 255   (inclusive). This will be used as the color for all objects.</li> <li>A <code>str</code> representing a hex color or \"well known\" color interpretable by   matplotlib.colors.to_rgba.</li> <li>A numpy <code>ndarray</code> with two dimensions and data type <code>np.uint8</code>. The   size of the second dimension must be <code>3</code> or <code>4</code>, and will correspond to either RGB   or RGBA colors.</li> <li>A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The inner   size of the fixed size list must be <code>3</code> or <code>4</code> and its child must have type   <code>uint8</code>.</li> </ul> <p>You can use helpers in the <code>lonboard.colormap</code> module (i.e. <code>apply_continuous_cmap</code>) to simplify constructing numpy arrays for color values.</p>"},{"location":"api/traits/#lonboard.traits.FloatAccessor","title":"lonboard.traits.FloatAccessor","text":"<p>             Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl float accessor.</p> <p>Various input is allowed:</p> <ul> <li>An <code>int</code> or <code>float</code>. This will be used as the value for all objects.</li> <li>A numpy <code>ndarray</code> with a numeric data type. This will be casted to an array of   data type <code>np.float32</code>. Each value in the array will be used as   the value for the object at the same row index.</li> <li>A pandas <code>Series</code> with a numeric data type. This will be casted to an array of   data type <code>np.float32</code>. Each value in the array will be used as   the value for the object at the same row index.</li> <li>A pyarrow <code>FloatArray</code>, <code>DoubleArray</code>   or <code>ChunkedArray</code> containing either a <code>FloatArray</code> or   <code>DoubleArray</code>. Each value in the array will be used as the value for the object at   the same row index.</li> </ul>"},{"location":"api/viz/","title":"viz","text":"<p>The top-level namespace accessible after <code>import lonboard</code>.</p> <p>Layers are also accessible in the top-level namespace, but are documented in the <code>layers/</code> folder.</p>"},{"location":"api/viz/#lonboard.viz","title":"lonboard.viz","text":"<pre><code>viz(\n    data: Union[VizDataInput, List[VizDataInput], Tuple[VizDataInput, ...]],\n    **kwargs\n) -&gt; Map\n</code></pre> <p>A high-level function to plot your data easily.</p> <p>The goal of this function is to make it simple to get something showing on a map. For more control over rendering, construct <code>Map</code> and <code>Layer</code> objects directly.</p> <p>This function accepts a variety of geospatial inputs:</p> <ul> <li>geopandas <code>GeoDataFrame</code></li> <li>geopandas <code>GeoSeries</code></li> <li>numpy array of Shapely objects</li> <li>Single Shapely object</li> <li>Any Python class with a <code>__geo_interface__</code> property conforming to the     Geo Interface protocol.</li> <li><code>dict</code> holding GeoJSON-like data.</li> <li>pyarrow <code>Table</code> with a geometry column marked with a GeoArrow extension type</li> </ul> <p>Alternatively, you can pass a <code>list</code> or <code>tuple</code> of any of the above inputs.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>Union[VizDataInput, List[VizDataInput], Tuple[VizDataInput, ...]]</code>)         \u2013          <p>a data object of any supported type.</p> </li> </ul> Named args <p>Any other keyword arguments will be passed onto the relevant layer, either a <code>ScatterplotLayer</code>, <code>PathLayer</code>, or <code>SolidPolygonLayer</code>.</p> <p>If you pass a <code>list</code> or <code>tuple</code> of data objects, <code>kwargs</code> will be passed to all layers. For more control over rendering, construct <code>Map</code> and <code>Layer</code> objects directly.</p> <p>Returns:</p> <ul> <li> <code>Map</code>         \u2013          <p>widget visualizing the provided data.</p> </li> </ul>"},{"location":"api/viz/#lonboard._viz.VizDataInput","title":"VizDataInput  <code>module-attribute</code>","text":"<pre><code>VizDataInput = Union[\n    gpd.GeoDataFrame,\n    gpd.GeoSeries,\n    pa.Table,\n    NDArray[np.object_],\n    shapely.geometry.base.BaseGeometry,\n    GeoInterfaceProtocol,\n    Dict[str, Any],\n]\n</code></pre> <p>A type definition for allowed data inputs to the <code>viz</code> function.</p>"},{"location":"api/experimental/traits/","title":"lonboard.experimental.traits","text":""},{"location":"api/experimental/traits/#lonboard.experimental.traits.PointAccessor","title":"lonboard.experimental.traits.PointAccessor","text":"<p>             Bases: <code>FixedErrorTraitType</code></p> <p>A representation of a deck.gl point accessor.</p> <p>Various input is allowed:</p> <ul> <li>A numpy <code>ndarray</code> with two dimensions and data type <code>np.uint8</code>. The   size of the second dimension must be <code>2</code> or <code>3</code>, and will correspond to either XY   or XYZ positions.</li> <li>A pyarrow <code>FixedSizeListArray</code> or   <code>ChunkedArray</code> containing <code>FixedSizeListArray</code>s. The inner   size of the fixed size list must be <code>2</code> or <code>3</code> and its child must be of floating   point type.</li> </ul>"},{"location":"api/layer-extensions/brushing-extension/","title":"BrushingExtension","text":""},{"location":"api/layer-extensions/brushing-extension/#lonboard.experimental.BrushingExtension","title":"lonboard.experimental.BrushingExtension","text":"<p>Adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position.</p>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.experimental.BrushingExtension.brushing_enabled","title":"brushing_enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>brushing_enabled = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Enable/disable brushing. If brushing is disabled, all objects are rendered.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.experimental.BrushingExtension.brushing_radius","title":"brushing_radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>brushing_radius = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The brushing radius centered at the pointer, in meters. If a data object is within this circle, it is rendered; otherwise it is hidden.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>10000</code></li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.experimental.BrushingExtension.brushing_target","title":"brushing_target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>brushing_target = traitlets.Unicode('source', allow_none=True).tag(sync=True)\n</code></pre> <p>The position used to filter each object by.</p> <ul> <li> <p>Type: <code>str</code>, optional</p> <p>One of: 'source' | 'target' | 'source_target' | 'custom'</p> </li> <li> <p>Default: <code>10000</code></p> </li> </ul>"},{"location":"api/layer-extensions/brushing-extension/#lonboard.experimental.BrushingExtension.get_brushing_target","title":"get_brushing_target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_brushing_target = traitlets.Any(allow_none=True).tag(sync=True)\n</code></pre> <p>Called to retrieve an arbitrary position for each object that it will be filtered by.</p> <p>Only effective if <code>brushingTarget</code> is set to <code>\"custom\"</code>.</p>"},{"location":"api/layer-extensions/collision-filter-extension/","title":"CollisionFilterExtension","text":""},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.experimental.CollisionFilterExtension","title":"lonboard.experimental.CollisionFilterExtension","text":"<p>Allows layers to hide overlapping objects.</p>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.experimental.CollisionFilterExtension.collision_enabled","title":"collision_enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>collision_enabled = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Enable/disable collisions. If collisions are disabled, all objects are rendered.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.experimental.CollisionFilterExtension.collision_group","title":"collision_group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>collision_group = traitlets.Unicode().tag(sync=True)\n</code></pre> <p>Collision group this layer belongs to. If it is not set, the 'default' collision group is used</p> <ul> <li>Type: <code>string</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layer-extensions/collision-filter-extension/#lonboard.experimental.CollisionFilterExtension.get_collision_priority","title":"get_collision_priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_collision_priority = FloatAccessor(allow_none=True)\n</code></pre> <p>Accessor for collision priority. Must return a number in the range -1000 -&gt; 1000. Features with higher values are shown preferentially.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the priority for all objects.</li> <li>If an array is provided, each value in the array will be used as the priority   for the object at the same row index.</li> </ul> </li> <li>Default: <code>0</code>.</li> </ul>"},{"location":"api/layers/arc-layer/","title":"ArcLayer","text":""},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer","title":"lonboard.experimental.ArcLayer","text":"<p>Render raised arcs joining pairs of source and target coordinates.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_height","title":"get_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_height = FloatAccessor()\n</code></pre> <p>Height color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_source_color","title":"get_source_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_source_color = ColorAccessor()\n</code></pre> <p>Source color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_source_position","title":"get_source_position  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_source_position = PointAccessor()\n</code></pre> <p>Source position of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_target_color","title":"get_target_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_target_color = ColorAccessor()\n</code></pre> <p>Target color of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_target_position","title":"get_target_position  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_target_position = PointAccessor()\n</code></pre> <p>Target position of each object</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_tilt","title":"get_tilt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_tilt = FloatAccessor()\n</code></pre> <p>Use to tilt the arc to the side if you have multiple arcs with the same source and target positions.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>0</code>.</li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.get_width","title":"get_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_width = FloatAccessor()\n</code></pre> <p>The line width of each object, in units specified by <code>widthUnits</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.great_circle","title":"great_circle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>great_circle = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>If <code>True</code>, create the arc along the shortest path on the earth surface.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.num_segments","title":"num_segments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_segments = traitlets.Int(allow_none=True).tag(sync=True)\n</code></pre> <p>The number of segments used to draw each arc.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>50</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_max_pixels","title":"width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_max_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The maximum line width in pixels.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_min_pixels","title":"width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_min_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The minimum line width in pixels.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_scale","title":"width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_scale = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The scaling multiplier for the width of each line.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.width_units","title":"width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_units = traitlets.Unicode(allow_none=True).tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'pixels'</code></li> </ul>"},{"location":"api/layers/arc-layer/#lonboard.experimental.ArcLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/heatmap-layer/","title":"HeatmapLayer","text":""},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer","title":"lonboard.HeatmapLayer","text":"<p>The <code>HeatmapLayer</code> visualizes the spatial distribution of data.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, HeatmapLayer\n\n# A GeoDataFrame with Point geometries\ngdf = gpd.GeoDataFrame()\nlayer = HeatmapLayer.from_geopandas(gdf,)\nmap_ = Map(layers=[layer])\n</code></pre>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.aggregation","title":"aggregation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aggregation = traitlets.Unicode(allow_none=True).tag(sync=True)\n</code></pre> <p>Defines the type of aggregation operation</p> <p>Valid values are 'SUM', 'MEAN'.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>\"SUM\"</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.debounce_timeout","title":"debounce_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debounce_timeout = traitlets.Int(allow_none=True).tag(sync=True)\n</code></pre> <p>Interval in milliseconds during which changes to the viewport don't trigger aggregation.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>500</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.get_weight","title":"get_weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_weight = FloatAccessor()\n</code></pre> <p>The weight of each object.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the outline width for all objects.</li> <li>If an array is provided, each value in the array will be used as the outline   width for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>intensity = traitlets.Float(allow_none=True).tag(sync=True)\n</code></pre> <p>Value that is multiplied with the total weight at a pixel to obtain the final weight.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.radius_pixels","title":"radius_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_pixels = traitlets.Float(allow_none=True).tag(sync=True)\n</code></pre> <p>Radius of the circle in pixels, to which the weight of an object is distributed.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>30</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.threshold","title":"threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>threshold = traitlets.Float(allow_none=True, min=0, max=1).tag(sync=True)\n</code></pre> <p>Ratio of the fading weight to the max weight, between <code>0</code> and <code>1</code>.</p> <p>For example, <code>0.1</code> affects all pixels with weight under 10% of the max.</p> <p>Ignored when <code>color_domain</code> is specified.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0.05</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.weights_texture_size","title":"weights_texture_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights_texture_size = traitlets.Int(allow_none=True).tag(sync=True)\n</code></pre> <p>Specifies the size of weight texture.</p> <ul> <li>Type: <code>int</code>, optional</li> <li>Default: <code>2048</code></li> </ul>"},{"location":"api/layers/heatmap-layer/#lonboard.HeatmapLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/path-layer/","title":"PathLayer","text":"<p>Screenshot from North America roads example</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer","title":"lonboard.PathLayer","text":"<p>The <code>PathLayer</code> renders lists of coordinate points as extruded polylines with mitering.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, PathLayer\n\n# A GeoDataFrame with LineString geometries\ngdf = gpd.GeoDataFrame()\nlayer = PathLayer.from_geopandas(\n    gdf,\n    get_color=[255, 0, 0],\n    width_min_pixels=2,\n)\nmap_ = Map(layers=[layer])\n</code></pre>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>If <code>True</code>, extrude the path in screen space (width always faces the camera). If <code>False</code>, the width always faces up.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.cap_rounded","title":"cap_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cap_rounded = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Type of caps. If <code>True</code>, draw round caps. Otherwise draw square caps.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor()\n</code></pre> <p>The color of each path in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the color for all   paths.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the color for the path at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.get_width","title":"get_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_width = FloatAccessor()\n</code></pre> <p>The width of each path, in units specified by <code>width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all paths.</li> <li>If an array is provided, each value in the array will be used as the width for   the path at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.joint_rounded","title":"joint_rounded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>joint_rounded = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Type of joint. If <code>True</code>, draw round joints. Otherwise draw miter joints.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.miter_limit","title":"miter_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>miter_limit = traitlets.Int(allow_none=True).tag(sync=True)\n</code></pre> <p>The maximum extent of a joint in ratio to the stroke width. Only works if <code>jointRounded</code> is <code>False</code>.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>4</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_max_pixels","title":"width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_max_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_min_pixels","title":"width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_min_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_scale","title":"width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_scale = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The path width multiplier that multiplied to all paths.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.width_units","title":"width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width_units = traitlets.Unicode(allow_none=True).tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/path-layer/#lonboard.PathLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/scatterplot-layer/","title":"ScatterplotLayer","text":"<p>Screenshot from Ookla example.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer","title":"lonboard.ScatterplotLayer","text":"<p>The <code>ScatterplotLayer</code> renders circles at given coordinates.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, ScatterplotLayer\n\n# A GeoDataFrame with Point geometries\ngdf = gpd.GeoDataFrame()\nlayer = ScatterplotLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\nmap_ = Map(layers=[layer])\n</code></pre>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.antialiasing","title":"antialiasing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>antialiasing = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>If <code>True</code>, circles are rendered with smoothed edges. If <code>False</code>, circles are rendered with rough edges. Antialiasing can cause artifacts on edges of overlapping circles.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>If <code>True</code>, rendered circles always face the camera. If <code>False</code> circles face up (i.e. are parallel with the ground plane).</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Draw the filled area of points.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor()\n</code></pre> <p>The filled color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the filled color for   all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the filled color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor()\n</code></pre> <p>The outline color of each object in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the outline color   for all objects.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the outline color for the object at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_line_width","title":"get_line_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_width = FloatAccessor()\n</code></pre> <p>The width of the outline of each object, in units specified by <code>line_width_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the outline width for all objects.</li> <li>If an array is provided, each value in the array will be used as the outline   width for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.get_radius","title":"get_radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_radius = FloatAccessor()\n</code></pre> <p>The radius of each object, in units specified by <code>radius_units</code> (default <code>'meters'</code>).</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the radius for all objects.</li> <li>If an array is provided, each value in the array will be used as the radius   for the object at the same row index.</li> </ul> </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_max_pixels","title":"line_width_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_max_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The maximum line width in pixels. This can be used to prevent the stroke from getting too thick when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_min_pixels","title":"line_width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_min_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The minimum line width in pixels. This can be used to prevent the stroke from getting too thin when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_scale","title":"line_width_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_scale = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>A global line width multiplier for all points.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.line_width_units","title":"line_width_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_units = traitlets.Unicode('meters', allow_none=True).tag(sync=True)\n</code></pre> <p>The units of the line width, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_max_pixels","title":"radius_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_max_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The maximum radius in pixels. This can be used to prevent the circle from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_min_pixels","title":"radius_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_min_pixels = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>The minimum radius in pixels. This can be used to prevent the circle from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_scale","title":"radius_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_scale = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>A global radius multiplier for all points.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.radius_units","title":"radius_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_units = traitlets.Unicode('meters', allow_none=True).tag(sync=True)\n</code></pre> <p>The units of the radius, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'meters'</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.stroked","title":"stroked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stroked = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Draw the outline of points.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/scatterplot-layer/#lonboard.ScatterplotLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/solid-polygon-layer/","title":"SolidPolygonLayer","text":""},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer","title":"lonboard.SolidPolygonLayer","text":"<p>The <code>SolidPolygonLayer</code> renders filled and/or extruded polygons.</p> <p>Example:</p> <pre><code>import geopandas as gpd\nfrom lonboard import Map, SolidPolygonLayer\n\n# A GeoDataFrame with Polygon geometries\ngdf = gpd.GeoDataFrame()\nlayer = SolidPolygonLayer.from_geopandas(\n    gdf,\n    get_fill_color=[255, 0, 0],\n)\nmap_ = Map(layers=[layer])\n</code></pre>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.elevation_scale","title":"elevation_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elevation_scale = traitlets.Float(allow_none=True, min=0).tag(sync=True)\n</code></pre> <p>Elevation multiplier. The final elevation is calculated by <code>elevation_scale * get_elevation(d)</code>. <code>elevation_scale</code> is a handy property to scale all elevation without updating the data.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>1</code></li> </ul> <p>Remarks:</p> <ul> <li>These lines are rendered with <code>GL.LINE</code> and will thus always be 1 pixel wide.</li> <li>Wireframe and solid extrusions are exclusive, you'll need to create two layers   with the same data if you want a combined rendering effect.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.extruded","title":"extruded  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extruded = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Whether to extrude the polygons (based on the elevations provided by the <code>get_elevation</code> accessor'). If set to <code>False</code>, all polygons will be flat, this generates less geometry and is faster than simply returning <code>0</code> from <code>get_elevation</code>.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Whether to fill the polygons (based on the color provided by the <code>get_fill_color</code> accessor).</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_elevation","title":"get_elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_elevation = FloatAccessor()\n</code></pre> <p>The elevation to extrude each polygon with, in meters.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: FloatAccessor, optional<ul> <li>If a number is provided, it is used as the width for all polygons.</li> <li>If an array is provided, each value in the array will be used as the width for   the polygon at the same row index.</li> </ul> </li> <li>Default: <code>1000</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_fill_color","title":"get_fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_fill_color = ColorAccessor()\n</code></pre> <p>The fill color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the fill color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the fill color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.get_line_color","title":"get_line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_line_color = ColorAccessor()\n</code></pre> <p>The line color of each polygon in the format of <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <p>Only applies if <code>extruded=True</code>.</p> <ul> <li>Type: ColorAccessor, optional<ul> <li>If a single <code>list</code> or <code>tuple</code> is provided, it is used as the line color for   all polygons.</li> <li>If a numpy or pyarrow array is provided, each value in the array will be used   as the line color for the polygon at the same row index.</li> </ul> </li> <li>Default: <code>[0, 0, 0, 255]</code>.</li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.wireframe","title":"wireframe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wireframe = traitlets.Bool(allow_none=True).tag(sync=True)\n</code></pre> <p>Whether to generate a line wireframe of the polygon. The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical line (a \"strut\") for each vertex on the polygon.</p> <ul> <li>Type: <code>bool</code>, optional</li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/solid-polygon-layer/#lonboard.SolidPolygonLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"api/layers/text-layer/","title":"TextLayer","text":""},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer","title":"lonboard.experimental.TextLayer","text":"<p>Render text labels at given coordinates.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.auto_highlight","title":"auto_highlight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_highlight = traitlets.Bool(False).tag(sync=True)\n</code></pre> <p>When true, the current object pointed to by the mouse pointer (when hovered over) is highlighted with <code>highlightColor</code>.</p> <p>Requires <code>pickable</code> to be <code>True</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>False</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.background_padding","title":"background_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>background_padding = traitlets.Any().tag(sync=True)\n</code></pre> <p>The padding of the background.</p> <ul> <li>If an array of 2 is supplied, it is interpreted as <code>[padding_x, padding_y]</code> in   pixels.</li> <li>If an array of 4 is supplied, it is interpreted as <code>[padding_left, padding_top,   padding_right, padding_bottom]</code> in pixels.</li> </ul> <p>default [0, 0, 0, 0]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.billboard","title":"billboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>billboard = traitlets.Bool().tag(sync=True)\n</code></pre> <p>If <code>true</code>, the text always faces camera. Otherwise the text faces up (z).</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.character_set","title":"character_set  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>character_set = traitlets.Any().tag(sync=True)\n</code></pre> <p>Specifies a list of characters to include in the font. If set to 'auto', will be automatically generated from the data set.</p> <p>default (ASCII characters 32-128)</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_family","title":"font_family  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_family = traitlets.Any().tag(sync=True)\n</code></pre> <p>CSS font family</p> <p>default 'Monaco, monospace'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_settings","title":"font_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_settings = traitlets.Any().tag(sync=True)\n</code></pre> <p>Advance options for fine tuning the appearance and performance of the generated shared <code>fontAtlas</code>.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.font_weight","title":"font_weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>font_weight = traitlets.Any().tag(sync=True)\n</code></pre> <p>CSS font weight</p> <p>default 'normal'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_alignment_baseline","title":"get_alignment_baseline  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_alignment_baseline = traitlets.Any().tag(sync=True)\n</code></pre> <p>Vertical alignment accessor</p> <p>default 'center'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_angle","title":"get_angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_angle = FloatAccessor()\n</code></pre> <p>Label rotation accessor, in degrees</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_background_color","title":"get_background_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_background_color = ColorAccessor()\n</code></pre> <p>Background color accessor.</p> <p>default [255, 255, 255, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_border_color","title":"get_border_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_border_color = ColorAccessor()\n</code></pre> <p>Border color accessor.</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_border_width","title":"get_border_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_border_width = FloatAccessor()\n</code></pre> <p>Border width accessor.</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_color","title":"get_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_color = ColorAccessor()\n</code></pre> <p>Label color accessor</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_pixel_offset","title":"get_pixel_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_pixel_offset = traitlets.Any().tag(sync=True)\n</code></pre> <p>Label offset from the anchor position, [x, y] in pixels</p> <p>default [0, 0]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_size","title":"get_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_size = FloatAccessor()\n</code></pre> <p>Label size accessor</p> <p>default 32</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_text","title":"get_text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_text = TextAccessor()\n</code></pre> <p>Label text accessor</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.get_text_anchor","title":"get_text_anchor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_text_anchor = traitlets.Any().tag(sync=True)\n</code></pre> <p>Horizontal alignment accessor</p> <p>default 'middle'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.line_height","title":"line_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_height = traitlets.Any().tag(sync=True)\n</code></pre> <p>A unitless number that will be multiplied with the current text size to set the line height.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.max_width","title":"max_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_width = traitlets.Any().tag(sync=True)\n</code></pre> <p>A unitless number that will be multiplied with the current text size to set the width limit of a string.</p> <p>If specified, when the text is longer than the width limit, it will be wrapped into multiple lines using the strategy of <code>wordBreak</code>.</p> <p>default -1</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity = traitlets.Float(1, min=0, max=1).tag(sync=True)\n</code></pre> <p>The opacity of the layer.</p> <ul> <li>Type: <code>float</code>. Must range between 0 and 1.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.outline_color","title":"outline_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outline_color = traitlets.Any().tag(sync=True)\n</code></pre> <p>Color of outline around the text, in <code>[r, g, b, [a]]</code>. Each channel is a number between 0-255 and <code>a</code> is 255 if not supplied.</p> <p>default [0, 0, 0, 255]</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.outline_width","title":"outline_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outline_width = traitlets.Any().tag(sync=True)\n</code></pre> <p>Width of outline around the text, relative to the text size. Only effective if <code>fontSettings.sdf</code> is <code>true</code>.</p> <p>default 0</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer responds to mouse pointer picking events.</p> <p>This must be set to <code>True</code> for tooltips and other interactive elements to be available. This can also be used to only allow picking on specific layers within a map instance.</p> <p>Note that picking has some performance overhead in rendering. To get the absolute best rendering performance with large data (at the cost of removing interactivity), set this to <code>False</code>.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.selected_index","title":"selected_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_index = traitlets.Int(None, allow_none=True).tag(sync=True)\n</code></pre> <p>The positional index of the most-recently clicked on row of data.</p> <p>You can use this to access the full row of data from a GeoDataFrame</p> <pre><code>gdf.iloc[layer.selected_index]\n</code></pre> <p>Setting a value here from Python will do nothing. This attribute only exists to be updated from JavaScript on a map click. Note that <code>pickable</code> must be <code>True</code> (the default) on this layer for the JavaScript <code>onClick</code> handler to work; if <code>pickable</code> is set to <code>False</code>, <code>selected_index</code> will never update.</p> <p>Note that you can use <code>observe</code> to call a function whenever a new value is received from JavaScript. Refer here for an example.</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_max_pixels","title":"size_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_max_pixels = traitlets.Any().tag(sync=True)\n</code></pre> <p>The maximum size in pixels. When using non-pixel <code>sizeUnits</code>, this prop can be used to prevent the icon from getting too big when zoomed in.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>None</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_min_pixels","title":"size_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_min_pixels = traitlets.Any().tag(sync=True)\n</code></pre> <p>The minimum size in pixels. When using non-pixel <code>sizeUnits</code>, this prop can be used to prevent the icon from getting too small when zoomed out.</p> <ul> <li>Type: <code>float</code>, optional</li> <li>Default: <code>0</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_scale","title":"size_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_scale = traitlets.Any().tag(sync=True)\n</code></pre> <p>Text size multiplier.</p> <ul> <li>Type: <code>float</code>.</li> <li>Default: <code>1</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.size_units","title":"size_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size_units = traitlets.Any().tag(sync=True)\n</code></pre> <p>The units of the size, one of <code>'meters'</code>, <code>'common'</code>, and <code>'pixels'</code>. default 'pixels'. See unit system.</p> <ul> <li>Type: <code>str</code>, optional</li> <li>Default: <code>'pixels'</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.visible","title":"visible  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible = traitlets.Bool(True).tag(sync=True)\n</code></pre> <p>Whether the layer is visible.</p> <p>Under most circumstances, using the <code>visible</code> attribute to control the visibility of layers is recommended over removing/adding the layer from the <code>Map.layers</code> list.</p> <p>In particular, toggling the <code>visible</code> attribute will persist the layer on the JavaScript side, while removing/adding the layer from the <code>Map.layers</code> list will re-download and re-render from scratch.</p> <ul> <li>Type: <code>bool</code></li> <li>Default: <code>True</code></li> </ul>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.word_break","title":"word_break  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>word_break = traitlets.Any().tag(sync=True)\n</code></pre> <p>Available options are <code>break-all</code> and <code>break-word</code>. A valid <code>maxWidth</code> has to be provided to use <code>wordBreak</code>.</p> <p>default 'break-word'</p>"},{"location":"api/layers/text-layer/#lonboard.experimental.TextLayer.from_geopandas","title":"from_geopandas  <code>classmethod</code>","text":"<pre><code>from_geopandas(\n    gdf: gpd.GeoDataFrame, *, auto_downcast: bool = True, **kwargs\n) -&gt; Self\n</code></pre> <p>Construct a Layer from a geopandas GeoDataFrame.</p> <p>The GeoDataFrame will be reprojected to EPSG:4326 if it is not already in that coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>gdf</code>             (<code>GeoDataFrame</code>)         \u2013          <p>The GeoDataFrame to set on the layer.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>auto_downcast</code>             (<code>bool</code>)         \u2013          <p>If <code>True</code>, automatically downcast to smaller-size data types if possible without loss of precision. This calls pandas.DataFrame.convert_dtypes and pandas.to_numeric under the hood.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A Layer with the initialized data.</p> </li> </ul>"},{"location":"examples/internet-speeds/","title":"Speedtest Data from Ookla","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom palettable.colorbrewer.diverging import BrBG_10\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd import numpy as np import pandas as pd import shapely from palettable.colorbrewer.diverging import BrBG_10  from lonboard import Map, ScatterplotLayer from lonboard.colormap import apply_continuous_cmap <p>The URL for a single data file for mobile network speeds in the first quarter of 2019.</p> In\u00a0[2]: Copied! <pre>url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\"\n</pre> url = \"https://ookla-open-data.s3.us-west-2.amazonaws.com/parquet/performance/type=mobile/year=2019/quarter=1/2019-01-01_performance_mobile_tiles.parquet\" <p>We can fetch two columns from this data file directly from AWS. This <code>pd.read_parquet</code> command will perform a network request for the data file, so it may take a while on a slow network connection.</p> In\u00a0[3]: Copied! <pre># avg_d_kbps is the average download speed for that data point in kilobits per second\n# tile is the WKT string representing a given zoom-16 Web Mercator tile\ncolumns = [\"avg_d_kbps\", \"tile\"]\n</pre> # avg_d_kbps is the average download speed for that data point in kilobits per second # tile is the WKT string representing a given zoom-16 Web Mercator tile columns = [\"avg_d_kbps\", \"tile\"] In\u00a0[4]: Copied! <pre>df = pd.read_parquet(url, columns=columns)\n</pre> df = pd.read_parquet(url, columns=columns) <p>We can take a quick look at this data:</p> In\u00a0[5]: Copied! <pre>df.head()\n</pre> df.head() Out[5]: avg_d_kbps tile 0 5983 POLYGON((-160.021362304688 70.6381267305321, -... 1 3748 POLYGON((-160.043334960938 70.6344840663086, -... 2 3364 POLYGON((-160.043334960938 70.6326624870732, -... 3 2381 POLYGON((-160.037841796875 70.6344840663086, -... 4 3047 POLYGON((-160.037841796875 70.6326624870732, -... <p>The <code>tile</code> column contains strings representing geometries. We need to parse those strings into geometries. Then for simplicity we'll convert into their centroids.</p> In\u00a0[6]: Copied! <pre>tile_geometries = shapely.from_wkt(df[\"tile\"])\ntile_centroids = shapely.centroid(tile_geometries)\n</pre> tile_geometries = shapely.from_wkt(df[\"tile\"]) tile_centroids = shapely.centroid(tile_geometries) <p>Now we can create a geopandas GeoDataFrame from the download speed and the shapely geometries.</p> In\u00a0[7]: Copied! <pre>gdf = gpd.GeoDataFrame(df[[\"avg_d_kbps\"]], geometry=tile_centroids)\n</pre> gdf = gpd.GeoDataFrame(df[[\"avg_d_kbps\"]], geometry=tile_centroids) <p>To ensure that this demo is snappy on most computers, we'll filter to a bounding box over Europe.</p> In\u00a0[8]: Copied! <pre>gdf = gdf.cx[-11.83:25.5, 34.9:59]\n</pre> gdf = gdf.cx[-11.83:25.5, 34.9:59] <p>Even this filtered data frame still has 800,000 rows, so it's still a lot of data to explore:</p> In\u00a0[9]: Copied! <pre>gdf\n</pre> gdf Out[9]: avg_d_kbps geometry 383429 13570 POINT (-2.94159 58.99673) 383430 18108 POINT (-3.29865 58.96276) 383431 5569 POINT (-3.29315 58.97125) 383432 9349 POINT (-3.29315 58.96842) 383433 11216 POINT (-3.23273 58.98541) ... ... ... 1840929 104723 POINT (25.38666 35.09519) 1840930 62540 POINT (25.44708 35.04124) 1840931 88068 POINT (25.47455 35.04124) 1840938 38255 POINT (25.38116 35.00075) 1840939 91750 POINT (25.45807 34.99175) <p>807221 rows \u00d7 2 columns</p> <p>To render point data, first create a <code>ScatterplotLayer</code> and then add it to a <code>Map</code> object:</p> In\u00a0[10]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nmap_ = Map(layers=[layer])\nmap_\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) map_ = Map(layers=[layer]) map_ Out[10]: <pre>Map(layers=[ScatterplotLayer(table=pyarrow.Table\navg_d_kbps: int64\n__index_level_0__: int64\ngeometry: fixed_si\u2026</pre> <p>We can look at the documentation for <code>ScatterplotLayer</code> to see what other rendering options it allows. Let's set the fill color to something other than black:</p> In\u00a0[11]: Copied! <pre>layer.get_fill_color = [0, 0, 200, 200]\n</pre> layer.get_fill_color = [0, 0, 200, 200] <p>Blue is pretty, but the map would be more informative if we colored each point by a relevant characteristic. In this case, we have the download speed associated with each location, so let's use that!</p> <p>Here we compute a linear statistic for the download speed. Given a minimum bound of <code>5000</code> and a maximum bound of <code>50,000</code> the normalized speed is linearly scaled to between 0 and 1.</p> In\u00a0[12]: Copied! <pre>min_bound = 5000\nmax_bound = 50000\ndownload_speed = gdf['avg_d_kbps']\nnormalized_download_speed = (download_speed - min_bound) / (max_bound - min_bound)\n</pre> min_bound = 5000 max_bound = 50000 download_speed = gdf['avg_d_kbps'] normalized_download_speed = (download_speed - min_bound) / (max_bound - min_bound) <p><code>normalized_download_speed</code> is now linearly scaled based on the bounds provided above. Keep in mind that the input range of the colormap is 0-1. So any values that are below 0 will receive the left-most color in the colormap, while any values above 1 will receive the right-most color in the colormap.</p> In\u00a0[13]: Copied! <pre>normalized_download_speed\n</pre> normalized_download_speed Out[13]: <pre>383429     0.190444\n383430     0.291289\n383431     0.012644\n383432     0.096644\n383433     0.138133\n             ...   \n1840929    2.216067\n1840930    1.278667\n1840931    1.845956\n1840938    0.739000\n1840939    1.927778\nName: avg_d_kbps, Length: 807221, dtype: float64</pre> <p>We can use any colormap provided by the <code>palettable</code> package. Let's inspect the <code>BrBG_10</code> diverging colormap below:</p> In\u00a0[14]: Copied! <pre>BrBG_10.mpl_colormap\n</pre> BrBG_10.mpl_colormap Out[14]: BrBG  underbad over  <p>Now let's apply the colormap on <code>normalized_download_speed</code> using a helper provided by <code>lonboard</code>. We can set it on <code>layer.get_fill_color</code> to update the existing colors.</p> In\u00a0[15]: Copied! <pre>layer.get_fill_color = apply_continuous_cmap(normalized_download_speed, BrBG_10)\n</pre> layer.get_fill_color = apply_continuous_cmap(normalized_download_speed, BrBG_10) <p>After running the above cell, you should see the map above update with a different color per point!</p> <p>We can pass an array into any of the \"accessors\" supported by the layer (this is any attribute that starts with <code>get_*</code>).</p> <p>For demonstration purposes, let's also set <code>get_radius</code> to <code>normalized_download_speed</code>.</p> In\u00a0[16]: Copied! <pre># for now, cast to a numpy array until the layer is updated to support pandas series\nlayer.get_radius = np.array(normalized_download_speed) * 200\nlayer.radius_units = \"meters\"\nlayer.radius_min_pixels = 0.5\n</pre> # for now, cast to a numpy array until the layer is updated to support pandas series layer.get_radius = np.array(normalized_download_speed) * 200 layer.radius_units = \"meters\" layer.radius_min_pixels = 0.5 <p>After running the above cell, you should see the map updated to have a different radius per point!</p>"},{"location":"examples/internet-speeds/#speedtest-data-from-ookla","title":"Speedtest Data from Ookla\u00b6","text":"<p>This example will use data collected from Ookla's Speed Test application and shared publicly in the AWS Open Data Registry. From the AWS page:</p> <p>Global fixed broadband and mobile (cellular) network performance, allocated to zoom level 16 web mercator tiles (approximately 610.8 meters by 610.8 meters at the equator). Data is provided in both Shapefile format as well as Apache Parquet with geometries represented in Well Known Text (WKT) projected in EPSG:4326. Download speed, upload speed, and latency are collected via the Speedtest by Ookla applications for Android and iOS and averaged for each tile.</p>"},{"location":"examples/internet-speeds/#imports","title":"Imports\u00b6","text":""},{"location":"examples/migration/","title":"U.S. County-to-County Migration","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport pyarrow as pa\nimport requests\nimport shapely\nfrom matplotlib.colors import Normalize\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.experimental import ArcLayer, BrushingExtension\n</pre> import geopandas as gpd import numpy as np import pandas as pd import pyarrow as pa import requests import shapely from matplotlib.colors import Normalize  from lonboard import Map, ScatterplotLayer from lonboard.experimental import ArcLayer, BrushingExtension <p>Fetch the data from the version in the <code>deck.gl-data</code> repository.</p> In\u00a0[2]: Copied! <pre>url = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/arc/counties.json\"\nr = requests.get(url)\nsource_data = r.json()\n</pre> url = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/arc/counties.json\" r = requests.get(url) source_data = r.json() <p>The following cell may be a little hard to follow, but what it's doing is taking the raw data, which represents a graph) of the data and normalizing it to a table structure where each row represents one \"arc\" between a source and target county.</p> <p>This is ported from the original JavaScript here.</p> In\u00a0[3]: Copied! <pre>arcs = []\ntargets = []\nsources = []\npairs = {}\n\nfeatures = source_data[\"features\"]\nfor i, county in enumerate(features):\n    flows = county[\"properties\"][\"flows\"]\n    target_centroid = county[\"properties\"][\"centroid\"]\n    total_value = {\n        \"gain\": 0,\n        \"loss\": 0,\n    }\n\n    for to_id, value in flows.items():\n        if value &gt; 0:\n            total_value[\"gain\"] += value\n        else:\n            total_value[\"loss\"] += value\n\n        # If number is too small, ignore it\n        if abs(value) &lt; 50:\n            continue\n\n        pair_key = \"-\".join(map(str, sorted([i, int(to_id)])))\n        source_centroid = features[int(to_id)][\"properties\"][\"centroid\"]\n        gain = np.sign(flows[to_id])\n\n        # add point at arc source\n        sources.append(\n            {\n                \"position\": source_centroid,\n                \"target\": target_centroid,\n                \"name\": features[int(to_id)][\"properties\"][\"name\"],\n                \"radius\": 3,\n                \"gain\": -gain,\n            }\n        )\n        # eliminate duplicate arcs\n        if pair_key in pairs.keys():\n            continue\n\n        pairs[pair_key] = True\n\n        if gain &gt; 0:\n            arcs.append(\n                {\n                    \"target\": target_centroid,\n                    \"source\": source_centroid,\n                    \"value\": flows[to_id],\n                }\n            )\n        else:\n            arcs.append(\n                {\n                    \"target\": source_centroid,\n                    \"source\": target_centroid,\n                    \"value\": flows[to_id],\n                }\n            )\n\n    # add point at arc target\n    targets.append(\n        {\n            **total_value,\n            \"position\": [target_centroid[0], target_centroid[1], 10],\n            \"net\": total_value[\"gain\"] + total_value[\"loss\"],\n            \"name\": county[\"properties\"][\"name\"],\n        }\n    )\n\n# sort targets by radius large -&gt; small\ntargets = sorted(targets, key=lambda d: abs(d[\"net\"]), reverse=True)\nnormalizer = Normalize(0, abs(targets[0][\"net\"]))\n</pre> arcs = [] targets = [] sources = [] pairs = {}  features = source_data[\"features\"] for i, county in enumerate(features):     flows = county[\"properties\"][\"flows\"]     target_centroid = county[\"properties\"][\"centroid\"]     total_value = {         \"gain\": 0,         \"loss\": 0,     }      for to_id, value in flows.items():         if value &gt; 0:             total_value[\"gain\"] += value         else:             total_value[\"loss\"] += value          # If number is too small, ignore it         if abs(value) &lt; 50:             continue          pair_key = \"-\".join(map(str, sorted([i, int(to_id)])))         source_centroid = features[int(to_id)][\"properties\"][\"centroid\"]         gain = np.sign(flows[to_id])          # add point at arc source         sources.append(             {                 \"position\": source_centroid,                 \"target\": target_centroid,                 \"name\": features[int(to_id)][\"properties\"][\"name\"],                 \"radius\": 3,                 \"gain\": -gain,             }         )         # eliminate duplicate arcs         if pair_key in pairs.keys():             continue          pairs[pair_key] = True          if gain &gt; 0:             arcs.append(                 {                     \"target\": target_centroid,                     \"source\": source_centroid,                     \"value\": flows[to_id],                 }             )         else:             arcs.append(                 {                     \"target\": source_centroid,                     \"source\": target_centroid,                     \"value\": flows[to_id],                 }             )      # add point at arc target     targets.append(         {             **total_value,             \"position\": [target_centroid[0], target_centroid[1], 10],             \"net\": total_value[\"gain\"] + total_value[\"loss\"],             \"name\": county[\"properties\"][\"name\"],         }     )  # sort targets by radius large -&gt; small targets = sorted(targets, key=lambda d: abs(d[\"net\"]), reverse=True) normalizer = Normalize(0, abs(targets[0][\"net\"])) <p>We define some color constants, as well as a color lookup array.</p> <p>A nice trick in numpy is that if you have a two-dimensional array like:</p> <pre>[\n    [166,   3,   3],\n    [ 35, 181, 184]\n]\n</pre> <p>you can perform a lookup based on the index to transform data from one dimensionality to another. In this case, we'll use <code>0</code> and <code>1</code> \u2014 the two available indexes of the array's first dimension \u2014 to create an array of colors.</p> <p>So when we call <code>COLORS[colors_lookup]</code> that creates an output array of something like:</p> <pre>[\n    [166,   3,   3],\n    [ 35, 181, 184],\n    [166,   3,   3],\n    [166,   3,   3]\n]\n</pre> <p>equal to the number of rows in our dataset. We can then pass this to any parameter that accepts a ColorAccessor.</p> In\u00a0[4]: Copied! <pre># migrate out\nSOURCE_COLOR = [166, 3, 3]\n# migrate in\nTARGET_COLOR = [35, 181, 184]\n# Combine into a single arr to use as a lookup table\nCOLORS = np.vstack(\n    [np.array(SOURCE_COLOR, dtype=np.uint8), np.array(TARGET_COLOR, dtype=np.uint8)]\n)\nSOURCE_LOOKUP = 0\nTARGET_LOOKUP = 1\n</pre> # migrate out SOURCE_COLOR = [166, 3, 3] # migrate in TARGET_COLOR = [35, 181, 184] # Combine into a single arr to use as a lookup table COLORS = np.vstack(     [np.array(SOURCE_COLOR, dtype=np.uint8), np.array(TARGET_COLOR, dtype=np.uint8)] ) SOURCE_LOOKUP = 0 TARGET_LOOKUP = 1 In\u00a0[5]: Copied! <pre>brushing_extension = BrushingExtension(brushing_radius=200000)\n</pre> brushing_extension = BrushingExtension(brushing_radius=200000) <p>Convert the <code>sources</code> list of dictionaries into a GeoPandas <code>GeoDataFrame</code> to pass into a <code>ScatterplotLayer</code>.</p> In\u00a0[6]: Copied! <pre>source_arr = np.array([source[\"position\"] for source in sources])\nsource_positions = shapely.points(source_arr[:, 0], source_arr[:, 1])\nsource_gdf = gpd.GeoDataFrame(\n    pd.DataFrame.from_records(sources)[[\"name\", \"radius\", \"gain\"]],\n    geometry=source_positions,\n)\n# We use a lookup table (`COLORS`) to apply either the target color or the source color\n# to the array\nsource_colors_lookup = np.where(source_gdf[\"gain\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP)\nsource_fill_colors = COLORS[source_colors_lookup]\n</pre> source_arr = np.array([source[\"position\"] for source in sources]) source_positions = shapely.points(source_arr[:, 0], source_arr[:, 1]) source_gdf = gpd.GeoDataFrame(     pd.DataFrame.from_records(sources)[[\"name\", \"radius\", \"gain\"]],     geometry=source_positions, ) # We use a lookup table (`COLORS`) to apply either the target color or the source color # to the array source_colors_lookup = np.where(source_gdf[\"gain\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP) source_fill_colors = COLORS[source_colors_lookup]  <p>Create a <code>ScatterplotLayer</code> for source points:</p> In\u00a0[7]: Copied! <pre>source_layer = ScatterplotLayer.from_geopandas(\n    source_gdf,\n    get_fill_color=source_fill_colors,\n    radius_scale=3000,\n    pickable=False,\n    extensions=[brushing_extension],\n)\n</pre> source_layer = ScatterplotLayer.from_geopandas(     source_gdf,     get_fill_color=source_fill_colors,     radius_scale=3000,     pickable=False,     extensions=[brushing_extension], ) In\u00a0[8]: Copied! <pre>targets_arr = np.array([target[\"position\"] for target in targets])\ntarget_positions = shapely.points(targets_arr[:, 0], targets_arr[:, 1])\ntarget_gdf = gpd.GeoDataFrame(\n    pd.DataFrame.from_records(targets)[[\"name\", \"gain\", \"loss\", \"net\"]],\n    geometry=target_positions,\n)\n# We use a lookup table (`COLORS`) to apply either the target color or the source color\n# to the array\ntarget_line_colors_lookup = np.where(target_gdf[\"net\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP)\ntarget_line_colors = COLORS[target_line_colors_lookup]\n</pre> targets_arr = np.array([target[\"position\"] for target in targets]) target_positions = shapely.points(targets_arr[:, 0], targets_arr[:, 1]) target_gdf = gpd.GeoDataFrame(     pd.DataFrame.from_records(targets)[[\"name\", \"gain\", \"loss\", \"net\"]],     geometry=target_positions, ) # We use a lookup table (`COLORS`) to apply either the target color or the source color # to the array target_line_colors_lookup = np.where(target_gdf[\"net\"] &gt; 0, TARGET_LOOKUP, SOURCE_LOOKUP) target_line_colors = COLORS[target_line_colors_lookup]  <p>Create a <code>ScatterplotLayer</code> for target points:</p> In\u00a0[9]: Copied! <pre>target_ring_layer = ScatterplotLayer.from_geopandas(\n    target_gdf,\n    get_line_color=target_line_colors,\n    radius_scale=4000,\n    pickable=True,\n    stroked=True,\n    filled=False,\n    line_width_min_pixels=2,\n    extensions=[brushing_extension],\n)\n</pre> target_ring_layer = ScatterplotLayer.from_geopandas(     target_gdf,     get_line_color=target_line_colors,     radius_scale=4000,     pickable=True,     stroked=True,     filled=False,     line_width_min_pixels=2,     extensions=[brushing_extension], ) <p>Note: the <code>ArcLayer</code> can't currently be created from a GeoDataFrame because it needs two point columns, not one. This is a large part of why it's still marked under the \"experimental\" module.</p> <p>Here we pass a numpy array for each point column. This is allowed as long as the shape of the array is <code>(N, 2)</code> or <code>(N, 3)</code> (i.e. 2D or 3D coordinates).</p> In\u00a0[10]: Copied! <pre>value = np.array([arc[\"value\"] for arc in arcs])\nget_source_position = np.array([arc[\"source\"] for arc in arcs])\nget_target_position = np.array([arc[\"target\"] for arc in arcs])\ntable = pa.table({\"value\": value})\n\narc_layer = ArcLayer(\n    table=table,\n    get_source_position=get_source_position,\n    get_target_position=get_target_position,\n    get_source_color=SOURCE_COLOR,\n    get_target_color=TARGET_COLOR,\n    get_width=1,\n    opacity=0.4,\n    pickable=False,\n    extensions=[brushing_extension],\n)\n</pre> value = np.array([arc[\"value\"] for arc in arcs]) get_source_position = np.array([arc[\"source\"] for arc in arcs]) get_target_position = np.array([arc[\"target\"] for arc in arcs]) table = pa.table({\"value\": value})  arc_layer = ArcLayer(     table=table,     get_source_position=get_source_position,     get_target_position=get_target_position,     get_source_color=SOURCE_COLOR,     get_target_color=TARGET_COLOR,     get_width=1,     opacity=0.4,     pickable=False,     extensions=[brushing_extension], ) <p>Now we can create a map using these three layers we've created.</p> <p>As you hover over the map, it should render only the arcs near your cursor.</p> <p>You can modify <code>brushing_extension.brushing_radius</code> to control how large the brush is around your cursor.</p> In\u00a0[11]: Copied! <pre>map_ = Map(layers=[source_layer, target_ring_layer, arc_layer], picking_radius=10)\nmap_\n</pre> map_ = Map(layers=[source_layer, target_ring_layer, arc_layer], picking_radius=10) map_ Out[11]: <pre>Map(layers=[ScatterplotLayer(extensions=[BrushingExtension(brushing_radius=200000.0)], get_fill_color=&lt;pyarrow\u2026</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/migration/#us-county-to-county-migration","title":"U.S. County-to-County Migration\u00b6","text":"<p>This notebook is derived from the original deck.gl example in JavaScript, which you can see here.</p> <p>This dataset originally came from the U.S. Census Bureau and represents people moving in and out of each county between 2009-2013.</p> <p>This also serves as a notebook for day 10 of 30 Day Map Challenge.</p>"},{"location":"examples/migration/#imports","title":"Imports\u00b6","text":""},{"location":"examples/north-america-roads/","title":"North America Roads","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport palettable.colorbrewer.diverging\n\nfrom lonboard import Map, PathLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd import palettable.colorbrewer.diverging  from lonboard import Map, PathLayer from lonboard.colormap import apply_continuous_cmap <p>The \"public\" URL for this dataset from the Natural Earth website is</p> <pre><code>https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_roads_north_america.zip\n</code></pre> <p>That doesn't appear to work directly inside a notebook, so we'll use the URL the above redirects to:</p> <pre><code>https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip\n</code></pre> <p>It's possible this \"private\" URL will change in the future.</p> In\u00a0[2]: Copied! <pre>url = 'https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip'\n</pre> url = 'https://naciscdn.org/naturalearth/10m/cultural/ne_10m_roads_north_america.zip' <p>We'll use GeoPandas to fetch this data (45MB) over the internet and load it into a <code>GeoDataFrame</code>. This uses the <code>pyogrio</code> engine, which is faster. Ensure you have <code>pyogrio</code> installed.</p> In\u00a0[3]: Copied! <pre>gdf = gpd.read_file(url, engine=\"pyogrio\")\n</pre> gdf = gpd.read_file(url, engine=\"pyogrio\") <p>This dataframe has a variety of attributes, plus a geometry column with a <code>LineString</code> type.</p> In\u00a0[4]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[4]: prefix number class type divided country state note scalerank uident length rank continent geometry 0 None None Other Unpaved None United States California None 12 0 10.373500 0 North America LINESTRING (-119.63954 37.85634, -119.63954 37... 1 None None Other Other Paved None United States Nevada None 12 1 2.307760 0 North America LINESTRING (-119.76779 39.14514, -119.74707 39... 2 None S2 Other Other Paved None Mexico None None 11 2 92.178100 -1 North America LINESTRING (-116.47485 33.09658, -116.46246 33... 3 None S1 Other Other Paved None United States California None 11 3 46.124100 0 North America LINESTRING (-116.56070 33.01205, -116.55359 33... 4 None S1 Other Secondary Undivided United States California None 10 4 0.305463 0 North America LINESTRING (-116.50827 32.81225, -116.50820 32... <p>To ensure that this demo is snappy on most computers, we'll filter to only the contiguous U.S. If you're on a recent computer, feel free to comment out this line.</p> In\u00a0[5]: Copied! <pre>gdf = gdf[gdf[\"state\"] == \"California\"]\n</pre> gdf = gdf[gdf[\"state\"] == \"California\"] <p>To render <code>LineString</code> data, first create a <code>PathLayer</code> and then add it to a <code>Map</code> object.</p> In\u00a0[6]: Copied! <pre>layer = PathLayer.from_geopandas(gdf, width_min_pixels=0.8)\nmap_ = Map(layers=[layer])\nmap_\n</pre> layer = PathLayer.from_geopandas(gdf, width_min_pixels=0.8) map_ = Map(layers=[layer]) map_ Out[6]: <pre>Map(layers=[PathLayer(table=pyarrow.Table\nprefix: string\nnumber: string\nclass: string\ntype: string\ndivided: st\u2026</pre> <p>We can look at the documentation for <code>PathLayer</code> to see what other rendering options it allows. Let's set the path color to something other than black:</p> In\u00a0[7]: Copied! <pre>layer.get_color = [200, 0, 200]\n</pre> layer.get_color = [200, 0, 200] <p>Ok, so we can see the data! That's great! But let's customize the rendering based on an attribute!</p> <p>The <code>scalerank</code> column tells how important the road is in the road network. Let's see what the distribution of values is for this column:</p> In\u00a0[8]: Copied! <pre>gdf['scalerank'].value_counts().sort_index()\n</pre> gdf['scalerank'].value_counts().sort_index() Out[8]: <pre>scalerank\n3       19\n4       93\n5       35\n6       94\n7      178\n8      122\n9        1\n10     237\n11     541\n12    1562\nName: count, dtype: int64</pre> <p>Ok, so the values range from <code>3</code> to <code>12</code>. To assign a colormap to this column, we need \"normalized\" values that span between 0 and 1:</p> In\u00a0[9]: Copied! <pre>normalized_scale_rank = (gdf['scalerank'] - 3) / 9\n</pre> normalized_scale_rank = (gdf['scalerank'] - 3) / 9 <p>The values of this array now range from 0 to 1:</p> In\u00a0[10]: Copied! <pre>normalized_scale_rank.min(), normalized_scale_rank.max()\n</pre> normalized_scale_rank.min(), normalized_scale_rank.max() Out[10]: <pre>(0.0, 1.0)</pre> <p>Let's select a colormap to apply to this data:</p> In\u00a0[11]: Copied! <pre>cmap = palettable.colorbrewer.diverging.PuOr_10\n</pre> cmap = palettable.colorbrewer.diverging.PuOr_10 In\u00a0[12]: Copied! <pre>cmap.mpl_colormap\n</pre> cmap.mpl_colormap Out[12]: PuOr  underbad over  <p>Now we'll use <code>apply_continuous_cmap</code> onto this array to generate colors for our data. Just set this new array onto the existing layer, and you'll see the map update with the new colors!</p> In\u00a0[13]: Copied! <pre>layer.get_color = apply_continuous_cmap(normalized_scale_rank, palettable.colorbrewer.diverging.PuOr_10, alpha=0.8)\n</pre> layer.get_color = apply_continuous_cmap(normalized_scale_rank, palettable.colorbrewer.diverging.PuOr_10, alpha=0.8) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/north-america-roads/#north-america-roads","title":"North America Roads\u00b6","text":"<p>This example uses data from Natural Earth to plot the road network in North America. Refer to the data documentation for more information about this dataset.</p>"},{"location":"examples/north-america-roads/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li>lonboard</li> <li>pyogrio</li> </ul>"},{"location":"examples/north-america-roads/#imports","title":"Imports\u00b6","text":""},{"location":"examples/integrations/color-picker/","title":"ColorPicker","text":"<p>Example gif:</p> <p></p> In\u00a0[1]: Copied! <pre>import geodatasets\nimport geopandas as gpd\nimport ipywidgets\n\nfrom lonboard import Map, SolidPolygonLayer\n</pre> import geodatasets import geopandas as gpd import ipywidgets  from lonboard import Map, SolidPolygonLayer <p><code>geodatasets.get_path</code> will download the dataset if it hasn't been downloaded and cached before.</p> In\u00a0[2]: Copied! <pre>gdf = gpd.read_file(geodatasets.get_path(\"nybb\"))\n</pre> gdf = gpd.read_file(geodatasets.get_path(\"nybb\")) <p>Create our basic map:</p> In\u00a0[3]: Copied! <pre>layer = SolidPolygonLayer.from_geopandas(gdf)\nmap_ = Map(layers=[layer])\nmap_\n</pre> layer = SolidPolygonLayer.from_geopandas(gdf) map_ = Map(layers=[layer]) map_ <pre>/Users/kyle/github/developmentseed/lonboard/lonboard/_layer.py:99: UserWarning: GeoDataFrame being reprojected to EPSG:4326\n  warnings.warn(\"GeoDataFrame being reprojected to EPSG:4326\")\n</pre> Out[3]: <pre>Map(layers=[SolidPolygonLayer(table=pyarrow.Table\nBoroCode: int64\nBoroName: string\nShape_Leng: double\nShape_Ar\u2026</pre> <p>Create the <code>ColorPicker</code> widget:</p> In\u00a0[4]: Copied! <pre>color_picker = ipywidgets.ColorPicker()\ncolor_picker\n</pre> color_picker = ipywidgets.ColorPicker() color_picker Out[4]: <pre>ColorPicker(value='black')</pre> <p>Note that the \"data\" contained by the <code>color_picker</code> instance is held by the <code>value</code> attribute:</p> In\u00a0[5]: Copied! <pre>color_picker.value\n</pre> color_picker.value Out[5]: <pre>'black'</pre> <p>We'll now link the two widgets together, so that whenever the color picker is updated, <code>ipywidgets</code> will update the value of <code>get_fill_color</code> on the layer.</p> <p>The format of <code>dlink</code> is:</p> <ul> <li>tuple: (source widget, attribute of source widget)</li> <li>tuple: (target widget, attribute of target widget)</li> </ul> <p>So we use the below syntax to link <code>color_picker.value</code> to <code>layer.get_fill_color</code>.</p> <p>We need to use <code>dlink</code>, not <code>link</code>, which creates a one-directional link (from the color picker to the layer) and not a bi-directional link. This is because the color picker and the layer have a different color representation under the hood (<code>ColorPicker</code> stores a hex string; the <code>SolidPolygonLayer</code> works in terms of RGBA color integers).</p> In\u00a0[6]: Copied! <pre>ipywidgets.dlink(\n    (color_picker, 'value'),\n    (layer, 'get_fill_color')\n)\n</pre> ipywidgets.dlink(     (color_picker, 'value'),     (layer, 'get_fill_color') ) Out[6]: <pre>&lt;traitlets.traitlets.directional_link at 0x168822610&gt;</pre> <p>Now click on the color widget and change the color! You need to press Enter to select a specific color.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/integrations/color-picker/#colorpicker","title":"ColorPicker\u00b6","text":"<p>Use lonboard with an ipywidgets ColorPicker object.</p>"},{"location":"examples/integrations/color-picker/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li><p>lonboard</p> </li> <li><p>geodatasets</p> <p>Run <code>pip install geodatasets</code> if needed.</p> </li> </ul>"},{"location":"examples/integrations/color-picker/#imports","title":"Imports\u00b6","text":""},{"location":"examples/integrations/sidecar/","title":"Sidecar","text":"<p>The goal of this notebook is to show how using Jupyter Sidecar can help to interactively explore and understand your data.</p> <p>Note that sidecar only works in JupyterLab and will not work in other notebook frontends like Colab.</p> <p></p> In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport ipywidgets\nimport matplotlib as mpl\nimport pandas as pd\nfrom palettable.colorbrewer.diverging import BrBG_10\nfrom sidecar import Sidecar\n\nfrom lonboard import Map, ScatterplotLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd import ipywidgets import matplotlib as mpl import pandas as pd from palettable.colorbrewer.diverging import BrBG_10 from sidecar import Sidecar  from lonboard import Map, ScatterplotLayer from lonboard.colormap import apply_continuous_cmap <p>For this example, we'll use a dataset of abandoned cars in Chicago. Since this is a CSV file, we need to pass in the names of the X and Y columns into the \"open options\" to pass to OGR.</p> In\u00a0[2]: Copied! <pre>url = \"https://geodacenter.github.io/data-and-lab/data/Abandoned_Vehicles_Map.csv\"\ngdf = gpd.read_file(\n    url,\n    engine=\"pyogrio\",\n    use_arrow=True,\n    X_POSSIBLE_NAMES=\"Longitude\",\n    Y_POSSIBLE_NAMES=\"Latitude\",\n    KEEP_GEOM_COLUMNS=\"NO\",\n)\n</pre> url = \"https://geodacenter.github.io/data-and-lab/data/Abandoned_Vehicles_Map.csv\" gdf = gpd.read_file(     url,     engine=\"pyogrio\",     use_arrow=True,     X_POSSIBLE_NAMES=\"Longitude\",     Y_POSSIBLE_NAMES=\"Latitude\",     KEEP_GEOM_COLUMNS=\"NO\", ) <p>This dataset has some null values for geometries. We'll remove these first:</p> In\u00a0[3]: Copied! <pre>gdf = gdf[gdf.geometry != None]\n</pre> gdf = gdf[gdf.geometry != None] <p>Let's also remove empty values from another column to make later steps easier (when modifying a single map object with lonboard, you can't change the number of rows).</p> In\u00a0[4]: Copied! <pre>gdf = gdf[gdf[\"How Many Days Has the Vehicle Been Reported as Parked?\"] != \"\"]\n</pre> gdf = gdf[gdf[\"How Many Days Has the Vehicle Been Reported as Parked?\"] != \"\"] <p>We'll now initialize the <code>Sidecar</code> object, which splits the JupyterLab screen in half, creating the output area for our widget.</p> In\u00a0[5]: Copied! <pre>sc = Sidecar(title='My Map')\n</pre> sc = Sidecar(title='My Map') <p>Now let's create a map layer from our <code>GeoDataFrame</code>.</p> <p>The default map height is 500 pixels, but we'd like to have a taller map because it's vertical. This API may change in the future.</p> In\u00a0[6]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nmap_ = Map(layers=[layer])\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) map_ = Map(layers=[layer]) <p>Now we can render this inside the sidecar. You should see the map appear on the right side of your screen.</p> In\u00a0[7]: Copied! <pre>with sc:\n    display(map_)\n</pre> with sc:     display(map_) <p>It's great that we can see the map, but let's customize the rendering a bit. There's a column in the data titled</p> <p>How Many Days Has the Vehicle Been Reported as Parked?</p> <p>Let's use this column to visualize how long it takes to remove a car in different areas of the city.</p> <p>This is a string column, so first let's convert it to a numeric value.</p> In\u00a0[8]: Copied! <pre>colname = \"How Many Days Has the Vehicle Been Reported as Parked?\"\ngdf[colname] = pd.to_numeric(gdf[colname])\n</pre> colname = \"How Many Days Has the Vehicle Been Reported as Parked?\" gdf[colname] = pd.to_numeric(gdf[colname]) <p>In order to apply a colormap onto our data, we need to normalize our values to the range of <code>0-1</code>. Matplotlib offers several normalization options. See the tutorial and the <code>matplotlib.colors</code> module.</p> <p>To start, we'll do a simple linear normalization, converting from 0-90 to 0-1. Any values below 0 will be clamped to 0, and any values above 90 will be clamped to 1.</p> In\u00a0[9]: Copied! <pre>normalizer = mpl.colors.Normalize(0, 90)\nnormalized_values = normalizer(gdf[colname])\n</pre> normalizer = mpl.colors.Normalize(0, 90) normalized_values = normalizer(gdf[colname]) <p>These values now range between 0 and 1:</p> In\u00a0[10]: Copied! <pre>normalized_values\n</pre> normalized_values Out[10]: <pre>masked_array(data=[0.22222222, 0.26666667, 0.66666667, ..., 0.62222222,\n                   1.03333333, 0.33333333],\n             mask=False,\n       fill_value=1e+20)</pre> In\u00a0[11]: Copied! <pre>BrBG_10.mpl_colormap\n</pre> BrBG_10.mpl_colormap Out[11]: BrBG  underbad over  In\u00a0[12]: Copied! <pre>layer.radius_min_pixels = 0.5\nlayer.get_fill_color = apply_continuous_cmap(normalized_values, BrBG_10)\n</pre> layer.radius_min_pixels = 0.5 layer.get_fill_color = apply_continuous_cmap(normalized_values, BrBG_10) <p>Now the circles on the map have colors based on the time they've been parked.</p> <p>But this dataset is skewed with a long tail. Most cars have been sitting way less than 90 days, but a few have been sitting even longer.</p> <p>A logarithmic normalization (aka matplotlib's <code>LogNorm</code>) might be more useful here:</p> In\u00a0[13]: Copied! <pre>log_normalizer = mpl.colors.LogNorm(3, 90, clip=True)\nlog_values = log_normalizer(gdf[colname])\n</pre> log_normalizer = mpl.colors.LogNorm(3, 90, clip=True) log_values = log_normalizer(gdf[colname]) In\u00a0[14]: Copied! <pre>layer.get_fill_color = apply_continuous_cmap(log_values, BrBG_10)\nlayer.get_radius = log_values * 50\nlayer.radius_units = \"meters\"\n</pre> layer.get_fill_color = apply_continuous_cmap(log_values, BrBG_10) layer.get_radius = log_values * 50 layer.radius_units = \"meters\" In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/integrations/sidecar/#sidecar","title":"Sidecar\u00b6","text":""},{"location":"examples/integrations/sidecar/#dependencies","title":"Dependencies\u00b6","text":"<ul> <li>lonboard</li> <li>sidecar</li> <li>pyogrio</li> </ul> <p>Run</p> <pre><code>pip install sidecar pyogrio\n</code></pre> <p>if needed. You may need to restart Jupyter and/or refresh your browser tab after installing <code>sidecar</code>.</p>"},{"location":"examples/integrations/sidecar/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/1-points/","title":"30 Day Map Challenge: Day 1 (Points)","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport matplotlib as mpl\nimport numpy as np\nimport pandas as pd\nimport shapely\n\nfrom lonboard import Map, ScatterplotLayer\n</pre> import geopandas as gpd import matplotlib as mpl import numpy as np import pandas as pd import shapely  from lonboard import Map, ScatterplotLayer In\u00a0[2]: Copied! <pre>path = \"/Users/kyle/Downloads/Motor_Vehicle_Collisions_-_Crashes_20231101.csv\"\n</pre> path = \"/Users/kyle/Downloads/Motor_Vehicle_Collisions_-_Crashes_20231101.csv\" <p>Read the data:</p> In\u00a0[3]: Copied! <pre>df = pd.read_csv(path, dtype={\"ZIP CODE\": str})\n</pre> df = pd.read_csv(path, dtype={\"ZIP CODE\": str}) <p>Let's first take a peek at our data:</p> In\u00a0[4]: Copied! <pre>pd.options.display.max_columns = None\ndf.head()\n</pre> pd.options.display.max_columns = None df.head() Out[4]: CRASH DATE CRASH TIME BOROUGH ZIP CODE LATITUDE LONGITUDE LOCATION ON STREET NAME CROSS STREET NAME OFF STREET NAME NUMBER OF PERSONS INJURED NUMBER OF PERSONS KILLED NUMBER OF PEDESTRIANS INJURED NUMBER OF PEDESTRIANS KILLED NUMBER OF CYCLIST INJURED NUMBER OF CYCLIST KILLED NUMBER OF MOTORIST INJURED NUMBER OF MOTORIST KILLED CONTRIBUTING FACTOR VEHICLE 1 CONTRIBUTING FACTOR VEHICLE 2 CONTRIBUTING FACTOR VEHICLE 3 CONTRIBUTING FACTOR VEHICLE 4 CONTRIBUTING FACTOR VEHICLE 5 COLLISION_ID VEHICLE TYPE CODE 1 VEHICLE TYPE CODE 2 VEHICLE TYPE CODE 3 VEHICLE TYPE CODE 4 VEHICLE TYPE CODE 5 0 09/11/2021 2:39 NaN NaN NaN NaN NaN WHITESTONE EXPRESSWAY 20 AVENUE NaN 2.0 0.0 0 0 0 0 2 0 Aggressive Driving/Road Rage Unspecified NaN NaN NaN 4455765 Sedan Sedan NaN NaN NaN 1 03/26/2022 11:45 NaN NaN NaN NaN NaN QUEENSBORO BRIDGE UPPER NaN NaN 1.0 0.0 0 0 0 0 1 0 Pavement Slippery NaN NaN NaN NaN 4513547 Sedan NaN NaN NaN NaN 2 06/29/2022 6:55 NaN NaN NaN NaN NaN THROGS NECK BRIDGE NaN NaN 0.0 0.0 0 0 0 0 0 0 Following Too Closely Unspecified NaN NaN NaN 4541903 Sedan Pick-up Truck NaN NaN NaN 3 09/11/2021 9:35 BROOKLYN 11208 40.667202 -73.866500 (40.667202, -73.8665) NaN NaN 1211      LORING AVENUE 0.0 0.0 0 0 0 0 0 0 Unspecified NaN NaN NaN NaN 4456314 Sedan NaN NaN NaN NaN 4 12/14/2021 8:13 BROOKLYN 11233 40.683304 -73.917274 (40.683304, -73.917274) SARATOGA AVENUE DECATUR STREET NaN 0.0 0.0 0 0 0 0 0 0 NaN NaN NaN NaN NaN 4486609 NaN NaN NaN NaN NaN <p>There are a bunch of columns in this dataset:</p> In\u00a0[5]: Copied! <pre>df.columns\n</pre> df.columns Out[5]: <pre>Index(['CRASH DATE', 'CRASH TIME', 'BOROUGH', 'ZIP CODE', 'LATITUDE',\n       'LONGITUDE', 'LOCATION', 'ON STREET NAME', 'CROSS STREET NAME',\n       'OFF STREET NAME', 'NUMBER OF PERSONS INJURED',\n       'NUMBER OF PERSONS KILLED', 'NUMBER OF PEDESTRIANS INJURED',\n       'NUMBER OF PEDESTRIANS KILLED', 'NUMBER OF CYCLIST INJURED',\n       'NUMBER OF CYCLIST KILLED', 'NUMBER OF MOTORIST INJURED',\n       'NUMBER OF MOTORIST KILLED', 'CONTRIBUTING FACTOR VEHICLE 1',\n       'CONTRIBUTING FACTOR VEHICLE 2', 'CONTRIBUTING FACTOR VEHICLE 3',\n       'CONTRIBUTING FACTOR VEHICLE 4', 'CONTRIBUTING FACTOR VEHICLE 5',\n       'COLLISION_ID', 'VEHICLE TYPE CODE 1', 'VEHICLE TYPE CODE 2',\n       'VEHICLE TYPE CODE 3', 'VEHICLE TYPE CODE 4', 'VEHICLE TYPE CODE 5'],\n      dtype='object')</pre> <p>Let's keep only specific columns that we care about:</p> In\u00a0[6]: Copied! <pre>keep_cols = [\n    \"CRASH DATE\",\n    \"CRASH TIME\",\n    \"LATITUDE\",\n    \"LONGITUDE\",\n    \"NUMBER OF PERSONS INJURED\",\n    \"NUMBER OF PERSONS KILLED\",\n    \"NUMBER OF PEDESTRIANS INJURED\",\n    \"NUMBER OF PEDESTRIANS KILLED\",\n    \"NUMBER OF CYCLIST INJURED\",\n    \"NUMBER OF CYCLIST KILLED\",\n    \"NUMBER OF MOTORIST INJURED\",\n    \"NUMBER OF MOTORIST KILLED\",\n    \"COLLISION_ID\",\n]\ndf = df[keep_cols]\n</pre> keep_cols = [     \"CRASH DATE\",     \"CRASH TIME\",     \"LATITUDE\",     \"LONGITUDE\",     \"NUMBER OF PERSONS INJURED\",     \"NUMBER OF PERSONS KILLED\",     \"NUMBER OF PEDESTRIANS INJURED\",     \"NUMBER OF PEDESTRIANS KILLED\",     \"NUMBER OF CYCLIST INJURED\",     \"NUMBER OF CYCLIST KILLED\",     \"NUMBER OF MOTORIST INJURED\",     \"NUMBER OF MOTORIST KILLED\",     \"COLLISION_ID\", ] df = df[keep_cols] <p>About 11% of the data have missing locations. For this quick demo, I don't have the ability to georeference those rows based on street name, so we'll just remove them. Hopefully there isn't a skew where crashes in some areas are more likely to not be georeferenced.</p> In\u00a0[7]: Copied! <pre>(df[\"LONGITUDE\"].isnull() | df[\"LATITUDE\"].isnull()).mean()\n</pre> (df[\"LONGITUDE\"].isnull() | df[\"LATITUDE\"].isnull()).mean() Out[7]: <pre>0.11342612579376604</pre> <p>Keep only the rows where longitude and latitude are not null.</p> In\u00a0[8]: Copied! <pre>df = df[(df[\"LONGITUDE\"].notnull() &amp; df[\"LATITUDE\"].notnull())]\n</pre> df = df[(df[\"LONGITUDE\"].notnull() &amp; df[\"LATITUDE\"].notnull())] <p>This dataset has crash data from the end of 2021, all of 2022, and thus far in 2023. For simplicity and regularity, let's choose only data from 2022.</p> <p>We'll convert the date to a datetime column and then select rows where the date happened in 2022:</p> In\u00a0[9]: Copied! <pre>df[\"CRASH DATE\"] = pd.to_datetime(df[\"CRASH DATE\"])\ndf = df[df[\"CRASH DATE\"].dt.year == 2022]\n</pre> df[\"CRASH DATE\"] = pd.to_datetime(df[\"CRASH DATE\"]) df = df[df[\"CRASH DATE\"].dt.year == 2022] <p>Let's also convert the time column from a string to a timestamp.</p> In\u00a0[10]: Copied! <pre>df[\"CRASH TIME\"] = pd.to_datetime(df[\"CRASH TIME\"], format=\"%H:%M\")\n</pre> df[\"CRASH TIME\"] = pd.to_datetime(df[\"CRASH TIME\"], format=\"%H:%M\") <p>If we look at the data types in our data, they were inferred as <code>int64</code> and <code>float64</code> data types:</p> In\u00a0[11]: Copied! <pre>df.dtypes\n</pre> df.dtypes Out[11]: <pre>CRASH DATE                       datetime64[ns]\nCRASH TIME                       datetime64[ns]\nLATITUDE                                float64\nLONGITUDE                               float64\nNUMBER OF PERSONS INJURED               float64\nNUMBER OF PERSONS KILLED                float64\nNUMBER OF PEDESTRIANS INJURED             int64\nNUMBER OF PEDESTRIANS KILLED              int64\nNUMBER OF CYCLIST INJURED                 int64\nNUMBER OF CYCLIST KILLED                  int64\nNUMBER OF MOTORIST INJURED                int64\nNUMBER OF MOTORIST KILLED                 int64\nCOLLISION_ID                              int64\ndtype: object</pre> <p>Knowing that our data holds small values, we can downcast to smaller data types:</p> In\u00a0[12]: Copied! <pre>for numeric_col_name in df.select_dtypes(\"number\").columns:\n    df[numeric_col_name] = pd.to_numeric(df[numeric_col_name], downcast=\"unsigned\")\n</pre> for numeric_col_name in df.select_dtypes(\"number\").columns:     df[numeric_col_name] = pd.to_numeric(df[numeric_col_name], downcast=\"unsigned\") <p>Now our data types are much smaller:</p> In\u00a0[13]: Copied! <pre>df.dtypes\n</pre> df.dtypes Out[13]: <pre>CRASH DATE                       datetime64[ns]\nCRASH TIME                       datetime64[ns]\nLATITUDE                                float64\nLONGITUDE                               float64\nNUMBER OF PERSONS INJURED                 uint8\nNUMBER OF PERSONS KILLED                  uint8\nNUMBER OF PEDESTRIANS INJURED             uint8\nNUMBER OF PEDESTRIANS KILLED              uint8\nNUMBER OF CYCLIST INJURED                 uint8\nNUMBER OF CYCLIST KILLED                  uint8\nNUMBER OF MOTORIST INJURED                uint8\nNUMBER OF MOTORIST KILLED                 uint8\nCOLLISION_ID                             uint32\ndtype: object</pre> <p>Now let's construct a GeoDataFrame from this data.</p> In\u00a0[14]: Copied! <pre>geometry = shapely.points(df.pop(\"LONGITUDE\"), df.pop(\"LATITUDE\"))\ngdf = gpd.GeoDataFrame(df, geometry=geometry)\n</pre> geometry = shapely.points(df.pop(\"LONGITUDE\"), df.pop(\"LATITUDE\")) gdf = gpd.GeoDataFrame(df, geometry=geometry) In\u00a0[15]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[15]: CRASH DATE CRASH TIME NUMBER OF PERSONS INJURED NUMBER OF PERSONS KILLED NUMBER OF PEDESTRIANS INJURED NUMBER OF PEDESTRIANS KILLED NUMBER OF CYCLIST INJURED NUMBER OF CYCLIST KILLED NUMBER OF MOTORIST INJURED NUMBER OF MOTORIST KILLED COLLISION_ID geometry 37 2022-07-12 1900-01-01 17:50:00 0 0 0 0 0 0 0 0 4545699 POINT (-73.96049 40.66330) 40 2022-04-24 1900-01-01 16:45:00 1 0 0 0 0 0 1 0 4521660 POINT (-74.13892 40.60768) 41 2022-04-24 1900-01-01 04:49:00 0 0 0 0 0 0 0 0 4521759 POINT (-73.86990 40.85597) 42 2022-04-22 1900-01-01 17:17:00 1 0 1 0 0 0 0 0 4522226 POINT (-73.93960 40.79028) 43 2022-04-24 1900-01-01 01:30:00 0 0 0 0 0 0 0 0 4522015 POINT (-74.01621 40.64299) <p>If we look at the bounding box of our data, we see that some points are way outside of NYC. Let's filter to include only the data in the NYC region:</p> In\u00a0[16]: Copied! <pre>gdf.total_bounds\n</pre> gdf.total_bounds Out[16]: <pre>array([-74.25496 ,   0.      ,   0.      ,  40.912167])</pre> In\u00a0[17]: Copied! <pre>nyc_bbox = [-74.382742, 40.428857, -73.452477, 41.092696]\n</pre> nyc_bbox = [-74.382742, 40.428857, -73.452477, 41.092696] In\u00a0[18]: Copied! <pre>gdf = gdf[gdf.intersects(shapely.box(*nyc_bbox))]\n</pre> gdf = gdf[gdf.intersects(shapely.box(*nyc_bbox))] In\u00a0[19]: Copied! <pre>layer = ScatterplotLayer.from_geopandas(gdf)\nmap = Map(layers=[layer], _height=800)\nmap\n</pre> layer = ScatterplotLayer.from_geopandas(gdf) map = Map(layers=[layer], _height=800) map Out[19]: <pre>Map(layers=[ScatterplotLayer(table=pyarrow.Table\nCRASH DATE: timestamp[ns]\nCRASH TIME: timestamp[ns]\nNUMBER OF\u2026</pre> <p>Ok cool, we can see something on the map, but let's make our visualization more interesting.</p> <p>Let's compute the number of non-motorists injured in each collision:</p> In\u00a0[20]: Copied! <pre>num_injured = gdf[\"NUMBER OF PEDESTRIANS INJURED\"] + gdf[\"NUMBER OF CYCLIST INJURED\"]\n</pre> num_injured = gdf[\"NUMBER OF PEDESTRIANS INJURED\"] + gdf[\"NUMBER OF CYCLIST INJURED\"] <p>We can see a quick distribution with <code>value_counts</code></p> In\u00a0[21]: Copied! <pre>num_injured.value_counts()\n</pre> num_injured.value_counts() Out[21]: <pre>0    80613\n1    12057\n2      356\n3       37\n4        3\n5        3\nName: count, dtype: int64</pre> In\u00a0[22]: Copied! <pre>layer.get_radius = np.array(num_injured + 1)\nlayer.radius_scale = 50\nlayer.opacity = 0.05\n</pre> layer.get_radius = np.array(num_injured + 1) layer.radius_scale = 50 layer.opacity = 0.05 <p>Next, let's color each dot by time of day. We'll use a cyclic colormap that starts and ends on the same color, because the time of day is cyclic.</p> In\u00a0[23]: Copied! <pre>colormap = mpl.colormaps[\"twilight\"]\ncolormap\n</pre> colormap = mpl.colormaps[\"twilight\"] colormap Out[23]: twilight  underbad over  <p>Next get the minute of day of the crash:</p> In\u00a0[24]: Copied! <pre>minute_of_day = gdf[\"CRASH TIME\"].dt.hour * 60 + gdf[\"CRASH TIME\"].dt.minute\n</pre> minute_of_day = gdf[\"CRASH TIME\"].dt.hour * 60 + gdf[\"CRASH TIME\"].dt.minute <p>To apply a colormap, we need to normalize the <code>minute_of_day</code> series to <code>0-1</code>. We can do this with matplotlib's <code>Normalize</code>. We set the minimum value to 0 and the maximum value to the number of minutes in a day.</p> In\u00a0[25]: Copied! <pre>normalizer = mpl.colors.Normalize(0, 24 * 60)\nnormalized_minutes = normalizer(minute_of_day)\n</pre> normalizer = mpl.colors.Normalize(0, 24 * 60) normalized_minutes = normalizer(minute_of_day) <p>Now <code>normalized_minutes</code> ranges from 0-1:</p> In\u00a0[26]: Copied! <pre>normalized_minutes\n</pre> normalized_minutes Out[26]: <pre>masked_array(data=[0.74305556, 0.69791667, 0.20069444, ..., 0.54166667,\n                   0.625     , 0.60069444],\n             mask=False,\n       fill_value=1e+20)</pre> <p>Next we can apply the matplotlib colormap on our normalized values. We set <code>bytes=True</code> to ensure the output is of <code>uint8</code> data type.</p> In\u00a0[27]: Copied! <pre>colors = colormap(normalized_minutes, bytes=True)\n</pre> colors = colormap(normalized_minutes, bytes=True) In\u00a0[28]: Copied! <pre>colors\n</pre> colors Out[28]: <pre>array([[175,  81,  81, 255],\n       [156,  57,  79, 255],\n       [109, 144, 191, 255],\n       ...,\n       [ 63,  17,  60, 255],\n       [115,  29,  78, 255],\n       [ 99,  24,  75, 255]], dtype=uint8)</pre> In\u00a0[29]: Copied! <pre>layer.get_fill_color = colors\n</pre> layer.get_fill_color = colors In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map_challenge/1-points/#30-day-map-challenge-day-1-points","title":"30 Day Map Challenge: Day 1 (Points)\u00b6","text":"<p>This is a notebook for day 1 of 30 Day Map Challenge.</p>"},{"location":"examples/map_challenge/1-points/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/1-points/#access-the-data","title":"Access the data\u00b6","text":"<p>This data comes from NYC Open Data, where we use Motor Vehicle Collisions - Crashes. First download this data via <code>Export &gt; CSV</code>, save it somewhere on disk, and update the <code>path</code> variable in the next cell for that location.</p>"},{"location":"examples/map_challenge/6-asia/","title":"30 Day Map Challenge: Day 6 (Asia)","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nfrom palettable.colorbrewer.sequential import Blues_8\n\nfrom lonboard import Map, PathLayer\nfrom lonboard.colormap import apply_continuous_cmap\n</pre> import geopandas as gpd from palettable.colorbrewer.sequential import Blues_8  from lonboard import Map, PathLayer from lonboard.colormap import apply_continuous_cmap In\u00a0[2]: Copied! <pre>url = \"https://storage.googleapis.com/fao-maps-catalog-data/geonetwork/aquamaps/rivers_asia_37331.zip\"\n</pre> url = \"https://storage.googleapis.com/fao-maps-catalog-data/geonetwork/aquamaps/rivers_asia_37331.zip\" In\u00a0[3]: Copied! <pre>gdf = gpd.read_file(url, engine=\"pyogrio\")\n</pre> gdf = gpd.read_file(url, engine=\"pyogrio\") <p>The <code>Strahler</code> column seems to refer to how important/central the particular river is. It ranges from 1-7.</p> In\u00a0[4]: Copied! <pre>gdf['Strahler'].value_counts()\n</pre> gdf['Strahler'].value_counts() Out[4]: <pre>Strahler\n1    80503\n2    39100\n3    19655\n4     8960\n5     4547\n6     1901\n7      484\nName: count, dtype: int64</pre> <p>We'll use <code>Strahler</code> to plot more central rivers in both a darker blue and with a wider line.</p> In\u00a0[5]: Copied! <pre>layer = PathLayer.from_geopandas(gdf)\nlayer.get_color = apply_continuous_cmap(gdf['Strahler'] / 7, Blues_8)\nlayer.get_width = gdf['Strahler']\nlayer.width_scale = 3000\nlayer.width_min_pixels = 0.5\n\nm = Map(layers=[layer])\nm\n</pre> layer = PathLayer.from_geopandas(gdf) layer.get_color = apply_continuous_cmap(gdf['Strahler'] / 7, Blues_8) layer.get_width = gdf['Strahler'] layer.width_scale = 3000 layer.width_min_pixels = 0.5  m = Map(layers=[layer]) m Out[5]: <pre>Map(layers=[PathLayer(get_color=&lt;pyarrow.lib.FixedSizeListArray object at 0x107cbb220&gt;\n[\n  [\n    8,\n    69,\n  \u2026</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map_challenge/6-asia/#30-day-map-challenge-day-6-asia","title":"30 Day Map Challenge: Day 6 (Asia)\u00b6","text":"<p>This is a notebook for day 6 of 30 Day Map Challenge.</p> <p>This data comes from the UN's \"Rivers of South and East Asia\".</p>"},{"location":"examples/map_challenge/6-asia/#imports","title":"Imports\u00b6","text":""},{"location":"examples/map_challenge/6-asia/#fetch-the-data","title":"Fetch the data\u00b6","text":""}]}